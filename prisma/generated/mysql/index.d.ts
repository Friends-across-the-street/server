
/**
 * Client
**/

import * as runtime from './runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model incumbentsAdditional
 * 
 */
export type incumbentsAdditional = $Result.DefaultSelection<Prisma.$incumbentsAdditionalPayload>
/**
 * Model studentsAdditional
 * 
 */
export type studentsAdditional = $Result.DefaultSelection<Prisma.$studentsAdditionalPayload>
/**
 * Model category
 * 
 */
export type category = $Result.DefaultSelection<Prisma.$categoryPayload>
/**
 * Model posts
 * 
 */
export type posts = $Result.DefaultSelection<Prisma.$postsPayload>
/**
 * Model comments
 * 
 */
export type comments = $Result.DefaultSelection<Prisma.$commentsPayload>
/**
 * Model recommendPosts
 * 
 */
export type recommendPosts = $Result.DefaultSelection<Prisma.$recommendPostsPayload>
/**
 * Model reportedPosts
 * 
 */
export type reportedPosts = $Result.DefaultSelection<Prisma.$reportedPostsPayload>
/**
 * Model recommendComments
 * 
 */
export type recommendComments = $Result.DefaultSelection<Prisma.$recommendCommentsPayload>
/**
 * Model reportedComments
 * 
 */
export type reportedComments = $Result.DefaultSelection<Prisma.$reportedCommentsPayload>
/**
 * Model reportedUsers
 * 
 */
export type reportedUsers = $Result.DefaultSelection<Prisma.$reportedUsersPayload>
/**
 * Model company
 * 
 */
export type company = $Result.DefaultSelection<Prisma.$companyPayload>
/**
 * Model school
 * 
 */
export type school = $Result.DefaultSelection<Prisma.$schoolPayload>
/**
 * Model major
 * 
 */
export type major = $Result.DefaultSelection<Prisma.$majorPayload>
/**
 * Model bigJobKind
 * 
 */
export type bigJobKind = $Result.DefaultSelection<Prisma.$bigJobKindPayload>
/**
 * Model midJobKind
 * 
 */
export type midJobKind = $Result.DefaultSelection<Prisma.$midJobKindPayload>
/**
 * Model smallJobKind
 * 
 */
export type smallJobKind = $Result.DefaultSelection<Prisma.$smallJobKindPayload>
/**
 * Model job
 * 
 */
export type job = $Result.DefaultSelection<Prisma.$jobPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Gender: {
  male: 'male',
  female: 'female'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const userType: {
  incumbent: 'incumbent',
  student: 'student',
  admin: 'admin'
};

export type userType = (typeof userType)[keyof typeof userType]

}

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type userType = $Enums.userType

export const userType: typeof $Enums.userType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs>;

  /**
   * `prisma.incumbentsAdditional`: Exposes CRUD operations for the **incumbentsAdditional** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IncumbentsAdditionals
    * const incumbentsAdditionals = await prisma.incumbentsAdditional.findMany()
    * ```
    */
  get incumbentsAdditional(): Prisma.incumbentsAdditionalDelegate<ExtArgs>;

  /**
   * `prisma.studentsAdditional`: Exposes CRUD operations for the **studentsAdditional** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentsAdditionals
    * const studentsAdditionals = await prisma.studentsAdditional.findMany()
    * ```
    */
  get studentsAdditional(): Prisma.studentsAdditionalDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.categoryDelegate<ExtArgs>;

  /**
   * `prisma.posts`: Exposes CRUD operations for the **posts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.posts.findMany()
    * ```
    */
  get posts(): Prisma.postsDelegate<ExtArgs>;

  /**
   * `prisma.comments`: Exposes CRUD operations for the **comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comments.findMany()
    * ```
    */
  get comments(): Prisma.commentsDelegate<ExtArgs>;

  /**
   * `prisma.recommendPosts`: Exposes CRUD operations for the **recommendPosts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecommendPosts
    * const recommendPosts = await prisma.recommendPosts.findMany()
    * ```
    */
  get recommendPosts(): Prisma.recommendPostsDelegate<ExtArgs>;

  /**
   * `prisma.reportedPosts`: Exposes CRUD operations for the **reportedPosts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportedPosts
    * const reportedPosts = await prisma.reportedPosts.findMany()
    * ```
    */
  get reportedPosts(): Prisma.reportedPostsDelegate<ExtArgs>;

  /**
   * `prisma.recommendComments`: Exposes CRUD operations for the **recommendComments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RecommendComments
    * const recommendComments = await prisma.recommendComments.findMany()
    * ```
    */
  get recommendComments(): Prisma.recommendCommentsDelegate<ExtArgs>;

  /**
   * `prisma.reportedComments`: Exposes CRUD operations for the **reportedComments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportedComments
    * const reportedComments = await prisma.reportedComments.findMany()
    * ```
    */
  get reportedComments(): Prisma.reportedCommentsDelegate<ExtArgs>;

  /**
   * `prisma.reportedUsers`: Exposes CRUD operations for the **reportedUsers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReportedUsers
    * const reportedUsers = await prisma.reportedUsers.findMany()
    * ```
    */
  get reportedUsers(): Prisma.reportedUsersDelegate<ExtArgs>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.companyDelegate<ExtArgs>;

  /**
   * `prisma.school`: Exposes CRUD operations for the **school** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schools
    * const schools = await prisma.school.findMany()
    * ```
    */
  get school(): Prisma.schoolDelegate<ExtArgs>;

  /**
   * `prisma.major`: Exposes CRUD operations for the **major** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Majors
    * const majors = await prisma.major.findMany()
    * ```
    */
  get major(): Prisma.majorDelegate<ExtArgs>;

  /**
   * `prisma.bigJobKind`: Exposes CRUD operations for the **bigJobKind** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BigJobKinds
    * const bigJobKinds = await prisma.bigJobKind.findMany()
    * ```
    */
  get bigJobKind(): Prisma.bigJobKindDelegate<ExtArgs>;

  /**
   * `prisma.midJobKind`: Exposes CRUD operations for the **midJobKind** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MidJobKinds
    * const midJobKinds = await prisma.midJobKind.findMany()
    * ```
    */
  get midJobKind(): Prisma.midJobKindDelegate<ExtArgs>;

  /**
   * `prisma.smallJobKind`: Exposes CRUD operations for the **smallJobKind** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SmallJobKinds
    * const smallJobKinds = await prisma.smallJobKind.findMany()
    * ```
    */
  get smallJobKind(): Prisma.smallJobKindDelegate<ExtArgs>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.jobDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.5.2
   * Query Engine version: aebc046ce8b88ebbcb45efe31cbe7d06fd6abc0a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    users: 'users',
    incumbentsAdditional: 'incumbentsAdditional',
    studentsAdditional: 'studentsAdditional',
    category: 'category',
    posts: 'posts',
    comments: 'comments',
    recommendPosts: 'recommendPosts',
    reportedPosts: 'reportedPosts',
    recommendComments: 'recommendComments',
    reportedComments: 'reportedComments',
    reportedUsers: 'reportedUsers',
    company: 'company',
    school: 'school',
    major: 'major',
    bigJobKind: 'bigJobKind',
    midJobKind: 'midJobKind',
    smallJobKind: 'smallJobKind',
    job: 'job'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'users' | 'incumbentsAdditional' | 'studentsAdditional' | 'category' | 'posts' | 'comments' | 'recommendPosts' | 'reportedPosts' | 'recommendComments' | 'reportedComments' | 'reportedUsers' | 'company' | 'school' | 'major' | 'bigJobKind' | 'midJobKind' | 'smallJobKind' | 'job'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>,
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      incumbentsAdditional: {
        payload: Prisma.$incumbentsAdditionalPayload<ExtArgs>
        fields: Prisma.incumbentsAdditionalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.incumbentsAdditionalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$incumbentsAdditionalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.incumbentsAdditionalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$incumbentsAdditionalPayload>
          }
          findFirst: {
            args: Prisma.incumbentsAdditionalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$incumbentsAdditionalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.incumbentsAdditionalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$incumbentsAdditionalPayload>
          }
          findMany: {
            args: Prisma.incumbentsAdditionalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$incumbentsAdditionalPayload>[]
          }
          create: {
            args: Prisma.incumbentsAdditionalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$incumbentsAdditionalPayload>
          }
          createMany: {
            args: Prisma.incumbentsAdditionalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.incumbentsAdditionalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$incumbentsAdditionalPayload>
          }
          update: {
            args: Prisma.incumbentsAdditionalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$incumbentsAdditionalPayload>
          }
          deleteMany: {
            args: Prisma.incumbentsAdditionalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.incumbentsAdditionalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.incumbentsAdditionalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$incumbentsAdditionalPayload>
          }
          aggregate: {
            args: Prisma.IncumbentsAdditionalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateIncumbentsAdditional>
          }
          groupBy: {
            args: Prisma.incumbentsAdditionalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<IncumbentsAdditionalGroupByOutputType>[]
          }
          count: {
            args: Prisma.incumbentsAdditionalCountArgs<ExtArgs>,
            result: $Utils.Optional<IncumbentsAdditionalCountAggregateOutputType> | number
          }
        }
      }
      studentsAdditional: {
        payload: Prisma.$studentsAdditionalPayload<ExtArgs>
        fields: Prisma.studentsAdditionalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.studentsAdditionalFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$studentsAdditionalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.studentsAdditionalFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$studentsAdditionalPayload>
          }
          findFirst: {
            args: Prisma.studentsAdditionalFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$studentsAdditionalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.studentsAdditionalFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$studentsAdditionalPayload>
          }
          findMany: {
            args: Prisma.studentsAdditionalFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$studentsAdditionalPayload>[]
          }
          create: {
            args: Prisma.studentsAdditionalCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$studentsAdditionalPayload>
          }
          createMany: {
            args: Prisma.studentsAdditionalCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.studentsAdditionalDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$studentsAdditionalPayload>
          }
          update: {
            args: Prisma.studentsAdditionalUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$studentsAdditionalPayload>
          }
          deleteMany: {
            args: Prisma.studentsAdditionalDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.studentsAdditionalUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.studentsAdditionalUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$studentsAdditionalPayload>
          }
          aggregate: {
            args: Prisma.StudentsAdditionalAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStudentsAdditional>
          }
          groupBy: {
            args: Prisma.studentsAdditionalGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StudentsAdditionalGroupByOutputType>[]
          }
          count: {
            args: Prisma.studentsAdditionalCountArgs<ExtArgs>,
            result: $Utils.Optional<StudentsAdditionalCountAggregateOutputType> | number
          }
        }
      }
      category: {
        payload: Prisma.$categoryPayload<ExtArgs>
        fields: Prisma.categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findFirst: {
            args: Prisma.categoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          findMany: {
            args: Prisma.categoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>[]
          }
          create: {
            args: Prisma.categoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          createMany: {
            args: Prisma.categoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.categoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          update: {
            args: Prisma.categoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          deleteMany: {
            args: Prisma.categoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.categoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.categoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.categoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      posts: {
        payload: Prisma.$postsPayload<ExtArgs>
        fields: Prisma.postsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.postsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$postsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.postsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          findFirst: {
            args: Prisma.postsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$postsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.postsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          findMany: {
            args: Prisma.postsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$postsPayload>[]
          }
          create: {
            args: Prisma.postsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          createMany: {
            args: Prisma.postsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.postsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          update: {
            args: Prisma.postsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          deleteMany: {
            args: Prisma.postsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.postsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.postsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          aggregate: {
            args: Prisma.PostsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePosts>
          }
          groupBy: {
            args: Prisma.postsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PostsGroupByOutputType>[]
          }
          count: {
            args: Prisma.postsCountArgs<ExtArgs>,
            result: $Utils.Optional<PostsCountAggregateOutputType> | number
          }
        }
      }
      comments: {
        payload: Prisma.$commentsPayload<ExtArgs>
        fields: Prisma.commentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.commentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.commentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          findFirst: {
            args: Prisma.commentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.commentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          findMany: {
            args: Prisma.commentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]
          }
          create: {
            args: Prisma.commentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          createMany: {
            args: Prisma.commentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.commentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          update: {
            args: Prisma.commentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          deleteMany: {
            args: Prisma.commentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.commentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.commentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          aggregate: {
            args: Prisma.CommentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComments>
          }
          groupBy: {
            args: Prisma.commentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.commentsCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentsCountAggregateOutputType> | number
          }
        }
      }
      recommendPosts: {
        payload: Prisma.$recommendPostsPayload<ExtArgs>
        fields: Prisma.recommendPostsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.recommendPostsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendPostsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.recommendPostsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendPostsPayload>
          }
          findFirst: {
            args: Prisma.recommendPostsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendPostsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.recommendPostsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendPostsPayload>
          }
          findMany: {
            args: Prisma.recommendPostsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendPostsPayload>[]
          }
          create: {
            args: Prisma.recommendPostsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendPostsPayload>
          }
          createMany: {
            args: Prisma.recommendPostsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.recommendPostsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendPostsPayload>
          }
          update: {
            args: Prisma.recommendPostsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendPostsPayload>
          }
          deleteMany: {
            args: Prisma.recommendPostsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.recommendPostsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.recommendPostsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendPostsPayload>
          }
          aggregate: {
            args: Prisma.RecommendPostsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecommendPosts>
          }
          groupBy: {
            args: Prisma.recommendPostsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RecommendPostsGroupByOutputType>[]
          }
          count: {
            args: Prisma.recommendPostsCountArgs<ExtArgs>,
            result: $Utils.Optional<RecommendPostsCountAggregateOutputType> | number
          }
        }
      }
      reportedPosts: {
        payload: Prisma.$reportedPostsPayload<ExtArgs>
        fields: Prisma.reportedPostsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reportedPostsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedPostsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reportedPostsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedPostsPayload>
          }
          findFirst: {
            args: Prisma.reportedPostsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedPostsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reportedPostsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedPostsPayload>
          }
          findMany: {
            args: Prisma.reportedPostsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedPostsPayload>[]
          }
          create: {
            args: Prisma.reportedPostsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedPostsPayload>
          }
          createMany: {
            args: Prisma.reportedPostsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.reportedPostsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedPostsPayload>
          }
          update: {
            args: Prisma.reportedPostsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedPostsPayload>
          }
          deleteMany: {
            args: Prisma.reportedPostsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.reportedPostsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.reportedPostsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedPostsPayload>
          }
          aggregate: {
            args: Prisma.ReportedPostsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReportedPosts>
          }
          groupBy: {
            args: Prisma.reportedPostsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReportedPostsGroupByOutputType>[]
          }
          count: {
            args: Prisma.reportedPostsCountArgs<ExtArgs>,
            result: $Utils.Optional<ReportedPostsCountAggregateOutputType> | number
          }
        }
      }
      recommendComments: {
        payload: Prisma.$recommendCommentsPayload<ExtArgs>
        fields: Prisma.recommendCommentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.recommendCommentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendCommentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.recommendCommentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendCommentsPayload>
          }
          findFirst: {
            args: Prisma.recommendCommentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendCommentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.recommendCommentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendCommentsPayload>
          }
          findMany: {
            args: Prisma.recommendCommentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendCommentsPayload>[]
          }
          create: {
            args: Prisma.recommendCommentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendCommentsPayload>
          }
          createMany: {
            args: Prisma.recommendCommentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.recommendCommentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendCommentsPayload>
          }
          update: {
            args: Prisma.recommendCommentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendCommentsPayload>
          }
          deleteMany: {
            args: Prisma.recommendCommentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.recommendCommentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.recommendCommentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$recommendCommentsPayload>
          }
          aggregate: {
            args: Prisma.RecommendCommentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRecommendComments>
          }
          groupBy: {
            args: Prisma.recommendCommentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RecommendCommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.recommendCommentsCountArgs<ExtArgs>,
            result: $Utils.Optional<RecommendCommentsCountAggregateOutputType> | number
          }
        }
      }
      reportedComments: {
        payload: Prisma.$reportedCommentsPayload<ExtArgs>
        fields: Prisma.reportedCommentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reportedCommentsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedCommentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reportedCommentsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedCommentsPayload>
          }
          findFirst: {
            args: Prisma.reportedCommentsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedCommentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reportedCommentsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedCommentsPayload>
          }
          findMany: {
            args: Prisma.reportedCommentsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedCommentsPayload>[]
          }
          create: {
            args: Prisma.reportedCommentsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedCommentsPayload>
          }
          createMany: {
            args: Prisma.reportedCommentsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.reportedCommentsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedCommentsPayload>
          }
          update: {
            args: Prisma.reportedCommentsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedCommentsPayload>
          }
          deleteMany: {
            args: Prisma.reportedCommentsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.reportedCommentsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.reportedCommentsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedCommentsPayload>
          }
          aggregate: {
            args: Prisma.ReportedCommentsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReportedComments>
          }
          groupBy: {
            args: Prisma.reportedCommentsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReportedCommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.reportedCommentsCountArgs<ExtArgs>,
            result: $Utils.Optional<ReportedCommentsCountAggregateOutputType> | number
          }
        }
      }
      reportedUsers: {
        payload: Prisma.$reportedUsersPayload<ExtArgs>
        fields: Prisma.reportedUsersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reportedUsersFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedUsersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reportedUsersFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedUsersPayload>
          }
          findFirst: {
            args: Prisma.reportedUsersFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedUsersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reportedUsersFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedUsersPayload>
          }
          findMany: {
            args: Prisma.reportedUsersFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedUsersPayload>[]
          }
          create: {
            args: Prisma.reportedUsersCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedUsersPayload>
          }
          createMany: {
            args: Prisma.reportedUsersCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.reportedUsersDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedUsersPayload>
          }
          update: {
            args: Prisma.reportedUsersUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedUsersPayload>
          }
          deleteMany: {
            args: Prisma.reportedUsersDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.reportedUsersUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.reportedUsersUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$reportedUsersPayload>
          }
          aggregate: {
            args: Prisma.ReportedUsersAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReportedUsers>
          }
          groupBy: {
            args: Prisma.reportedUsersGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReportedUsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.reportedUsersCountArgs<ExtArgs>,
            result: $Utils.Optional<ReportedUsersCountAggregateOutputType> | number
          }
        }
      }
      company: {
        payload: Prisma.$companyPayload<ExtArgs>
        fields: Prisma.companyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companyFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companyFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          findFirst: {
            args: Prisma.companyFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companyFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          findMany: {
            args: Prisma.companyFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload>[]
          }
          create: {
            args: Prisma.companyCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          createMany: {
            args: Prisma.companyCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.companyDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          update: {
            args: Prisma.companyUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          deleteMany: {
            args: Prisma.companyDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.companyUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.companyUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$companyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.companyGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.companyCountArgs<ExtArgs>,
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      school: {
        payload: Prisma.$schoolPayload<ExtArgs>
        fields: Prisma.schoolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.schoolFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$schoolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.schoolFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$schoolPayload>
          }
          findFirst: {
            args: Prisma.schoolFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$schoolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.schoolFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$schoolPayload>
          }
          findMany: {
            args: Prisma.schoolFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$schoolPayload>[]
          }
          create: {
            args: Prisma.schoolCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$schoolPayload>
          }
          createMany: {
            args: Prisma.schoolCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.schoolDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$schoolPayload>
          }
          update: {
            args: Prisma.schoolUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$schoolPayload>
          }
          deleteMany: {
            args: Prisma.schoolDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.schoolUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.schoolUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$schoolPayload>
          }
          aggregate: {
            args: Prisma.SchoolAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSchool>
          }
          groupBy: {
            args: Prisma.schoolGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SchoolGroupByOutputType>[]
          }
          count: {
            args: Prisma.schoolCountArgs<ExtArgs>,
            result: $Utils.Optional<SchoolCountAggregateOutputType> | number
          }
        }
      }
      major: {
        payload: Prisma.$majorPayload<ExtArgs>
        fields: Prisma.majorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.majorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$majorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.majorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$majorPayload>
          }
          findFirst: {
            args: Prisma.majorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$majorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.majorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$majorPayload>
          }
          findMany: {
            args: Prisma.majorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$majorPayload>[]
          }
          create: {
            args: Prisma.majorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$majorPayload>
          }
          createMany: {
            args: Prisma.majorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.majorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$majorPayload>
          }
          update: {
            args: Prisma.majorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$majorPayload>
          }
          deleteMany: {
            args: Prisma.majorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.majorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.majorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$majorPayload>
          }
          aggregate: {
            args: Prisma.MajorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMajor>
          }
          groupBy: {
            args: Prisma.majorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MajorGroupByOutputType>[]
          }
          count: {
            args: Prisma.majorCountArgs<ExtArgs>,
            result: $Utils.Optional<MajorCountAggregateOutputType> | number
          }
        }
      }
      bigJobKind: {
        payload: Prisma.$bigJobKindPayload<ExtArgs>
        fields: Prisma.bigJobKindFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bigJobKindFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bigJobKindPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bigJobKindFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bigJobKindPayload>
          }
          findFirst: {
            args: Prisma.bigJobKindFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bigJobKindPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bigJobKindFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bigJobKindPayload>
          }
          findMany: {
            args: Prisma.bigJobKindFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bigJobKindPayload>[]
          }
          create: {
            args: Prisma.bigJobKindCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bigJobKindPayload>
          }
          createMany: {
            args: Prisma.bigJobKindCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.bigJobKindDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bigJobKindPayload>
          }
          update: {
            args: Prisma.bigJobKindUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bigJobKindPayload>
          }
          deleteMany: {
            args: Prisma.bigJobKindDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.bigJobKindUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.bigJobKindUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$bigJobKindPayload>
          }
          aggregate: {
            args: Prisma.BigJobKindAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBigJobKind>
          }
          groupBy: {
            args: Prisma.bigJobKindGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BigJobKindGroupByOutputType>[]
          }
          count: {
            args: Prisma.bigJobKindCountArgs<ExtArgs>,
            result: $Utils.Optional<BigJobKindCountAggregateOutputType> | number
          }
        }
      }
      midJobKind: {
        payload: Prisma.$midJobKindPayload<ExtArgs>
        fields: Prisma.midJobKindFieldRefs
        operations: {
          findUnique: {
            args: Prisma.midJobKindFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$midJobKindPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.midJobKindFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$midJobKindPayload>
          }
          findFirst: {
            args: Prisma.midJobKindFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$midJobKindPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.midJobKindFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$midJobKindPayload>
          }
          findMany: {
            args: Prisma.midJobKindFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$midJobKindPayload>[]
          }
          create: {
            args: Prisma.midJobKindCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$midJobKindPayload>
          }
          createMany: {
            args: Prisma.midJobKindCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.midJobKindDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$midJobKindPayload>
          }
          update: {
            args: Prisma.midJobKindUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$midJobKindPayload>
          }
          deleteMany: {
            args: Prisma.midJobKindDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.midJobKindUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.midJobKindUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$midJobKindPayload>
          }
          aggregate: {
            args: Prisma.MidJobKindAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMidJobKind>
          }
          groupBy: {
            args: Prisma.midJobKindGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MidJobKindGroupByOutputType>[]
          }
          count: {
            args: Prisma.midJobKindCountArgs<ExtArgs>,
            result: $Utils.Optional<MidJobKindCountAggregateOutputType> | number
          }
        }
      }
      smallJobKind: {
        payload: Prisma.$smallJobKindPayload<ExtArgs>
        fields: Prisma.smallJobKindFieldRefs
        operations: {
          findUnique: {
            args: Prisma.smallJobKindFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$smallJobKindPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.smallJobKindFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$smallJobKindPayload>
          }
          findFirst: {
            args: Prisma.smallJobKindFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$smallJobKindPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.smallJobKindFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$smallJobKindPayload>
          }
          findMany: {
            args: Prisma.smallJobKindFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$smallJobKindPayload>[]
          }
          create: {
            args: Prisma.smallJobKindCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$smallJobKindPayload>
          }
          createMany: {
            args: Prisma.smallJobKindCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.smallJobKindDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$smallJobKindPayload>
          }
          update: {
            args: Prisma.smallJobKindUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$smallJobKindPayload>
          }
          deleteMany: {
            args: Prisma.smallJobKindDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.smallJobKindUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.smallJobKindUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$smallJobKindPayload>
          }
          aggregate: {
            args: Prisma.SmallJobKindAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSmallJobKind>
          }
          groupBy: {
            args: Prisma.smallJobKindGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SmallJobKindGroupByOutputType>[]
          }
          count: {
            args: Prisma.smallJobKindCountArgs<ExtArgs>,
            result: $Utils.Optional<SmallJobKindCountAggregateOutputType> | number
          }
        }
      }
      job: {
        payload: Prisma.$jobPayload<ExtArgs>
        fields: Prisma.jobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jobFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$jobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jobFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          findFirst: {
            args: Prisma.jobFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$jobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jobFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          findMany: {
            args: Prisma.jobFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$jobPayload>[]
          }
          create: {
            args: Prisma.jobCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          createMany: {
            args: Prisma.jobCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.jobDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          update: {
            args: Prisma.jobUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          deleteMany: {
            args: Prisma.jobDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.jobUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.jobUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$jobPayload>
          }
          aggregate: {
            args: Prisma.JobAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateJob>
          }
          groupBy: {
            args: Prisma.jobGroupByArgs<ExtArgs>,
            result: $Utils.Optional<JobGroupByOutputType>[]
          }
          count: {
            args: Prisma.jobCountArgs<ExtArgs>,
            result: $Utils.Optional<JobCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    posts: number
    comments: number
    recommend_posts: number
    recommend_comments: number
    reported_posts: number
    reported_comments: number
    reported_users: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | UsersCountOutputTypeCountPostsArgs
    comments?: boolean | UsersCountOutputTypeCountCommentsArgs
    recommend_posts?: boolean | UsersCountOutputTypeCountRecommend_postsArgs
    recommend_comments?: boolean | UsersCountOutputTypeCountRecommend_commentsArgs
    reported_posts?: boolean | UsersCountOutputTypeCountReported_postsArgs
    reported_comments?: boolean | UsersCountOutputTypeCountReported_commentsArgs
    reported_users?: boolean | UsersCountOutputTypeCountReported_usersArgs
  }

  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: postsWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRecommend_postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recommendPostsWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountRecommend_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recommendCommentsWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReported_postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportedPostsWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReported_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportedCommentsWhereInput
  }


  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountReported_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportedUsersWhereInput
  }



  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    posts: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | CategoryCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: postsWhereInput
  }



  /**
   * Count Type PostsCountOutputType
   */

  export type PostsCountOutputType = {
    comments: number
    recommend_posts: number
    reported_posts: number
  }

  export type PostsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PostsCountOutputTypeCountCommentsArgs
    recommend_posts?: boolean | PostsCountOutputTypeCountRecommend_postsArgs
    reported_posts?: boolean | PostsCountOutputTypeCountReported_postsArgs
  }

  // Custom InputTypes

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsCountOutputType
     */
    select?: PostsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
  }


  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountRecommend_postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recommendPostsWhereInput
  }


  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountReported_postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportedPostsWhereInput
  }



  /**
   * Count Type CommentsCountOutputType
   */

  export type CommentsCountOutputType = {
    replies: number
    recommend_comments: number
    reported_comments: number
  }

  export type CommentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentsCountOutputTypeCountRepliesArgs
    recommend_comments?: boolean | CommentsCountOutputTypeCountRecommend_commentsArgs
    reported_comments?: boolean | CommentsCountOutputTypeCountReported_commentsArgs
  }

  // Custom InputTypes

  /**
   * CommentsCountOutputType without action
   */
  export type CommentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentsCountOutputType
     */
    select?: CommentsCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CommentsCountOutputType without action
   */
  export type CommentsCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
  }


  /**
   * CommentsCountOutputType without action
   */
  export type CommentsCountOutputTypeCountRecommend_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recommendCommentsWhereInput
  }


  /**
   * CommentsCountOutputType without action
   */
  export type CommentsCountOutputTypeCountReported_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportedCommentsWhereInput
  }



  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    incumebent: number
    student: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incumebent?: boolean | CompanyCountOutputTypeCountIncumebentArgs
    student?: boolean | CompanyCountOutputTypeCountStudentArgs
  }

  // Custom InputTypes

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountIncumebentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: incumbentsAdditionalWhereInput
  }


  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsAdditionalWhereInput
  }



  /**
   * Count Type SchoolCountOutputType
   */

  export type SchoolCountOutputType = {
    major: number
    incumebent: number
    student: number
  }

  export type SchoolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    major?: boolean | SchoolCountOutputTypeCountMajorArgs
    incumebent?: boolean | SchoolCountOutputTypeCountIncumebentArgs
    student?: boolean | SchoolCountOutputTypeCountStudentArgs
  }

  // Custom InputTypes

  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolCountOutputType
     */
    select?: SchoolCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountMajorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: majorWhereInput
  }


  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountIncumebentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: incumbentsAdditionalWhereInput
  }


  /**
   * SchoolCountOutputType without action
   */
  export type SchoolCountOutputTypeCountStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsAdditionalWhereInput
  }



  /**
   * Count Type MajorCountOutputType
   */

  export type MajorCountOutputType = {
    incumebent: number
    student: number
  }

  export type MajorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incumebent?: boolean | MajorCountOutputTypeCountIncumebentArgs
    student?: boolean | MajorCountOutputTypeCountStudentArgs
  }

  // Custom InputTypes

  /**
   * MajorCountOutputType without action
   */
  export type MajorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MajorCountOutputType
     */
    select?: MajorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MajorCountOutputType without action
   */
  export type MajorCountOutputTypeCountIncumebentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: incumbentsAdditionalWhereInput
  }


  /**
   * MajorCountOutputType without action
   */
  export type MajorCountOutputTypeCountStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsAdditionalWhereInput
  }



  /**
   * Count Type BigJobKindCountOutputType
   */

  export type BigJobKindCountOutputType = {
    company: number
    midJobKind: number
  }

  export type BigJobKindCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | BigJobKindCountOutputTypeCountCompanyArgs
    midJobKind?: boolean | BigJobKindCountOutputTypeCountMidJobKindArgs
  }

  // Custom InputTypes

  /**
   * BigJobKindCountOutputType without action
   */
  export type BigJobKindCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BigJobKindCountOutputType
     */
    select?: BigJobKindCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * BigJobKindCountOutputType without action
   */
  export type BigJobKindCountOutputTypeCountCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyWhereInput
  }


  /**
   * BigJobKindCountOutputType without action
   */
  export type BigJobKindCountOutputTypeCountMidJobKindArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: midJobKindWhereInput
  }



  /**
   * Count Type MidJobKindCountOutputType
   */

  export type MidJobKindCountOutputType = {
    company: number
    smallJobKind: number
  }

  export type MidJobKindCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | MidJobKindCountOutputTypeCountCompanyArgs
    smallJobKind?: boolean | MidJobKindCountOutputTypeCountSmallJobKindArgs
  }

  // Custom InputTypes

  /**
   * MidJobKindCountOutputType without action
   */
  export type MidJobKindCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MidJobKindCountOutputType
     */
    select?: MidJobKindCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MidJobKindCountOutputType without action
   */
  export type MidJobKindCountOutputTypeCountCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyWhereInput
  }


  /**
   * MidJobKindCountOutputType without action
   */
  export type MidJobKindCountOutputTypeCountSmallJobKindArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: smallJobKindWhereInput
  }



  /**
   * Count Type SmallJobKindCountOutputType
   */

  export type SmallJobKindCountOutputType = {
    company: number
  }

  export type SmallJobKindCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | SmallJobKindCountOutputTypeCountCompanyArgs
  }

  // Custom InputTypes

  /**
   * SmallJobKindCountOutputType without action
   */
  export type SmallJobKindCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SmallJobKindCountOutputType
     */
    select?: SmallJobKindCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SmallJobKindCountOutputType without action
   */
  export type SmallJobKindCountOutputTypeCountCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyWhereInput
  }



  /**
   * Count Type JobCountOutputType
   */

  export type JobCountOutputType = {
    incumebent: number
    student: number
  }

  export type JobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incumebent?: boolean | JobCountOutputTypeCountIncumebentArgs
    student?: boolean | JobCountOutputTypeCountStudentArgs
  }

  // Custom InputTypes

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCountOutputType
     */
    select?: JobCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountIncumebentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: incumbentsAdditionalWhereInput
  }


  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountStudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsAdditionalWhereInput
  }



  /**
   * Models
   */

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    age: number | null
    gender: $Enums.Gender | null
    image: string | null
    type: $Enums.userType | null
    createdDate: Date | null
    updatedDate: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    age: number | null
    gender: $Enums.Gender | null
    image: string | null
    type: $Enums.userType | null
    createdDate: Date | null
    updatedDate: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    age: number
    gender: number
    image: number
    type: number
    createdDate: number
    updatedDate: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    age?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    age?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    age?: true
    gender?: true
    image?: true
    type?: true
    createdDate?: true
    updatedDate?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    age?: true
    gender?: true
    image?: true
    type?: true
    createdDate?: true
    updatedDate?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    age?: true
    gender?: true
    image?: true
    type?: true
    createdDate?: true
    updatedDate?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image: string | null
    type: $Enums.userType
    createdDate: Date
    updatedDate: Date
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    age?: boolean
    gender?: boolean
    image?: boolean
    type?: boolean
    createdDate?: boolean
    updatedDate?: boolean
    incumbent_additional?: boolean | users$incumbent_additionalArgs<ExtArgs>
    student_additional?: boolean | users$student_additionalArgs<ExtArgs>
    posts?: boolean | users$postsArgs<ExtArgs>
    comments?: boolean | users$commentsArgs<ExtArgs>
    recommend_posts?: boolean | users$recommend_postsArgs<ExtArgs>
    recommend_comments?: boolean | users$recommend_commentsArgs<ExtArgs>
    reported_posts?: boolean | users$reported_postsArgs<ExtArgs>
    reported_comments?: boolean | users$reported_commentsArgs<ExtArgs>
    reported_users?: boolean | users$reported_usersArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    age?: boolean
    gender?: boolean
    image?: boolean
    type?: boolean
    createdDate?: boolean
    updatedDate?: boolean
  }

  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incumbent_additional?: boolean | users$incumbent_additionalArgs<ExtArgs>
    student_additional?: boolean | users$student_additionalArgs<ExtArgs>
    posts?: boolean | users$postsArgs<ExtArgs>
    comments?: boolean | users$commentsArgs<ExtArgs>
    recommend_posts?: boolean | users$recommend_postsArgs<ExtArgs>
    recommend_comments?: boolean | users$recommend_commentsArgs<ExtArgs>
    reported_posts?: boolean | users$reported_postsArgs<ExtArgs>
    reported_comments?: boolean | users$reported_commentsArgs<ExtArgs>
    reported_users?: boolean | users$reported_usersArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      incumbent_additional: Prisma.$incumbentsAdditionalPayload<ExtArgs> | null
      student_additional: Prisma.$studentsAdditionalPayload<ExtArgs> | null
      posts: Prisma.$postsPayload<ExtArgs>[]
      comments: Prisma.$commentsPayload<ExtArgs>[]
      recommend_posts: Prisma.$recommendPostsPayload<ExtArgs>[]
      recommend_comments: Prisma.$recommendCommentsPayload<ExtArgs>[]
      reported_posts: Prisma.$reportedPostsPayload<ExtArgs>[]
      reported_comments: Prisma.$reportedCommentsPayload<ExtArgs>[]
      reported_users: Prisma.$reportedUsersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string
      age: number
      gender: $Enums.Gender
      image: string | null
      type: $Enums.userType
      createdDate: Date
      updatedDate: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }


  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Users that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, usersCreateArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, usersDeleteArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, usersUpsertArgs<ExtArgs>>
    ): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    incumbent_additional<T extends users$incumbent_additionalArgs<ExtArgs> = {}>(args?: Subset<T, users$incumbent_additionalArgs<ExtArgs>>): Prisma__incumbentsAdditionalClient<$Result.GetResult<Prisma.$incumbentsAdditionalPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    student_additional<T extends users$student_additionalArgs<ExtArgs> = {}>(args?: Subset<T, users$student_additionalArgs<ExtArgs>>): Prisma__studentsAdditionalClient<$Result.GetResult<Prisma.$studentsAdditionalPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    posts<T extends users$postsArgs<ExtArgs> = {}>(args?: Subset<T, users$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, 'findMany'> | Null>;

    comments<T extends users$commentsArgs<ExtArgs> = {}>(args?: Subset<T, users$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    recommend_posts<T extends users$recommend_postsArgs<ExtArgs> = {}>(args?: Subset<T, users$recommend_postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recommendPostsPayload<ExtArgs>, T, 'findMany'> | Null>;

    recommend_comments<T extends users$recommend_commentsArgs<ExtArgs> = {}>(args?: Subset<T, users$recommend_commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recommendCommentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    reported_posts<T extends users$reported_postsArgs<ExtArgs> = {}>(args?: Subset<T, users$reported_postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportedPostsPayload<ExtArgs>, T, 'findMany'> | Null>;

    reported_comments<T extends users$reported_commentsArgs<ExtArgs> = {}>(args?: Subset<T, users$reported_commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportedCommentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    reported_users<T extends users$reported_usersArgs<ExtArgs> = {}>(args?: Subset<T, users$reported_usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportedUsersPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly email: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly name: FieldRef<"users", 'String'>
    readonly age: FieldRef<"users", 'Int'>
    readonly gender: FieldRef<"users", 'Gender'>
    readonly image: FieldRef<"users", 'String'>
    readonly type: FieldRef<"users", 'userType'>
    readonly createdDate: FieldRef<"users", 'DateTime'>
    readonly updatedDate: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }


  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }


  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }


  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }


  /**
   * users.incumbent_additional
   */
  export type users$incumbent_additionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incumbentsAdditional
     */
    select?: incumbentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incumbentsAdditionalInclude<ExtArgs> | null
    where?: incumbentsAdditionalWhereInput
  }


  /**
   * users.student_additional
   */
  export type users$student_additionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentsAdditional
     */
    select?: studentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: studentsAdditionalInclude<ExtArgs> | null
    where?: studentsAdditionalWhereInput
  }


  /**
   * users.posts
   */
  export type users$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: postsInclude<ExtArgs> | null
    where?: postsWhereInput
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    cursor?: postsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }


  /**
   * users.comments
   */
  export type users$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    cursor?: commentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }


  /**
   * users.recommend_posts
   */
  export type users$recommend_postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendPosts
     */
    select?: recommendPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendPostsInclude<ExtArgs> | null
    where?: recommendPostsWhereInput
    orderBy?: recommendPostsOrderByWithRelationInput | recommendPostsOrderByWithRelationInput[]
    cursor?: recommendPostsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecommendPostsScalarFieldEnum | RecommendPostsScalarFieldEnum[]
  }


  /**
   * users.recommend_comments
   */
  export type users$recommend_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendComments
     */
    select?: recommendCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendCommentsInclude<ExtArgs> | null
    where?: recommendCommentsWhereInput
    orderBy?: recommendCommentsOrderByWithRelationInput | recommendCommentsOrderByWithRelationInput[]
    cursor?: recommendCommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecommendCommentsScalarFieldEnum | RecommendCommentsScalarFieldEnum[]
  }


  /**
   * users.reported_posts
   */
  export type users$reported_postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedPosts
     */
    select?: reportedPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedPostsInclude<ExtArgs> | null
    where?: reportedPostsWhereInput
    orderBy?: reportedPostsOrderByWithRelationInput | reportedPostsOrderByWithRelationInput[]
    cursor?: reportedPostsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportedPostsScalarFieldEnum | ReportedPostsScalarFieldEnum[]
  }


  /**
   * users.reported_comments
   */
  export type users$reported_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedComments
     */
    select?: reportedCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedCommentsInclude<ExtArgs> | null
    where?: reportedCommentsWhereInput
    orderBy?: reportedCommentsOrderByWithRelationInput | reportedCommentsOrderByWithRelationInput[]
    cursor?: reportedCommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportedCommentsScalarFieldEnum | ReportedCommentsScalarFieldEnum[]
  }


  /**
   * users.reported_users
   */
  export type users$reported_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedUsers
     */
    select?: reportedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedUsersInclude<ExtArgs> | null
    where?: reportedUsersWhereInput
    orderBy?: reportedUsersOrderByWithRelationInput | reportedUsersOrderByWithRelationInput[]
    cursor?: reportedUsersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportedUsersScalarFieldEnum | ReportedUsersScalarFieldEnum[]
  }


  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
  }



  /**
   * Model incumbentsAdditional
   */

  export type AggregateIncumbentsAdditional = {
    _count: IncumbentsAdditionalCountAggregateOutputType | null
    _avg: IncumbentsAdditionalAvgAggregateOutputType | null
    _sum: IncumbentsAdditionalSumAggregateOutputType | null
    _min: IncumbentsAdditionalMinAggregateOutputType | null
    _max: IncumbentsAdditionalMaxAggregateOutputType | null
  }

  export type IncumbentsAdditionalAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    companyId: number | null
    schoolId: number | null
    majorId: number | null
    bigJobId: number | null
    midJobId: number | null
    smallJobId: number | null
    jobId: number | null
    reportedNum: number | null
    adviceCount: number | null
    estimationCount: number | null
  }

  export type IncumbentsAdditionalSumAggregateOutputType = {
    id: number | null
    userId: number | null
    companyId: number | null
    schoolId: number | null
    majorId: number | null
    bigJobId: number | null
    midJobId: number | null
    smallJobId: number | null
    jobId: number | null
    reportedNum: number | null
    adviceCount: number | null
    estimationCount: number | null
  }

  export type IncumbentsAdditionalMinAggregateOutputType = {
    id: number | null
    userId: number | null
    companyId: number | null
    schoolId: number | null
    majorId: number | null
    bigJobId: number | null
    midJobId: number | null
    smallJobId: number | null
    jobId: number | null
    shortSpec: string | null
    reportedNum: number | null
    adviceCount: number | null
    estimationCount: number | null
    updatedDate: Date | null
  }

  export type IncumbentsAdditionalMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    companyId: number | null
    schoolId: number | null
    majorId: number | null
    bigJobId: number | null
    midJobId: number | null
    smallJobId: number | null
    jobId: number | null
    shortSpec: string | null
    reportedNum: number | null
    adviceCount: number | null
    estimationCount: number | null
    updatedDate: Date | null
  }

  export type IncumbentsAdditionalCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    schoolId: number
    majorId: number
    bigJobId: number
    midJobId: number
    smallJobId: number
    jobId: number
    shortSpec: number
    reportedNum: number
    adviceCount: number
    estimationCount: number
    updatedDate: number
    _all: number
  }


  export type IncumbentsAdditionalAvgAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    schoolId?: true
    majorId?: true
    bigJobId?: true
    midJobId?: true
    smallJobId?: true
    jobId?: true
    reportedNum?: true
    adviceCount?: true
    estimationCount?: true
  }

  export type IncumbentsAdditionalSumAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    schoolId?: true
    majorId?: true
    bigJobId?: true
    midJobId?: true
    smallJobId?: true
    jobId?: true
    reportedNum?: true
    adviceCount?: true
    estimationCount?: true
  }

  export type IncumbentsAdditionalMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    schoolId?: true
    majorId?: true
    bigJobId?: true
    midJobId?: true
    smallJobId?: true
    jobId?: true
    shortSpec?: true
    reportedNum?: true
    adviceCount?: true
    estimationCount?: true
    updatedDate?: true
  }

  export type IncumbentsAdditionalMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    schoolId?: true
    majorId?: true
    bigJobId?: true
    midJobId?: true
    smallJobId?: true
    jobId?: true
    shortSpec?: true
    reportedNum?: true
    adviceCount?: true
    estimationCount?: true
    updatedDate?: true
  }

  export type IncumbentsAdditionalCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    schoolId?: true
    majorId?: true
    bigJobId?: true
    midJobId?: true
    smallJobId?: true
    jobId?: true
    shortSpec?: true
    reportedNum?: true
    adviceCount?: true
    estimationCount?: true
    updatedDate?: true
    _all?: true
  }

  export type IncumbentsAdditionalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which incumbentsAdditional to aggregate.
     */
    where?: incumbentsAdditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incumbentsAdditionals to fetch.
     */
    orderBy?: incumbentsAdditionalOrderByWithRelationInput | incumbentsAdditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: incumbentsAdditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incumbentsAdditionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incumbentsAdditionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned incumbentsAdditionals
    **/
    _count?: true | IncumbentsAdditionalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IncumbentsAdditionalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IncumbentsAdditionalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IncumbentsAdditionalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IncumbentsAdditionalMaxAggregateInputType
  }

  export type GetIncumbentsAdditionalAggregateType<T extends IncumbentsAdditionalAggregateArgs> = {
        [P in keyof T & keyof AggregateIncumbentsAdditional]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncumbentsAdditional[P]>
      : GetScalarType<T[P], AggregateIncumbentsAdditional[P]>
  }




  export type incumbentsAdditionalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: incumbentsAdditionalWhereInput
    orderBy?: incumbentsAdditionalOrderByWithAggregationInput | incumbentsAdditionalOrderByWithAggregationInput[]
    by: IncumbentsAdditionalScalarFieldEnum[] | IncumbentsAdditionalScalarFieldEnum
    having?: incumbentsAdditionalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IncumbentsAdditionalCountAggregateInputType | true
    _avg?: IncumbentsAdditionalAvgAggregateInputType
    _sum?: IncumbentsAdditionalSumAggregateInputType
    _min?: IncumbentsAdditionalMinAggregateInputType
    _max?: IncumbentsAdditionalMaxAggregateInputType
  }

  export type IncumbentsAdditionalGroupByOutputType = {
    id: number
    userId: number
    companyId: number | null
    schoolId: number | null
    majorId: number | null
    bigJobId: number | null
    midJobId: number | null
    smallJobId: number | null
    jobId: number | null
    shortSpec: string | null
    reportedNum: number
    adviceCount: number
    estimationCount: number
    updatedDate: Date
    _count: IncumbentsAdditionalCountAggregateOutputType | null
    _avg: IncumbentsAdditionalAvgAggregateOutputType | null
    _sum: IncumbentsAdditionalSumAggregateOutputType | null
    _min: IncumbentsAdditionalMinAggregateOutputType | null
    _max: IncumbentsAdditionalMaxAggregateOutputType | null
  }

  type GetIncumbentsAdditionalGroupByPayload<T extends incumbentsAdditionalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IncumbentsAdditionalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IncumbentsAdditionalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IncumbentsAdditionalGroupByOutputType[P]>
            : GetScalarType<T[P], IncumbentsAdditionalGroupByOutputType[P]>
        }
      >
    >


  export type incumbentsAdditionalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    schoolId?: boolean
    majorId?: boolean
    bigJobId?: boolean
    midJobId?: boolean
    smallJobId?: boolean
    jobId?: boolean
    shortSpec?: boolean
    reportedNum?: boolean
    adviceCount?: boolean
    estimationCount?: boolean
    updatedDate?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    company?: boolean | incumbentsAdditional$companyArgs<ExtArgs>
    school?: boolean | incumbentsAdditional$schoolArgs<ExtArgs>
    major?: boolean | incumbentsAdditional$majorArgs<ExtArgs>
    job?: boolean | incumbentsAdditional$jobArgs<ExtArgs>
  }, ExtArgs["result"]["incumbentsAdditional"]>

  export type incumbentsAdditionalSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    schoolId?: boolean
    majorId?: boolean
    bigJobId?: boolean
    midJobId?: boolean
    smallJobId?: boolean
    jobId?: boolean
    shortSpec?: boolean
    reportedNum?: boolean
    adviceCount?: boolean
    estimationCount?: boolean
    updatedDate?: boolean
  }

  export type incumbentsAdditionalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    company?: boolean | incumbentsAdditional$companyArgs<ExtArgs>
    school?: boolean | incumbentsAdditional$schoolArgs<ExtArgs>
    major?: boolean | incumbentsAdditional$majorArgs<ExtArgs>
    job?: boolean | incumbentsAdditional$jobArgs<ExtArgs>
  }


  export type $incumbentsAdditionalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "incumbentsAdditional"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      company: Prisma.$companyPayload<ExtArgs> | null
      school: Prisma.$schoolPayload<ExtArgs> | null
      major: Prisma.$majorPayload<ExtArgs> | null
      job: Prisma.$jobPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      companyId: number | null
      schoolId: number | null
      majorId: number | null
      bigJobId: number | null
      midJobId: number | null
      smallJobId: number | null
      jobId: number | null
      shortSpec: string | null
      reportedNum: number
      adviceCount: number
      estimationCount: number
      updatedDate: Date
    }, ExtArgs["result"]["incumbentsAdditional"]>
    composites: {}
  }


  type incumbentsAdditionalGetPayload<S extends boolean | null | undefined | incumbentsAdditionalDefaultArgs> = $Result.GetResult<Prisma.$incumbentsAdditionalPayload, S>

  type incumbentsAdditionalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<incumbentsAdditionalFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: IncumbentsAdditionalCountAggregateInputType | true
    }

  export interface incumbentsAdditionalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['incumbentsAdditional'], meta: { name: 'incumbentsAdditional' } }
    /**
     * Find zero or one IncumbentsAdditional that matches the filter.
     * @param {incumbentsAdditionalFindUniqueArgs} args - Arguments to find a IncumbentsAdditional
     * @example
     * // Get one IncumbentsAdditional
     * const incumbentsAdditional = await prisma.incumbentsAdditional.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends incumbentsAdditionalFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, incumbentsAdditionalFindUniqueArgs<ExtArgs>>
    ): Prisma__incumbentsAdditionalClient<$Result.GetResult<Prisma.$incumbentsAdditionalPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one IncumbentsAdditional that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {incumbentsAdditionalFindUniqueOrThrowArgs} args - Arguments to find a IncumbentsAdditional
     * @example
     * // Get one IncumbentsAdditional
     * const incumbentsAdditional = await prisma.incumbentsAdditional.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends incumbentsAdditionalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, incumbentsAdditionalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__incumbentsAdditionalClient<$Result.GetResult<Prisma.$incumbentsAdditionalPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first IncumbentsAdditional that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incumbentsAdditionalFindFirstArgs} args - Arguments to find a IncumbentsAdditional
     * @example
     * // Get one IncumbentsAdditional
     * const incumbentsAdditional = await prisma.incumbentsAdditional.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends incumbentsAdditionalFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, incumbentsAdditionalFindFirstArgs<ExtArgs>>
    ): Prisma__incumbentsAdditionalClient<$Result.GetResult<Prisma.$incumbentsAdditionalPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first IncumbentsAdditional that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incumbentsAdditionalFindFirstOrThrowArgs} args - Arguments to find a IncumbentsAdditional
     * @example
     * // Get one IncumbentsAdditional
     * const incumbentsAdditional = await prisma.incumbentsAdditional.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends incumbentsAdditionalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, incumbentsAdditionalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__incumbentsAdditionalClient<$Result.GetResult<Prisma.$incumbentsAdditionalPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more IncumbentsAdditionals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incumbentsAdditionalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all IncumbentsAdditionals
     * const incumbentsAdditionals = await prisma.incumbentsAdditional.findMany()
     * 
     * // Get first 10 IncumbentsAdditionals
     * const incumbentsAdditionals = await prisma.incumbentsAdditional.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incumbentsAdditionalWithIdOnly = await prisma.incumbentsAdditional.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends incumbentsAdditionalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, incumbentsAdditionalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$incumbentsAdditionalPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a IncumbentsAdditional.
     * @param {incumbentsAdditionalCreateArgs} args - Arguments to create a IncumbentsAdditional.
     * @example
     * // Create one IncumbentsAdditional
     * const IncumbentsAdditional = await prisma.incumbentsAdditional.create({
     *   data: {
     *     // ... data to create a IncumbentsAdditional
     *   }
     * })
     * 
    **/
    create<T extends incumbentsAdditionalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, incumbentsAdditionalCreateArgs<ExtArgs>>
    ): Prisma__incumbentsAdditionalClient<$Result.GetResult<Prisma.$incumbentsAdditionalPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many IncumbentsAdditionals.
     *     @param {incumbentsAdditionalCreateManyArgs} args - Arguments to create many IncumbentsAdditionals.
     *     @example
     *     // Create many IncumbentsAdditionals
     *     const incumbentsAdditional = await prisma.incumbentsAdditional.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends incumbentsAdditionalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, incumbentsAdditionalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a IncumbentsAdditional.
     * @param {incumbentsAdditionalDeleteArgs} args - Arguments to delete one IncumbentsAdditional.
     * @example
     * // Delete one IncumbentsAdditional
     * const IncumbentsAdditional = await prisma.incumbentsAdditional.delete({
     *   where: {
     *     // ... filter to delete one IncumbentsAdditional
     *   }
     * })
     * 
    **/
    delete<T extends incumbentsAdditionalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, incumbentsAdditionalDeleteArgs<ExtArgs>>
    ): Prisma__incumbentsAdditionalClient<$Result.GetResult<Prisma.$incumbentsAdditionalPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one IncumbentsAdditional.
     * @param {incumbentsAdditionalUpdateArgs} args - Arguments to update one IncumbentsAdditional.
     * @example
     * // Update one IncumbentsAdditional
     * const incumbentsAdditional = await prisma.incumbentsAdditional.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends incumbentsAdditionalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, incumbentsAdditionalUpdateArgs<ExtArgs>>
    ): Prisma__incumbentsAdditionalClient<$Result.GetResult<Prisma.$incumbentsAdditionalPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more IncumbentsAdditionals.
     * @param {incumbentsAdditionalDeleteManyArgs} args - Arguments to filter IncumbentsAdditionals to delete.
     * @example
     * // Delete a few IncumbentsAdditionals
     * const { count } = await prisma.incumbentsAdditional.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends incumbentsAdditionalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, incumbentsAdditionalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more IncumbentsAdditionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incumbentsAdditionalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many IncumbentsAdditionals
     * const incumbentsAdditional = await prisma.incumbentsAdditional.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends incumbentsAdditionalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, incumbentsAdditionalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one IncumbentsAdditional.
     * @param {incumbentsAdditionalUpsertArgs} args - Arguments to update or create a IncumbentsAdditional.
     * @example
     * // Update or create a IncumbentsAdditional
     * const incumbentsAdditional = await prisma.incumbentsAdditional.upsert({
     *   create: {
     *     // ... data to create a IncumbentsAdditional
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the IncumbentsAdditional we want to update
     *   }
     * })
    **/
    upsert<T extends incumbentsAdditionalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, incumbentsAdditionalUpsertArgs<ExtArgs>>
    ): Prisma__incumbentsAdditionalClient<$Result.GetResult<Prisma.$incumbentsAdditionalPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of IncumbentsAdditionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incumbentsAdditionalCountArgs} args - Arguments to filter IncumbentsAdditionals to count.
     * @example
     * // Count the number of IncumbentsAdditionals
     * const count = await prisma.incumbentsAdditional.count({
     *   where: {
     *     // ... the filter for the IncumbentsAdditionals we want to count
     *   }
     * })
    **/
    count<T extends incumbentsAdditionalCountArgs>(
      args?: Subset<T, incumbentsAdditionalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IncumbentsAdditionalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a IncumbentsAdditional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IncumbentsAdditionalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IncumbentsAdditionalAggregateArgs>(args: Subset<T, IncumbentsAdditionalAggregateArgs>): Prisma.PrismaPromise<GetIncumbentsAdditionalAggregateType<T>>

    /**
     * Group by IncumbentsAdditional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incumbentsAdditionalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends incumbentsAdditionalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: incumbentsAdditionalGroupByArgs['orderBy'] }
        : { orderBy?: incumbentsAdditionalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, incumbentsAdditionalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncumbentsAdditionalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the incumbentsAdditional model
   */
  readonly fields: incumbentsAdditionalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for incumbentsAdditional.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__incumbentsAdditionalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    company<T extends incumbentsAdditional$companyArgs<ExtArgs> = {}>(args?: Subset<T, incumbentsAdditional$companyArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    school<T extends incumbentsAdditional$schoolArgs<ExtArgs> = {}>(args?: Subset<T, incumbentsAdditional$schoolArgs<ExtArgs>>): Prisma__schoolClient<$Result.GetResult<Prisma.$schoolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    major<T extends incumbentsAdditional$majorArgs<ExtArgs> = {}>(args?: Subset<T, incumbentsAdditional$majorArgs<ExtArgs>>): Prisma__majorClient<$Result.GetResult<Prisma.$majorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    job<T extends incumbentsAdditional$jobArgs<ExtArgs> = {}>(args?: Subset<T, incumbentsAdditional$jobArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the incumbentsAdditional model
   */ 
  interface incumbentsAdditionalFieldRefs {
    readonly id: FieldRef<"incumbentsAdditional", 'Int'>
    readonly userId: FieldRef<"incumbentsAdditional", 'Int'>
    readonly companyId: FieldRef<"incumbentsAdditional", 'Int'>
    readonly schoolId: FieldRef<"incumbentsAdditional", 'Int'>
    readonly majorId: FieldRef<"incumbentsAdditional", 'Int'>
    readonly bigJobId: FieldRef<"incumbentsAdditional", 'Int'>
    readonly midJobId: FieldRef<"incumbentsAdditional", 'Int'>
    readonly smallJobId: FieldRef<"incumbentsAdditional", 'Int'>
    readonly jobId: FieldRef<"incumbentsAdditional", 'Int'>
    readonly shortSpec: FieldRef<"incumbentsAdditional", 'String'>
    readonly reportedNum: FieldRef<"incumbentsAdditional", 'Int'>
    readonly adviceCount: FieldRef<"incumbentsAdditional", 'Int'>
    readonly estimationCount: FieldRef<"incumbentsAdditional", 'Float'>
    readonly updatedDate: FieldRef<"incumbentsAdditional", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * incumbentsAdditional findUnique
   */
  export type incumbentsAdditionalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incumbentsAdditional
     */
    select?: incumbentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incumbentsAdditionalInclude<ExtArgs> | null
    /**
     * Filter, which incumbentsAdditional to fetch.
     */
    where: incumbentsAdditionalWhereUniqueInput
  }


  /**
   * incumbentsAdditional findUniqueOrThrow
   */
  export type incumbentsAdditionalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incumbentsAdditional
     */
    select?: incumbentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incumbentsAdditionalInclude<ExtArgs> | null
    /**
     * Filter, which incumbentsAdditional to fetch.
     */
    where: incumbentsAdditionalWhereUniqueInput
  }


  /**
   * incumbentsAdditional findFirst
   */
  export type incumbentsAdditionalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incumbentsAdditional
     */
    select?: incumbentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incumbentsAdditionalInclude<ExtArgs> | null
    /**
     * Filter, which incumbentsAdditional to fetch.
     */
    where?: incumbentsAdditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incumbentsAdditionals to fetch.
     */
    orderBy?: incumbentsAdditionalOrderByWithRelationInput | incumbentsAdditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for incumbentsAdditionals.
     */
    cursor?: incumbentsAdditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incumbentsAdditionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incumbentsAdditionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of incumbentsAdditionals.
     */
    distinct?: IncumbentsAdditionalScalarFieldEnum | IncumbentsAdditionalScalarFieldEnum[]
  }


  /**
   * incumbentsAdditional findFirstOrThrow
   */
  export type incumbentsAdditionalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incumbentsAdditional
     */
    select?: incumbentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incumbentsAdditionalInclude<ExtArgs> | null
    /**
     * Filter, which incumbentsAdditional to fetch.
     */
    where?: incumbentsAdditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incumbentsAdditionals to fetch.
     */
    orderBy?: incumbentsAdditionalOrderByWithRelationInput | incumbentsAdditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for incumbentsAdditionals.
     */
    cursor?: incumbentsAdditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incumbentsAdditionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incumbentsAdditionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of incumbentsAdditionals.
     */
    distinct?: IncumbentsAdditionalScalarFieldEnum | IncumbentsAdditionalScalarFieldEnum[]
  }


  /**
   * incumbentsAdditional findMany
   */
  export type incumbentsAdditionalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incumbentsAdditional
     */
    select?: incumbentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incumbentsAdditionalInclude<ExtArgs> | null
    /**
     * Filter, which incumbentsAdditionals to fetch.
     */
    where?: incumbentsAdditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incumbentsAdditionals to fetch.
     */
    orderBy?: incumbentsAdditionalOrderByWithRelationInput | incumbentsAdditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing incumbentsAdditionals.
     */
    cursor?: incumbentsAdditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incumbentsAdditionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incumbentsAdditionals.
     */
    skip?: number
    distinct?: IncumbentsAdditionalScalarFieldEnum | IncumbentsAdditionalScalarFieldEnum[]
  }


  /**
   * incumbentsAdditional create
   */
  export type incumbentsAdditionalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incumbentsAdditional
     */
    select?: incumbentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incumbentsAdditionalInclude<ExtArgs> | null
    /**
     * The data needed to create a incumbentsAdditional.
     */
    data: XOR<incumbentsAdditionalCreateInput, incumbentsAdditionalUncheckedCreateInput>
  }


  /**
   * incumbentsAdditional createMany
   */
  export type incumbentsAdditionalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many incumbentsAdditionals.
     */
    data: incumbentsAdditionalCreateManyInput | incumbentsAdditionalCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * incumbentsAdditional update
   */
  export type incumbentsAdditionalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incumbentsAdditional
     */
    select?: incumbentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incumbentsAdditionalInclude<ExtArgs> | null
    /**
     * The data needed to update a incumbentsAdditional.
     */
    data: XOR<incumbentsAdditionalUpdateInput, incumbentsAdditionalUncheckedUpdateInput>
    /**
     * Choose, which incumbentsAdditional to update.
     */
    where: incumbentsAdditionalWhereUniqueInput
  }


  /**
   * incumbentsAdditional updateMany
   */
  export type incumbentsAdditionalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update incumbentsAdditionals.
     */
    data: XOR<incumbentsAdditionalUpdateManyMutationInput, incumbentsAdditionalUncheckedUpdateManyInput>
    /**
     * Filter which incumbentsAdditionals to update
     */
    where?: incumbentsAdditionalWhereInput
  }


  /**
   * incumbentsAdditional upsert
   */
  export type incumbentsAdditionalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incumbentsAdditional
     */
    select?: incumbentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incumbentsAdditionalInclude<ExtArgs> | null
    /**
     * The filter to search for the incumbentsAdditional to update in case it exists.
     */
    where: incumbentsAdditionalWhereUniqueInput
    /**
     * In case the incumbentsAdditional found by the `where` argument doesn't exist, create a new incumbentsAdditional with this data.
     */
    create: XOR<incumbentsAdditionalCreateInput, incumbentsAdditionalUncheckedCreateInput>
    /**
     * In case the incumbentsAdditional was found with the provided `where` argument, update it with this data.
     */
    update: XOR<incumbentsAdditionalUpdateInput, incumbentsAdditionalUncheckedUpdateInput>
  }


  /**
   * incumbentsAdditional delete
   */
  export type incumbentsAdditionalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incumbentsAdditional
     */
    select?: incumbentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incumbentsAdditionalInclude<ExtArgs> | null
    /**
     * Filter which incumbentsAdditional to delete.
     */
    where: incumbentsAdditionalWhereUniqueInput
  }


  /**
   * incumbentsAdditional deleteMany
   */
  export type incumbentsAdditionalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which incumbentsAdditionals to delete
     */
    where?: incumbentsAdditionalWhereInput
  }


  /**
   * incumbentsAdditional.company
   */
  export type incumbentsAdditional$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    where?: companyWhereInput
  }


  /**
   * incumbentsAdditional.school
   */
  export type incumbentsAdditional$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school
     */
    select?: schoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolInclude<ExtArgs> | null
    where?: schoolWhereInput
  }


  /**
   * incumbentsAdditional.major
   */
  export type incumbentsAdditional$majorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the major
     */
    select?: majorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: majorInclude<ExtArgs> | null
    where?: majorWhereInput
  }


  /**
   * incumbentsAdditional.job
   */
  export type incumbentsAdditional$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: jobInclude<ExtArgs> | null
    where?: jobWhereInput
  }


  /**
   * incumbentsAdditional without action
   */
  export type incumbentsAdditionalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incumbentsAdditional
     */
    select?: incumbentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incumbentsAdditionalInclude<ExtArgs> | null
  }



  /**
   * Model studentsAdditional
   */

  export type AggregateStudentsAdditional = {
    _count: StudentsAdditionalCountAggregateOutputType | null
    _avg: StudentsAdditionalAvgAggregateOutputType | null
    _sum: StudentsAdditionalSumAggregateOutputType | null
    _min: StudentsAdditionalMinAggregateOutputType | null
    _max: StudentsAdditionalMaxAggregateOutputType | null
  }

  export type StudentsAdditionalAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    wishCompanyId: number | null
    schoolId: number | null
    majorId: number | null
    wishBigJobId: number | null
    wishMidJobId: number | null
    wishSmallJobId: number | null
    wishJobId: number | null
    reportedNum: number | null
    totalGrade: number | null
    adviceCount: number | null
    estimationCount: number | null
  }

  export type StudentsAdditionalSumAggregateOutputType = {
    id: number | null
    userId: number | null
    wishCompanyId: number | null
    schoolId: number | null
    majorId: number | null
    wishBigJobId: number | null
    wishMidJobId: number | null
    wishSmallJobId: number | null
    wishJobId: number | null
    reportedNum: number | null
    totalGrade: number | null
    adviceCount: number | null
    estimationCount: number | null
  }

  export type StudentsAdditionalMinAggregateOutputType = {
    id: number | null
    userId: number | null
    wishCompanyId: number | null
    schoolId: number | null
    majorId: number | null
    wishBigJobId: number | null
    wishMidJobId: number | null
    wishSmallJobId: number | null
    wishJobId: number | null
    portfolio: string | null
    reportedNum: number | null
    totalGrade: number | null
    adviceCount: number | null
    estimationCount: number | null
    updatedDate: Date | null
  }

  export type StudentsAdditionalMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    wishCompanyId: number | null
    schoolId: number | null
    majorId: number | null
    wishBigJobId: number | null
    wishMidJobId: number | null
    wishSmallJobId: number | null
    wishJobId: number | null
    portfolio: string | null
    reportedNum: number | null
    totalGrade: number | null
    adviceCount: number | null
    estimationCount: number | null
    updatedDate: Date | null
  }

  export type StudentsAdditionalCountAggregateOutputType = {
    id: number
    userId: number
    wishCompanyId: number
    schoolId: number
    majorId: number
    wishBigJobId: number
    wishMidJobId: number
    wishSmallJobId: number
    wishJobId: number
    portfolio: number
    reportedNum: number
    totalGrade: number
    adviceCount: number
    estimationCount: number
    updatedDate: number
    _all: number
  }


  export type StudentsAdditionalAvgAggregateInputType = {
    id?: true
    userId?: true
    wishCompanyId?: true
    schoolId?: true
    majorId?: true
    wishBigJobId?: true
    wishMidJobId?: true
    wishSmallJobId?: true
    wishJobId?: true
    reportedNum?: true
    totalGrade?: true
    adviceCount?: true
    estimationCount?: true
  }

  export type StudentsAdditionalSumAggregateInputType = {
    id?: true
    userId?: true
    wishCompanyId?: true
    schoolId?: true
    majorId?: true
    wishBigJobId?: true
    wishMidJobId?: true
    wishSmallJobId?: true
    wishJobId?: true
    reportedNum?: true
    totalGrade?: true
    adviceCount?: true
    estimationCount?: true
  }

  export type StudentsAdditionalMinAggregateInputType = {
    id?: true
    userId?: true
    wishCompanyId?: true
    schoolId?: true
    majorId?: true
    wishBigJobId?: true
    wishMidJobId?: true
    wishSmallJobId?: true
    wishJobId?: true
    portfolio?: true
    reportedNum?: true
    totalGrade?: true
    adviceCount?: true
    estimationCount?: true
    updatedDate?: true
  }

  export type StudentsAdditionalMaxAggregateInputType = {
    id?: true
    userId?: true
    wishCompanyId?: true
    schoolId?: true
    majorId?: true
    wishBigJobId?: true
    wishMidJobId?: true
    wishSmallJobId?: true
    wishJobId?: true
    portfolio?: true
    reportedNum?: true
    totalGrade?: true
    adviceCount?: true
    estimationCount?: true
    updatedDate?: true
  }

  export type StudentsAdditionalCountAggregateInputType = {
    id?: true
    userId?: true
    wishCompanyId?: true
    schoolId?: true
    majorId?: true
    wishBigJobId?: true
    wishMidJobId?: true
    wishSmallJobId?: true
    wishJobId?: true
    portfolio?: true
    reportedNum?: true
    totalGrade?: true
    adviceCount?: true
    estimationCount?: true
    updatedDate?: true
    _all?: true
  }

  export type StudentsAdditionalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which studentsAdditional to aggregate.
     */
    where?: studentsAdditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentsAdditionals to fetch.
     */
    orderBy?: studentsAdditionalOrderByWithRelationInput | studentsAdditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: studentsAdditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentsAdditionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentsAdditionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned studentsAdditionals
    **/
    _count?: true | StudentsAdditionalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentsAdditionalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentsAdditionalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentsAdditionalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentsAdditionalMaxAggregateInputType
  }

  export type GetStudentsAdditionalAggregateType<T extends StudentsAdditionalAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentsAdditional]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentsAdditional[P]>
      : GetScalarType<T[P], AggregateStudentsAdditional[P]>
  }




  export type studentsAdditionalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: studentsAdditionalWhereInput
    orderBy?: studentsAdditionalOrderByWithAggregationInput | studentsAdditionalOrderByWithAggregationInput[]
    by: StudentsAdditionalScalarFieldEnum[] | StudentsAdditionalScalarFieldEnum
    having?: studentsAdditionalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentsAdditionalCountAggregateInputType | true
    _avg?: StudentsAdditionalAvgAggregateInputType
    _sum?: StudentsAdditionalSumAggregateInputType
    _min?: StudentsAdditionalMinAggregateInputType
    _max?: StudentsAdditionalMaxAggregateInputType
  }

  export type StudentsAdditionalGroupByOutputType = {
    id: number
    userId: number
    wishCompanyId: number | null
    schoolId: number | null
    majorId: number | null
    wishBigJobId: number | null
    wishMidJobId: number | null
    wishSmallJobId: number | null
    wishJobId: number | null
    portfolio: string | null
    reportedNum: number
    totalGrade: number | null
    adviceCount: number
    estimationCount: number
    updatedDate: Date
    _count: StudentsAdditionalCountAggregateOutputType | null
    _avg: StudentsAdditionalAvgAggregateOutputType | null
    _sum: StudentsAdditionalSumAggregateOutputType | null
    _min: StudentsAdditionalMinAggregateOutputType | null
    _max: StudentsAdditionalMaxAggregateOutputType | null
  }

  type GetStudentsAdditionalGroupByPayload<T extends studentsAdditionalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentsAdditionalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentsAdditionalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentsAdditionalGroupByOutputType[P]>
            : GetScalarType<T[P], StudentsAdditionalGroupByOutputType[P]>
        }
      >
    >


  export type studentsAdditionalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    wishCompanyId?: boolean
    schoolId?: boolean
    majorId?: boolean
    wishBigJobId?: boolean
    wishMidJobId?: boolean
    wishSmallJobId?: boolean
    wishJobId?: boolean
    portfolio?: boolean
    reportedNum?: boolean
    totalGrade?: boolean
    adviceCount?: boolean
    estimationCount?: boolean
    updatedDate?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    wishCompany?: boolean | studentsAdditional$wishCompanyArgs<ExtArgs>
    school?: boolean | studentsAdditional$schoolArgs<ExtArgs>
    major?: boolean | studentsAdditional$majorArgs<ExtArgs>
    wishJob?: boolean | studentsAdditional$wishJobArgs<ExtArgs>
  }, ExtArgs["result"]["studentsAdditional"]>

  export type studentsAdditionalSelectScalar = {
    id?: boolean
    userId?: boolean
    wishCompanyId?: boolean
    schoolId?: boolean
    majorId?: boolean
    wishBigJobId?: boolean
    wishMidJobId?: boolean
    wishSmallJobId?: boolean
    wishJobId?: boolean
    portfolio?: boolean
    reportedNum?: boolean
    totalGrade?: boolean
    adviceCount?: boolean
    estimationCount?: boolean
    updatedDate?: boolean
  }

  export type studentsAdditionalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    wishCompany?: boolean | studentsAdditional$wishCompanyArgs<ExtArgs>
    school?: boolean | studentsAdditional$schoolArgs<ExtArgs>
    major?: boolean | studentsAdditional$majorArgs<ExtArgs>
    wishJob?: boolean | studentsAdditional$wishJobArgs<ExtArgs>
  }


  export type $studentsAdditionalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "studentsAdditional"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      wishCompany: Prisma.$companyPayload<ExtArgs> | null
      school: Prisma.$schoolPayload<ExtArgs> | null
      major: Prisma.$majorPayload<ExtArgs> | null
      wishJob: Prisma.$jobPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      wishCompanyId: number | null
      schoolId: number | null
      majorId: number | null
      wishBigJobId: number | null
      wishMidJobId: number | null
      wishSmallJobId: number | null
      wishJobId: number | null
      portfolio: string | null
      reportedNum: number
      totalGrade: number | null
      adviceCount: number
      estimationCount: number
      updatedDate: Date
    }, ExtArgs["result"]["studentsAdditional"]>
    composites: {}
  }


  type studentsAdditionalGetPayload<S extends boolean | null | undefined | studentsAdditionalDefaultArgs> = $Result.GetResult<Prisma.$studentsAdditionalPayload, S>

  type studentsAdditionalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<studentsAdditionalFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: StudentsAdditionalCountAggregateInputType | true
    }

  export interface studentsAdditionalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['studentsAdditional'], meta: { name: 'studentsAdditional' } }
    /**
     * Find zero or one StudentsAdditional that matches the filter.
     * @param {studentsAdditionalFindUniqueArgs} args - Arguments to find a StudentsAdditional
     * @example
     * // Get one StudentsAdditional
     * const studentsAdditional = await prisma.studentsAdditional.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends studentsAdditionalFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, studentsAdditionalFindUniqueArgs<ExtArgs>>
    ): Prisma__studentsAdditionalClient<$Result.GetResult<Prisma.$studentsAdditionalPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StudentsAdditional that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {studentsAdditionalFindUniqueOrThrowArgs} args - Arguments to find a StudentsAdditional
     * @example
     * // Get one StudentsAdditional
     * const studentsAdditional = await prisma.studentsAdditional.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends studentsAdditionalFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, studentsAdditionalFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__studentsAdditionalClient<$Result.GetResult<Prisma.$studentsAdditionalPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StudentsAdditional that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsAdditionalFindFirstArgs} args - Arguments to find a StudentsAdditional
     * @example
     * // Get one StudentsAdditional
     * const studentsAdditional = await prisma.studentsAdditional.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends studentsAdditionalFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, studentsAdditionalFindFirstArgs<ExtArgs>>
    ): Prisma__studentsAdditionalClient<$Result.GetResult<Prisma.$studentsAdditionalPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StudentsAdditional that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsAdditionalFindFirstOrThrowArgs} args - Arguments to find a StudentsAdditional
     * @example
     * // Get one StudentsAdditional
     * const studentsAdditional = await prisma.studentsAdditional.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends studentsAdditionalFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, studentsAdditionalFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__studentsAdditionalClient<$Result.GetResult<Prisma.$studentsAdditionalPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StudentsAdditionals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsAdditionalFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentsAdditionals
     * const studentsAdditionals = await prisma.studentsAdditional.findMany()
     * 
     * // Get first 10 StudentsAdditionals
     * const studentsAdditionals = await prisma.studentsAdditional.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentsAdditionalWithIdOnly = await prisma.studentsAdditional.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends studentsAdditionalFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, studentsAdditionalFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsAdditionalPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StudentsAdditional.
     * @param {studentsAdditionalCreateArgs} args - Arguments to create a StudentsAdditional.
     * @example
     * // Create one StudentsAdditional
     * const StudentsAdditional = await prisma.studentsAdditional.create({
     *   data: {
     *     // ... data to create a StudentsAdditional
     *   }
     * })
     * 
    **/
    create<T extends studentsAdditionalCreateArgs<ExtArgs>>(
      args: SelectSubset<T, studentsAdditionalCreateArgs<ExtArgs>>
    ): Prisma__studentsAdditionalClient<$Result.GetResult<Prisma.$studentsAdditionalPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StudentsAdditionals.
     *     @param {studentsAdditionalCreateManyArgs} args - Arguments to create many StudentsAdditionals.
     *     @example
     *     // Create many StudentsAdditionals
     *     const studentsAdditional = await prisma.studentsAdditional.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends studentsAdditionalCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, studentsAdditionalCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentsAdditional.
     * @param {studentsAdditionalDeleteArgs} args - Arguments to delete one StudentsAdditional.
     * @example
     * // Delete one StudentsAdditional
     * const StudentsAdditional = await prisma.studentsAdditional.delete({
     *   where: {
     *     // ... filter to delete one StudentsAdditional
     *   }
     * })
     * 
    **/
    delete<T extends studentsAdditionalDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, studentsAdditionalDeleteArgs<ExtArgs>>
    ): Prisma__studentsAdditionalClient<$Result.GetResult<Prisma.$studentsAdditionalPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StudentsAdditional.
     * @param {studentsAdditionalUpdateArgs} args - Arguments to update one StudentsAdditional.
     * @example
     * // Update one StudentsAdditional
     * const studentsAdditional = await prisma.studentsAdditional.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends studentsAdditionalUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, studentsAdditionalUpdateArgs<ExtArgs>>
    ): Prisma__studentsAdditionalClient<$Result.GetResult<Prisma.$studentsAdditionalPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StudentsAdditionals.
     * @param {studentsAdditionalDeleteManyArgs} args - Arguments to filter StudentsAdditionals to delete.
     * @example
     * // Delete a few StudentsAdditionals
     * const { count } = await prisma.studentsAdditional.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends studentsAdditionalDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, studentsAdditionalDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentsAdditionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsAdditionalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentsAdditionals
     * const studentsAdditional = await prisma.studentsAdditional.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends studentsAdditionalUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, studentsAdditionalUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentsAdditional.
     * @param {studentsAdditionalUpsertArgs} args - Arguments to update or create a StudentsAdditional.
     * @example
     * // Update or create a StudentsAdditional
     * const studentsAdditional = await prisma.studentsAdditional.upsert({
     *   create: {
     *     // ... data to create a StudentsAdditional
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentsAdditional we want to update
     *   }
     * })
    **/
    upsert<T extends studentsAdditionalUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, studentsAdditionalUpsertArgs<ExtArgs>>
    ): Prisma__studentsAdditionalClient<$Result.GetResult<Prisma.$studentsAdditionalPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StudentsAdditionals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsAdditionalCountArgs} args - Arguments to filter StudentsAdditionals to count.
     * @example
     * // Count the number of StudentsAdditionals
     * const count = await prisma.studentsAdditional.count({
     *   where: {
     *     // ... the filter for the StudentsAdditionals we want to count
     *   }
     * })
    **/
    count<T extends studentsAdditionalCountArgs>(
      args?: Subset<T, studentsAdditionalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentsAdditionalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentsAdditional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentsAdditionalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentsAdditionalAggregateArgs>(args: Subset<T, StudentsAdditionalAggregateArgs>): Prisma.PrismaPromise<GetStudentsAdditionalAggregateType<T>>

    /**
     * Group by StudentsAdditional.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {studentsAdditionalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends studentsAdditionalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: studentsAdditionalGroupByArgs['orderBy'] }
        : { orderBy?: studentsAdditionalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, studentsAdditionalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentsAdditionalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the studentsAdditional model
   */
  readonly fields: studentsAdditionalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for studentsAdditional.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__studentsAdditionalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    wishCompany<T extends studentsAdditional$wishCompanyArgs<ExtArgs> = {}>(args?: Subset<T, studentsAdditional$wishCompanyArgs<ExtArgs>>): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    school<T extends studentsAdditional$schoolArgs<ExtArgs> = {}>(args?: Subset<T, studentsAdditional$schoolArgs<ExtArgs>>): Prisma__schoolClient<$Result.GetResult<Prisma.$schoolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    major<T extends studentsAdditional$majorArgs<ExtArgs> = {}>(args?: Subset<T, studentsAdditional$majorArgs<ExtArgs>>): Prisma__majorClient<$Result.GetResult<Prisma.$majorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    wishJob<T extends studentsAdditional$wishJobArgs<ExtArgs> = {}>(args?: Subset<T, studentsAdditional$wishJobArgs<ExtArgs>>): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the studentsAdditional model
   */ 
  interface studentsAdditionalFieldRefs {
    readonly id: FieldRef<"studentsAdditional", 'Int'>
    readonly userId: FieldRef<"studentsAdditional", 'Int'>
    readonly wishCompanyId: FieldRef<"studentsAdditional", 'Int'>
    readonly schoolId: FieldRef<"studentsAdditional", 'Int'>
    readonly majorId: FieldRef<"studentsAdditional", 'Int'>
    readonly wishBigJobId: FieldRef<"studentsAdditional", 'Int'>
    readonly wishMidJobId: FieldRef<"studentsAdditional", 'Int'>
    readonly wishSmallJobId: FieldRef<"studentsAdditional", 'Int'>
    readonly wishJobId: FieldRef<"studentsAdditional", 'Int'>
    readonly portfolio: FieldRef<"studentsAdditional", 'String'>
    readonly reportedNum: FieldRef<"studentsAdditional", 'Int'>
    readonly totalGrade: FieldRef<"studentsAdditional", 'Float'>
    readonly adviceCount: FieldRef<"studentsAdditional", 'Int'>
    readonly estimationCount: FieldRef<"studentsAdditional", 'Float'>
    readonly updatedDate: FieldRef<"studentsAdditional", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * studentsAdditional findUnique
   */
  export type studentsAdditionalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentsAdditional
     */
    select?: studentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: studentsAdditionalInclude<ExtArgs> | null
    /**
     * Filter, which studentsAdditional to fetch.
     */
    where: studentsAdditionalWhereUniqueInput
  }


  /**
   * studentsAdditional findUniqueOrThrow
   */
  export type studentsAdditionalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentsAdditional
     */
    select?: studentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: studentsAdditionalInclude<ExtArgs> | null
    /**
     * Filter, which studentsAdditional to fetch.
     */
    where: studentsAdditionalWhereUniqueInput
  }


  /**
   * studentsAdditional findFirst
   */
  export type studentsAdditionalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentsAdditional
     */
    select?: studentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: studentsAdditionalInclude<ExtArgs> | null
    /**
     * Filter, which studentsAdditional to fetch.
     */
    where?: studentsAdditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentsAdditionals to fetch.
     */
    orderBy?: studentsAdditionalOrderByWithRelationInput | studentsAdditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for studentsAdditionals.
     */
    cursor?: studentsAdditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentsAdditionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentsAdditionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of studentsAdditionals.
     */
    distinct?: StudentsAdditionalScalarFieldEnum | StudentsAdditionalScalarFieldEnum[]
  }


  /**
   * studentsAdditional findFirstOrThrow
   */
  export type studentsAdditionalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentsAdditional
     */
    select?: studentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: studentsAdditionalInclude<ExtArgs> | null
    /**
     * Filter, which studentsAdditional to fetch.
     */
    where?: studentsAdditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentsAdditionals to fetch.
     */
    orderBy?: studentsAdditionalOrderByWithRelationInput | studentsAdditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for studentsAdditionals.
     */
    cursor?: studentsAdditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentsAdditionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentsAdditionals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of studentsAdditionals.
     */
    distinct?: StudentsAdditionalScalarFieldEnum | StudentsAdditionalScalarFieldEnum[]
  }


  /**
   * studentsAdditional findMany
   */
  export type studentsAdditionalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentsAdditional
     */
    select?: studentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: studentsAdditionalInclude<ExtArgs> | null
    /**
     * Filter, which studentsAdditionals to fetch.
     */
    where?: studentsAdditionalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of studentsAdditionals to fetch.
     */
    orderBy?: studentsAdditionalOrderByWithRelationInput | studentsAdditionalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing studentsAdditionals.
     */
    cursor?: studentsAdditionalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` studentsAdditionals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` studentsAdditionals.
     */
    skip?: number
    distinct?: StudentsAdditionalScalarFieldEnum | StudentsAdditionalScalarFieldEnum[]
  }


  /**
   * studentsAdditional create
   */
  export type studentsAdditionalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentsAdditional
     */
    select?: studentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: studentsAdditionalInclude<ExtArgs> | null
    /**
     * The data needed to create a studentsAdditional.
     */
    data: XOR<studentsAdditionalCreateInput, studentsAdditionalUncheckedCreateInput>
  }


  /**
   * studentsAdditional createMany
   */
  export type studentsAdditionalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many studentsAdditionals.
     */
    data: studentsAdditionalCreateManyInput | studentsAdditionalCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * studentsAdditional update
   */
  export type studentsAdditionalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentsAdditional
     */
    select?: studentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: studentsAdditionalInclude<ExtArgs> | null
    /**
     * The data needed to update a studentsAdditional.
     */
    data: XOR<studentsAdditionalUpdateInput, studentsAdditionalUncheckedUpdateInput>
    /**
     * Choose, which studentsAdditional to update.
     */
    where: studentsAdditionalWhereUniqueInput
  }


  /**
   * studentsAdditional updateMany
   */
  export type studentsAdditionalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update studentsAdditionals.
     */
    data: XOR<studentsAdditionalUpdateManyMutationInput, studentsAdditionalUncheckedUpdateManyInput>
    /**
     * Filter which studentsAdditionals to update
     */
    where?: studentsAdditionalWhereInput
  }


  /**
   * studentsAdditional upsert
   */
  export type studentsAdditionalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentsAdditional
     */
    select?: studentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: studentsAdditionalInclude<ExtArgs> | null
    /**
     * The filter to search for the studentsAdditional to update in case it exists.
     */
    where: studentsAdditionalWhereUniqueInput
    /**
     * In case the studentsAdditional found by the `where` argument doesn't exist, create a new studentsAdditional with this data.
     */
    create: XOR<studentsAdditionalCreateInput, studentsAdditionalUncheckedCreateInput>
    /**
     * In case the studentsAdditional was found with the provided `where` argument, update it with this data.
     */
    update: XOR<studentsAdditionalUpdateInput, studentsAdditionalUncheckedUpdateInput>
  }


  /**
   * studentsAdditional delete
   */
  export type studentsAdditionalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentsAdditional
     */
    select?: studentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: studentsAdditionalInclude<ExtArgs> | null
    /**
     * Filter which studentsAdditional to delete.
     */
    where: studentsAdditionalWhereUniqueInput
  }


  /**
   * studentsAdditional deleteMany
   */
  export type studentsAdditionalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which studentsAdditionals to delete
     */
    where?: studentsAdditionalWhereInput
  }


  /**
   * studentsAdditional.wishCompany
   */
  export type studentsAdditional$wishCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    where?: companyWhereInput
  }


  /**
   * studentsAdditional.school
   */
  export type studentsAdditional$schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school
     */
    select?: schoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolInclude<ExtArgs> | null
    where?: schoolWhereInput
  }


  /**
   * studentsAdditional.major
   */
  export type studentsAdditional$majorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the major
     */
    select?: majorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: majorInclude<ExtArgs> | null
    where?: majorWhereInput
  }


  /**
   * studentsAdditional.wishJob
   */
  export type studentsAdditional$wishJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: jobInclude<ExtArgs> | null
    where?: jobWhereInput
  }


  /**
   * studentsAdditional without action
   */
  export type studentsAdditionalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentsAdditional
     */
    select?: studentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: studentsAdditionalInclude<ExtArgs> | null
  }



  /**
   * Model category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which category to aggregate.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoryWhereInput
    orderBy?: categoryOrderByWithAggregationInput | categoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    posts?: boolean | category$postsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type categorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | category$postsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "category"
    objects: {
      posts: Prisma.$postsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }


  type categoryGetPayload<S extends boolean | null | undefined | categoryDefaultArgs> = $Result.GetResult<Prisma.$categoryPayload, S>

  type categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<categoryFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['category'], meta: { name: 'category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {categoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends categoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, categoryFindUniqueArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {categoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends categoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends categoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryFindFirstArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends categoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends categoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Category.
     * @param {categoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends categoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, categoryCreateArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Categories.
     *     @param {categoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends categoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {categoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends categoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, categoryDeleteArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Category.
     * @param {categoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends categoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, categoryUpdateArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {categoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends categoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends categoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, categoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {categoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends categoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, categoryUpsertArgs<ExtArgs>>
    ): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoryCountArgs>(
      args?: Subset<T, categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoryGroupByArgs['orderBy'] }
        : { orderBy?: categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the category model
   */
  readonly fields: categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    posts<T extends category$postsArgs<ExtArgs> = {}>(args?: Subset<T, category$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the category model
   */ 
  interface categoryFieldRefs {
    readonly id: FieldRef<"category", 'Int'>
    readonly name: FieldRef<"category", 'String'>
  }
    

  // Custom InputTypes

  /**
   * category findUnique
   */
  export type categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }


  /**
   * category findUniqueOrThrow
   */
  export type categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where: categoryWhereUniqueInput
  }


  /**
   * category findFirst
   */
  export type categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * category findFirstOrThrow
   */
  export type categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which category to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * category findMany
   */
  export type categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoryOrderByWithRelationInput | categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * category create
   */
  export type categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a category.
     */
    data: XOR<categoryCreateInput, categoryUncheckedCreateInput>
  }


  /**
   * category createMany
   */
  export type categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoryCreateManyInput | categoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * category update
   */
  export type categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a category.
     */
    data: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
    /**
     * Choose, which category to update.
     */
    where: categoryWhereUniqueInput
  }


  /**
   * category updateMany
   */
  export type categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoryUpdateManyMutationInput, categoryUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoryWhereInput
  }


  /**
   * category upsert
   */
  export type categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the category to update in case it exists.
     */
    where: categoryWhereUniqueInput
    /**
     * In case the category found by the `where` argument doesn't exist, create a new category with this data.
     */
    create: XOR<categoryCreateInput, categoryUncheckedCreateInput>
    /**
     * In case the category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoryUpdateInput, categoryUncheckedUpdateInput>
  }


  /**
   * category delete
   */
  export type categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    /**
     * Filter which category to delete.
     */
    where: categoryWhereUniqueInput
  }


  /**
   * category deleteMany
   */
  export type categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoryWhereInput
  }


  /**
   * category.posts
   */
  export type category$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: postsInclude<ExtArgs> | null
    where?: postsWhereInput
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    cursor?: postsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }


  /**
   * category without action
   */
  export type categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
  }



  /**
   * Model posts
   */

  export type AggregatePosts = {
    _count: PostsCountAggregateOutputType | null
    _avg: PostsAvgAggregateOutputType | null
    _sum: PostsSumAggregateOutputType | null
    _min: PostsMinAggregateOutputType | null
    _max: PostsMaxAggregateOutputType | null
  }

  export type PostsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    categoryId: number | null
    view: number | null
    recommend: number | null
    reported: number | null
  }

  export type PostsSumAggregateOutputType = {
    id: number | null
    userId: number | null
    categoryId: number | null
    view: number | null
    recommend: number | null
    reported: number | null
  }

  export type PostsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    categoryId: number | null
    title: string | null
    content: string | null
    view: number | null
    recommend: number | null
    reported: number | null
    createdDate: Date | null
    updatedDate: Date | null
  }

  export type PostsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    categoryId: number | null
    title: string | null
    content: string | null
    view: number | null
    recommend: number | null
    reported: number | null
    createdDate: Date | null
    updatedDate: Date | null
  }

  export type PostsCountAggregateOutputType = {
    id: number
    userId: number
    categoryId: number
    title: number
    content: number
    view: number
    recommend: number
    reported: number
    createdDate: number
    updatedDate: number
    _all: number
  }


  export type PostsAvgAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    view?: true
    recommend?: true
    reported?: true
  }

  export type PostsSumAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    view?: true
    recommend?: true
    reported?: true
  }

  export type PostsMinAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    title?: true
    content?: true
    view?: true
    recommend?: true
    reported?: true
    createdDate?: true
    updatedDate?: true
  }

  export type PostsMaxAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    title?: true
    content?: true
    view?: true
    recommend?: true
    reported?: true
    createdDate?: true
    updatedDate?: true
  }

  export type PostsCountAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    title?: true
    content?: true
    view?: true
    recommend?: true
    reported?: true
    createdDate?: true
    updatedDate?: true
    _all?: true
  }

  export type PostsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which posts to aggregate.
     */
    where?: postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned posts
    **/
    _count?: true | PostsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostsMaxAggregateInputType
  }

  export type GetPostsAggregateType<T extends PostsAggregateArgs> = {
        [P in keyof T & keyof AggregatePosts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosts[P]>
      : GetScalarType<T[P], AggregatePosts[P]>
  }




  export type postsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: postsWhereInput
    orderBy?: postsOrderByWithAggregationInput | postsOrderByWithAggregationInput[]
    by: PostsScalarFieldEnum[] | PostsScalarFieldEnum
    having?: postsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostsCountAggregateInputType | true
    _avg?: PostsAvgAggregateInputType
    _sum?: PostsSumAggregateInputType
    _min?: PostsMinAggregateInputType
    _max?: PostsMaxAggregateInputType
  }

  export type PostsGroupByOutputType = {
    id: number
    userId: number | null
    categoryId: number | null
    title: string
    content: string
    view: number
    recommend: number
    reported: number
    createdDate: Date
    updatedDate: Date
    _count: PostsCountAggregateOutputType | null
    _avg: PostsAvgAggregateOutputType | null
    _sum: PostsSumAggregateOutputType | null
    _min: PostsMinAggregateOutputType | null
    _max: PostsMaxAggregateOutputType | null
  }

  type GetPostsGroupByPayload<T extends postsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostsGroupByOutputType[P]>
            : GetScalarType<T[P], PostsGroupByOutputType[P]>
        }
      >
    >


  export type postsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    title?: boolean
    content?: boolean
    view?: boolean
    recommend?: boolean
    reported?: boolean
    createdDate?: boolean
    updatedDate?: boolean
    categories?: boolean | posts$categoriesArgs<ExtArgs>
    users?: boolean | posts$usersArgs<ExtArgs>
    comments?: boolean | posts$commentsArgs<ExtArgs>
    recommend_posts?: boolean | posts$recommend_postsArgs<ExtArgs>
    reported_posts?: boolean | posts$reported_postsArgs<ExtArgs>
    _count?: boolean | PostsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posts"]>

  export type postsSelectScalar = {
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    title?: boolean
    content?: boolean
    view?: boolean
    recommend?: boolean
    reported?: boolean
    createdDate?: boolean
    updatedDate?: boolean
  }

  export type postsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | posts$categoriesArgs<ExtArgs>
    users?: boolean | posts$usersArgs<ExtArgs>
    comments?: boolean | posts$commentsArgs<ExtArgs>
    recommend_posts?: boolean | posts$recommend_postsArgs<ExtArgs>
    reported_posts?: boolean | posts$reported_postsArgs<ExtArgs>
    _count?: boolean | PostsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $postsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "posts"
    objects: {
      categories: Prisma.$categoryPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
      comments: Prisma.$commentsPayload<ExtArgs>[]
      recommend_posts: Prisma.$recommendPostsPayload<ExtArgs>[]
      reported_posts: Prisma.$reportedPostsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      categoryId: number | null
      title: string
      content: string
      view: number
      recommend: number
      reported: number
      createdDate: Date
      updatedDate: Date
    }, ExtArgs["result"]["posts"]>
    composites: {}
  }


  type postsGetPayload<S extends boolean | null | undefined | postsDefaultArgs> = $Result.GetResult<Prisma.$postsPayload, S>

  type postsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<postsFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PostsCountAggregateInputType | true
    }

  export interface postsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['posts'], meta: { name: 'posts' } }
    /**
     * Find zero or one Posts that matches the filter.
     * @param {postsFindUniqueArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends postsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, postsFindUniqueArgs<ExtArgs>>
    ): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Posts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {postsFindUniqueOrThrowArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends postsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, postsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsFindFirstArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends postsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, postsFindFirstArgs<ExtArgs>>
    ): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Posts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsFindFirstOrThrowArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends postsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, postsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.posts.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.posts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postsWithIdOnly = await prisma.posts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends postsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, postsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Posts.
     * @param {postsCreateArgs} args - Arguments to create a Posts.
     * @example
     * // Create one Posts
     * const Posts = await prisma.posts.create({
     *   data: {
     *     // ... data to create a Posts
     *   }
     * })
     * 
    **/
    create<T extends postsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, postsCreateArgs<ExtArgs>>
    ): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Posts.
     *     @param {postsCreateManyArgs} args - Arguments to create many Posts.
     *     @example
     *     // Create many Posts
     *     const posts = await prisma.posts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends postsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, postsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Posts.
     * @param {postsDeleteArgs} args - Arguments to delete one Posts.
     * @example
     * // Delete one Posts
     * const Posts = await prisma.posts.delete({
     *   where: {
     *     // ... filter to delete one Posts
     *   }
     * })
     * 
    **/
    delete<T extends postsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, postsDeleteArgs<ExtArgs>>
    ): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Posts.
     * @param {postsUpdateArgs} args - Arguments to update one Posts.
     * @example
     * // Update one Posts
     * const posts = await prisma.posts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends postsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, postsUpdateArgs<ExtArgs>>
    ): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Posts.
     * @param {postsDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.posts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends postsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, postsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const posts = await prisma.posts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends postsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, postsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Posts.
     * @param {postsUpsertArgs} args - Arguments to update or create a Posts.
     * @example
     * // Update or create a Posts
     * const posts = await prisma.posts.upsert({
     *   create: {
     *     // ... data to create a Posts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Posts we want to update
     *   }
     * })
    **/
    upsert<T extends postsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, postsUpsertArgs<ExtArgs>>
    ): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.posts.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends postsCountArgs>(
      args?: Subset<T, postsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostsAggregateArgs>(args: Subset<T, PostsAggregateArgs>): Prisma.PrismaPromise<GetPostsAggregateType<T>>

    /**
     * Group by Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends postsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: postsGroupByArgs['orderBy'] }
        : { orderBy?: postsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, postsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the posts model
   */
  readonly fields: postsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for posts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__postsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    categories<T extends posts$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, posts$categoriesArgs<ExtArgs>>): Prisma__categoryClient<$Result.GetResult<Prisma.$categoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    users<T extends posts$usersArgs<ExtArgs> = {}>(args?: Subset<T, posts$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    comments<T extends posts$commentsArgs<ExtArgs> = {}>(args?: Subset<T, posts$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    recommend_posts<T extends posts$recommend_postsArgs<ExtArgs> = {}>(args?: Subset<T, posts$recommend_postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recommendPostsPayload<ExtArgs>, T, 'findMany'> | Null>;

    reported_posts<T extends posts$reported_postsArgs<ExtArgs> = {}>(args?: Subset<T, posts$reported_postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportedPostsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the posts model
   */ 
  interface postsFieldRefs {
    readonly id: FieldRef<"posts", 'Int'>
    readonly userId: FieldRef<"posts", 'Int'>
    readonly categoryId: FieldRef<"posts", 'Int'>
    readonly title: FieldRef<"posts", 'String'>
    readonly content: FieldRef<"posts", 'String'>
    readonly view: FieldRef<"posts", 'Int'>
    readonly recommend: FieldRef<"posts", 'Int'>
    readonly reported: FieldRef<"posts", 'Int'>
    readonly createdDate: FieldRef<"posts", 'DateTime'>
    readonly updatedDate: FieldRef<"posts", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * posts findUnique
   */
  export type postsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where: postsWhereUniqueInput
  }


  /**
   * posts findUniqueOrThrow
   */
  export type postsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where: postsWhereUniqueInput
  }


  /**
   * posts findFirst
   */
  export type postsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where?: postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for posts.
     */
    cursor?: postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of posts.
     */
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }


  /**
   * posts findFirstOrThrow
   */
  export type postsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where?: postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for posts.
     */
    cursor?: postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of posts.
     */
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }


  /**
   * posts findMany
   */
  export type postsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where?: postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing posts.
     */
    cursor?: postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }


  /**
   * posts create
   */
  export type postsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * The data needed to create a posts.
     */
    data: XOR<postsCreateInput, postsUncheckedCreateInput>
  }


  /**
   * posts createMany
   */
  export type postsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many posts.
     */
    data: postsCreateManyInput | postsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * posts update
   */
  export type postsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * The data needed to update a posts.
     */
    data: XOR<postsUpdateInput, postsUncheckedUpdateInput>
    /**
     * Choose, which posts to update.
     */
    where: postsWhereUniqueInput
  }


  /**
   * posts updateMany
   */
  export type postsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update posts.
     */
    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyInput>
    /**
     * Filter which posts to update
     */
    where?: postsWhereInput
  }


  /**
   * posts upsert
   */
  export type postsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * The filter to search for the posts to update in case it exists.
     */
    where: postsWhereUniqueInput
    /**
     * In case the posts found by the `where` argument doesn't exist, create a new posts with this data.
     */
    create: XOR<postsCreateInput, postsUncheckedCreateInput>
    /**
     * In case the posts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<postsUpdateInput, postsUncheckedUpdateInput>
  }


  /**
   * posts delete
   */
  export type postsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter which posts to delete.
     */
    where: postsWhereUniqueInput
  }


  /**
   * posts deleteMany
   */
  export type postsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which posts to delete
     */
    where?: postsWhereInput
  }


  /**
   * posts.categories
   */
  export type posts$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the category
     */
    select?: categorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoryInclude<ExtArgs> | null
    where?: categoryWhereInput
  }


  /**
   * posts.users
   */
  export type posts$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }


  /**
   * posts.comments
   */
  export type posts$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    cursor?: commentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }


  /**
   * posts.recommend_posts
   */
  export type posts$recommend_postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendPosts
     */
    select?: recommendPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendPostsInclude<ExtArgs> | null
    where?: recommendPostsWhereInput
    orderBy?: recommendPostsOrderByWithRelationInput | recommendPostsOrderByWithRelationInput[]
    cursor?: recommendPostsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecommendPostsScalarFieldEnum | RecommendPostsScalarFieldEnum[]
  }


  /**
   * posts.reported_posts
   */
  export type posts$reported_postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedPosts
     */
    select?: reportedPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedPostsInclude<ExtArgs> | null
    where?: reportedPostsWhereInput
    orderBy?: reportedPostsOrderByWithRelationInput | reportedPostsOrderByWithRelationInput[]
    cursor?: reportedPostsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportedPostsScalarFieldEnum | ReportedPostsScalarFieldEnum[]
  }


  /**
   * posts without action
   */
  export type postsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: postsInclude<ExtArgs> | null
  }



  /**
   * Model comments
   */

  export type AggregateComments = {
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  export type CommentsAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    parentCommentId: number | null
    recommend: number | null
    reported: number | null
  }

  export type CommentsSumAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    parentCommentId: number | null
    recommend: number | null
    reported: number | null
  }

  export type CommentsMinAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    content: string | null
    parentCommentId: number | null
    recommend: number | null
    reported: number | null
    createdDate: Date | null
    updatedDate: Date | null
    isDelete: boolean | null
  }

  export type CommentsMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    content: string | null
    parentCommentId: number | null
    recommend: number | null
    reported: number | null
    createdDate: Date | null
    updatedDate: Date | null
    isDelete: boolean | null
  }

  export type CommentsCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    content: number
    parentCommentId: number
    recommend: number
    reported: number
    createdDate: number
    updatedDate: number
    isDelete: number
    _all: number
  }


  export type CommentsAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    parentCommentId?: true
    recommend?: true
    reported?: true
  }

  export type CommentsSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    parentCommentId?: true
    recommend?: true
    reported?: true
  }

  export type CommentsMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    content?: true
    parentCommentId?: true
    recommend?: true
    reported?: true
    createdDate?: true
    updatedDate?: true
    isDelete?: true
  }

  export type CommentsMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    content?: true
    parentCommentId?: true
    recommend?: true
    reported?: true
    createdDate?: true
    updatedDate?: true
    isDelete?: true
  }

  export type CommentsCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    content?: true
    parentCommentId?: true
    recommend?: true
    reported?: true
    createdDate?: true
    updatedDate?: true
    isDelete?: true
    _all?: true
  }

  export type CommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to aggregate.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comments
    **/
    _count?: true | CommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentsMaxAggregateInputType
  }

  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComments[P]>
      : GetScalarType<T[P], AggregateComments[P]>
  }




  export type commentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithAggregationInput | commentsOrderByWithAggregationInput[]
    by: CommentsScalarFieldEnum[] | CommentsScalarFieldEnum
    having?: commentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentsCountAggregateInputType | true
    _avg?: CommentsAvgAggregateInputType
    _sum?: CommentsSumAggregateInputType
    _min?: CommentsMinAggregateInputType
    _max?: CommentsMaxAggregateInputType
  }

  export type CommentsGroupByOutputType = {
    id: number
    postId: number
    userId: number | null
    content: string
    parentCommentId: number | null
    recommend: number
    reported: number
    createdDate: Date
    updatedDate: Date
    isDelete: boolean
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  type GetCommentsGroupByPayload<T extends commentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentsGroupByOutputType[P]>
            : GetScalarType<T[P], CommentsGroupByOutputType[P]>
        }
      >
    >


  export type commentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    parentCommentId?: boolean
    recommend?: boolean
    reported?: boolean
    createdDate?: boolean
    updatedDate?: boolean
    isDelete?: boolean
    users?: boolean | comments$usersArgs<ExtArgs>
    post?: boolean | postsDefaultArgs<ExtArgs>
    parent?: boolean | comments$parentArgs<ExtArgs>
    replies?: boolean | comments$repliesArgs<ExtArgs>
    recommend_comments?: boolean | comments$recommend_commentsArgs<ExtArgs>
    reported_comments?: boolean | comments$reported_commentsArgs<ExtArgs>
    _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type commentsSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    parentCommentId?: boolean
    recommend?: boolean
    reported?: boolean
    createdDate?: boolean
    updatedDate?: boolean
    isDelete?: boolean
  }

  export type commentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | comments$usersArgs<ExtArgs>
    post?: boolean | postsDefaultArgs<ExtArgs>
    parent?: boolean | comments$parentArgs<ExtArgs>
    replies?: boolean | comments$repliesArgs<ExtArgs>
    recommend_comments?: boolean | comments$recommend_commentsArgs<ExtArgs>
    reported_comments?: boolean | comments$reported_commentsArgs<ExtArgs>
    _count?: boolean | CommentsCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $commentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comments"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
      post: Prisma.$postsPayload<ExtArgs>
      parent: Prisma.$commentsPayload<ExtArgs> | null
      replies: Prisma.$commentsPayload<ExtArgs>[]
      recommend_comments: Prisma.$recommendCommentsPayload<ExtArgs>[]
      reported_comments: Prisma.$reportedCommentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postId: number
      userId: number | null
      content: string
      parentCommentId: number | null
      recommend: number
      reported: number
      createdDate: Date
      updatedDate: Date
      isDelete: boolean
    }, ExtArgs["result"]["comments"]>
    composites: {}
  }


  type commentsGetPayload<S extends boolean | null | undefined | commentsDefaultArgs> = $Result.GetResult<Prisma.$commentsPayload, S>

  type commentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<commentsFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CommentsCountAggregateInputType | true
    }

  export interface commentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comments'], meta: { name: 'comments' } }
    /**
     * Find zero or one Comments that matches the filter.
     * @param {commentsFindUniqueArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends commentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, commentsFindUniqueArgs<ExtArgs>>
    ): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comments that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {commentsFindUniqueOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends commentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends commentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsFindFirstArgs<ExtArgs>>
    ): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends commentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comments.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentsWithIdOnly = await prisma.comments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends commentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comments.
     * @param {commentsCreateArgs} args - Arguments to create a Comments.
     * @example
     * // Create one Comments
     * const Comments = await prisma.comments.create({
     *   data: {
     *     // ... data to create a Comments
     *   }
     * })
     * 
    **/
    create<T extends commentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, commentsCreateArgs<ExtArgs>>
    ): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {commentsCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comments = await prisma.comments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends commentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comments.
     * @param {commentsDeleteArgs} args - Arguments to delete one Comments.
     * @example
     * // Delete one Comments
     * const Comments = await prisma.comments.delete({
     *   where: {
     *     // ... filter to delete one Comments
     *   }
     * })
     * 
    **/
    delete<T extends commentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, commentsDeleteArgs<ExtArgs>>
    ): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comments.
     * @param {commentsUpdateArgs} args - Arguments to update one Comments.
     * @example
     * // Update one Comments
     * const comments = await prisma.comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends commentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, commentsUpdateArgs<ExtArgs>>
    ): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {commentsDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends commentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, commentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends commentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, commentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comments.
     * @param {commentsUpsertArgs} args - Arguments to update or create a Comments.
     * @example
     * // Update or create a Comments
     * const comments = await prisma.comments.upsert({
     *   create: {
     *     // ... data to create a Comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comments we want to update
     *   }
     * })
    **/
    upsert<T extends commentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, commentsUpsertArgs<ExtArgs>>
    ): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comments.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends commentsCountArgs>(
      args?: Subset<T, commentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): Prisma.PrismaPromise<GetCommentsAggregateType<T>>

    /**
     * Group by Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends commentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: commentsGroupByArgs['orderBy'] }
        : { orderBy?: commentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, commentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comments model
   */
  readonly fields: commentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__commentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends comments$usersArgs<ExtArgs> = {}>(args?: Subset<T, comments$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    post<T extends postsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, postsDefaultArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    parent<T extends comments$parentArgs<ExtArgs> = {}>(args?: Subset<T, comments$parentArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    replies<T extends comments$repliesArgs<ExtArgs> = {}>(args?: Subset<T, comments$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    recommend_comments<T extends comments$recommend_commentsArgs<ExtArgs> = {}>(args?: Subset<T, comments$recommend_commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recommendCommentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    reported_comments<T extends comments$reported_commentsArgs<ExtArgs> = {}>(args?: Subset<T, comments$reported_commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportedCommentsPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the comments model
   */ 
  interface commentsFieldRefs {
    readonly id: FieldRef<"comments", 'Int'>
    readonly postId: FieldRef<"comments", 'Int'>
    readonly userId: FieldRef<"comments", 'Int'>
    readonly content: FieldRef<"comments", 'String'>
    readonly parentCommentId: FieldRef<"comments", 'Int'>
    readonly recommend: FieldRef<"comments", 'Int'>
    readonly reported: FieldRef<"comments", 'Int'>
    readonly createdDate: FieldRef<"comments", 'DateTime'>
    readonly updatedDate: FieldRef<"comments", 'DateTime'>
    readonly isDelete: FieldRef<"comments", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * comments findUnique
   */
  export type commentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }


  /**
   * comments findUniqueOrThrow
   */
  export type commentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }


  /**
   * comments findFirst
   */
  export type commentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }


  /**
   * comments findFirstOrThrow
   */
  export type commentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }


  /**
   * comments findMany
   */
  export type commentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }


  /**
   * comments create
   */
  export type commentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The data needed to create a comments.
     */
    data: XOR<commentsCreateInput, commentsUncheckedCreateInput>
  }


  /**
   * comments createMany
   */
  export type commentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comments.
     */
    data: commentsCreateManyInput | commentsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * comments update
   */
  export type commentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The data needed to update a comments.
     */
    data: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
    /**
     * Choose, which comments to update.
     */
    where: commentsWhereUniqueInput
  }


  /**
   * comments updateMany
   */
  export type commentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comments.
     */
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>
    /**
     * Filter which comments to update
     */
    where?: commentsWhereInput
  }


  /**
   * comments upsert
   */
  export type commentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The filter to search for the comments to update in case it exists.
     */
    where: commentsWhereUniqueInput
    /**
     * In case the comments found by the `where` argument doesn't exist, create a new comments with this data.
     */
    create: XOR<commentsCreateInput, commentsUncheckedCreateInput>
    /**
     * In case the comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
  }


  /**
   * comments delete
   */
  export type commentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter which comments to delete.
     */
    where: commentsWhereUniqueInput
  }


  /**
   * comments deleteMany
   */
  export type commentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to delete
     */
    where?: commentsWhereInput
  }


  /**
   * comments.users
   */
  export type comments$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }


  /**
   * comments.parent
   */
  export type comments$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
  }


  /**
   * comments.replies
   */
  export type comments$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    cursor?: commentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }


  /**
   * comments.recommend_comments
   */
  export type comments$recommend_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendComments
     */
    select?: recommendCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendCommentsInclude<ExtArgs> | null
    where?: recommendCommentsWhereInput
    orderBy?: recommendCommentsOrderByWithRelationInput | recommendCommentsOrderByWithRelationInput[]
    cursor?: recommendCommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecommendCommentsScalarFieldEnum | RecommendCommentsScalarFieldEnum[]
  }


  /**
   * comments.reported_comments
   */
  export type comments$reported_commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedComments
     */
    select?: reportedCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedCommentsInclude<ExtArgs> | null
    where?: reportedCommentsWhereInput
    orderBy?: reportedCommentsOrderByWithRelationInput | reportedCommentsOrderByWithRelationInput[]
    cursor?: reportedCommentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportedCommentsScalarFieldEnum | ReportedCommentsScalarFieldEnum[]
  }


  /**
   * comments without action
   */
  export type commentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: commentsInclude<ExtArgs> | null
  }



  /**
   * Model recommendPosts
   */

  export type AggregateRecommendPosts = {
    _count: RecommendPostsCountAggregateOutputType | null
    _avg: RecommendPostsAvgAggregateOutputType | null
    _sum: RecommendPostsSumAggregateOutputType | null
    _min: RecommendPostsMinAggregateOutputType | null
    _max: RecommendPostsMaxAggregateOutputType | null
  }

  export type RecommendPostsAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type RecommendPostsSumAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type RecommendPostsMinAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    createdDate: Date | null
  }

  export type RecommendPostsMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    createdDate: Date | null
  }

  export type RecommendPostsCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    createdDate: number
    _all: number
  }


  export type RecommendPostsAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type RecommendPostsSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type RecommendPostsMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdDate?: true
  }

  export type RecommendPostsMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdDate?: true
  }

  export type RecommendPostsCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    createdDate?: true
    _all?: true
  }

  export type RecommendPostsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recommendPosts to aggregate.
     */
    where?: recommendPostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recommendPosts to fetch.
     */
    orderBy?: recommendPostsOrderByWithRelationInput | recommendPostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recommendPostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recommendPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recommendPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recommendPosts
    **/
    _count?: true | RecommendPostsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecommendPostsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecommendPostsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecommendPostsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecommendPostsMaxAggregateInputType
  }

  export type GetRecommendPostsAggregateType<T extends RecommendPostsAggregateArgs> = {
        [P in keyof T & keyof AggregateRecommendPosts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecommendPosts[P]>
      : GetScalarType<T[P], AggregateRecommendPosts[P]>
  }




  export type recommendPostsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recommendPostsWhereInput
    orderBy?: recommendPostsOrderByWithAggregationInput | recommendPostsOrderByWithAggregationInput[]
    by: RecommendPostsScalarFieldEnum[] | RecommendPostsScalarFieldEnum
    having?: recommendPostsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecommendPostsCountAggregateInputType | true
    _avg?: RecommendPostsAvgAggregateInputType
    _sum?: RecommendPostsSumAggregateInputType
    _min?: RecommendPostsMinAggregateInputType
    _max?: RecommendPostsMaxAggregateInputType
  }

  export type RecommendPostsGroupByOutputType = {
    id: number
    postId: number
    userId: number
    createdDate: Date
    _count: RecommendPostsCountAggregateOutputType | null
    _avg: RecommendPostsAvgAggregateOutputType | null
    _sum: RecommendPostsSumAggregateOutputType | null
    _min: RecommendPostsMinAggregateOutputType | null
    _max: RecommendPostsMaxAggregateOutputType | null
  }

  type GetRecommendPostsGroupByPayload<T extends recommendPostsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecommendPostsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecommendPostsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecommendPostsGroupByOutputType[P]>
            : GetScalarType<T[P], RecommendPostsGroupByOutputType[P]>
        }
      >
    >


  export type recommendPostsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdDate?: boolean
    users?: boolean | recommendPosts$usersArgs<ExtArgs>
    post?: boolean | postsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recommendPosts"]>

  export type recommendPostsSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    createdDate?: boolean
  }

  export type recommendPostsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | recommendPosts$usersArgs<ExtArgs>
    post?: boolean | postsDefaultArgs<ExtArgs>
  }


  export type $recommendPostsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "recommendPosts"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
      post: Prisma.$postsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postId: number
      userId: number
      createdDate: Date
    }, ExtArgs["result"]["recommendPosts"]>
    composites: {}
  }


  type recommendPostsGetPayload<S extends boolean | null | undefined | recommendPostsDefaultArgs> = $Result.GetResult<Prisma.$recommendPostsPayload, S>

  type recommendPostsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<recommendPostsFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RecommendPostsCountAggregateInputType | true
    }

  export interface recommendPostsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['recommendPosts'], meta: { name: 'recommendPosts' } }
    /**
     * Find zero or one RecommendPosts that matches the filter.
     * @param {recommendPostsFindUniqueArgs} args - Arguments to find a RecommendPosts
     * @example
     * // Get one RecommendPosts
     * const recommendPosts = await prisma.recommendPosts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends recommendPostsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, recommendPostsFindUniqueArgs<ExtArgs>>
    ): Prisma__recommendPostsClient<$Result.GetResult<Prisma.$recommendPostsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RecommendPosts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {recommendPostsFindUniqueOrThrowArgs} args - Arguments to find a RecommendPosts
     * @example
     * // Get one RecommendPosts
     * const recommendPosts = await prisma.recommendPosts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends recommendPostsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, recommendPostsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__recommendPostsClient<$Result.GetResult<Prisma.$recommendPostsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RecommendPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommendPostsFindFirstArgs} args - Arguments to find a RecommendPosts
     * @example
     * // Get one RecommendPosts
     * const recommendPosts = await prisma.recommendPosts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends recommendPostsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, recommendPostsFindFirstArgs<ExtArgs>>
    ): Prisma__recommendPostsClient<$Result.GetResult<Prisma.$recommendPostsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RecommendPosts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommendPostsFindFirstOrThrowArgs} args - Arguments to find a RecommendPosts
     * @example
     * // Get one RecommendPosts
     * const recommendPosts = await prisma.recommendPosts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends recommendPostsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, recommendPostsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__recommendPostsClient<$Result.GetResult<Prisma.$recommendPostsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RecommendPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommendPostsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecommendPosts
     * const recommendPosts = await prisma.recommendPosts.findMany()
     * 
     * // Get first 10 RecommendPosts
     * const recommendPosts = await prisma.recommendPosts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recommendPostsWithIdOnly = await prisma.recommendPosts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends recommendPostsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, recommendPostsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recommendPostsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RecommendPosts.
     * @param {recommendPostsCreateArgs} args - Arguments to create a RecommendPosts.
     * @example
     * // Create one RecommendPosts
     * const RecommendPosts = await prisma.recommendPosts.create({
     *   data: {
     *     // ... data to create a RecommendPosts
     *   }
     * })
     * 
    **/
    create<T extends recommendPostsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, recommendPostsCreateArgs<ExtArgs>>
    ): Prisma__recommendPostsClient<$Result.GetResult<Prisma.$recommendPostsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RecommendPosts.
     *     @param {recommendPostsCreateManyArgs} args - Arguments to create many RecommendPosts.
     *     @example
     *     // Create many RecommendPosts
     *     const recommendPosts = await prisma.recommendPosts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends recommendPostsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, recommendPostsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecommendPosts.
     * @param {recommendPostsDeleteArgs} args - Arguments to delete one RecommendPosts.
     * @example
     * // Delete one RecommendPosts
     * const RecommendPosts = await prisma.recommendPosts.delete({
     *   where: {
     *     // ... filter to delete one RecommendPosts
     *   }
     * })
     * 
    **/
    delete<T extends recommendPostsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, recommendPostsDeleteArgs<ExtArgs>>
    ): Prisma__recommendPostsClient<$Result.GetResult<Prisma.$recommendPostsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RecommendPosts.
     * @param {recommendPostsUpdateArgs} args - Arguments to update one RecommendPosts.
     * @example
     * // Update one RecommendPosts
     * const recommendPosts = await prisma.recommendPosts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends recommendPostsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, recommendPostsUpdateArgs<ExtArgs>>
    ): Prisma__recommendPostsClient<$Result.GetResult<Prisma.$recommendPostsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RecommendPosts.
     * @param {recommendPostsDeleteManyArgs} args - Arguments to filter RecommendPosts to delete.
     * @example
     * // Delete a few RecommendPosts
     * const { count } = await prisma.recommendPosts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends recommendPostsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, recommendPostsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecommendPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommendPostsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecommendPosts
     * const recommendPosts = await prisma.recommendPosts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends recommendPostsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, recommendPostsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecommendPosts.
     * @param {recommendPostsUpsertArgs} args - Arguments to update or create a RecommendPosts.
     * @example
     * // Update or create a RecommendPosts
     * const recommendPosts = await prisma.recommendPosts.upsert({
     *   create: {
     *     // ... data to create a RecommendPosts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecommendPosts we want to update
     *   }
     * })
    **/
    upsert<T extends recommendPostsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, recommendPostsUpsertArgs<ExtArgs>>
    ): Prisma__recommendPostsClient<$Result.GetResult<Prisma.$recommendPostsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RecommendPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommendPostsCountArgs} args - Arguments to filter RecommendPosts to count.
     * @example
     * // Count the number of RecommendPosts
     * const count = await prisma.recommendPosts.count({
     *   where: {
     *     // ... the filter for the RecommendPosts we want to count
     *   }
     * })
    **/
    count<T extends recommendPostsCountArgs>(
      args?: Subset<T, recommendPostsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecommendPostsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecommendPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendPostsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecommendPostsAggregateArgs>(args: Subset<T, RecommendPostsAggregateArgs>): Prisma.PrismaPromise<GetRecommendPostsAggregateType<T>>

    /**
     * Group by RecommendPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommendPostsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends recommendPostsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: recommendPostsGroupByArgs['orderBy'] }
        : { orderBy?: recommendPostsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, recommendPostsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecommendPostsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the recommendPosts model
   */
  readonly fields: recommendPostsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for recommendPosts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__recommendPostsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends recommendPosts$usersArgs<ExtArgs> = {}>(args?: Subset<T, recommendPosts$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    post<T extends postsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, postsDefaultArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the recommendPosts model
   */ 
  interface recommendPostsFieldRefs {
    readonly id: FieldRef<"recommendPosts", 'Int'>
    readonly postId: FieldRef<"recommendPosts", 'Int'>
    readonly userId: FieldRef<"recommendPosts", 'Int'>
    readonly createdDate: FieldRef<"recommendPosts", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * recommendPosts findUnique
   */
  export type recommendPostsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendPosts
     */
    select?: recommendPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendPostsInclude<ExtArgs> | null
    /**
     * Filter, which recommendPosts to fetch.
     */
    where: recommendPostsWhereUniqueInput
  }


  /**
   * recommendPosts findUniqueOrThrow
   */
  export type recommendPostsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendPosts
     */
    select?: recommendPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendPostsInclude<ExtArgs> | null
    /**
     * Filter, which recommendPosts to fetch.
     */
    where: recommendPostsWhereUniqueInput
  }


  /**
   * recommendPosts findFirst
   */
  export type recommendPostsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendPosts
     */
    select?: recommendPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendPostsInclude<ExtArgs> | null
    /**
     * Filter, which recommendPosts to fetch.
     */
    where?: recommendPostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recommendPosts to fetch.
     */
    orderBy?: recommendPostsOrderByWithRelationInput | recommendPostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recommendPosts.
     */
    cursor?: recommendPostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recommendPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recommendPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recommendPosts.
     */
    distinct?: RecommendPostsScalarFieldEnum | RecommendPostsScalarFieldEnum[]
  }


  /**
   * recommendPosts findFirstOrThrow
   */
  export type recommendPostsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendPosts
     */
    select?: recommendPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendPostsInclude<ExtArgs> | null
    /**
     * Filter, which recommendPosts to fetch.
     */
    where?: recommendPostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recommendPosts to fetch.
     */
    orderBy?: recommendPostsOrderByWithRelationInput | recommendPostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recommendPosts.
     */
    cursor?: recommendPostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recommendPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recommendPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recommendPosts.
     */
    distinct?: RecommendPostsScalarFieldEnum | RecommendPostsScalarFieldEnum[]
  }


  /**
   * recommendPosts findMany
   */
  export type recommendPostsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendPosts
     */
    select?: recommendPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendPostsInclude<ExtArgs> | null
    /**
     * Filter, which recommendPosts to fetch.
     */
    where?: recommendPostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recommendPosts to fetch.
     */
    orderBy?: recommendPostsOrderByWithRelationInput | recommendPostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recommendPosts.
     */
    cursor?: recommendPostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recommendPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recommendPosts.
     */
    skip?: number
    distinct?: RecommendPostsScalarFieldEnum | RecommendPostsScalarFieldEnum[]
  }


  /**
   * recommendPosts create
   */
  export type recommendPostsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendPosts
     */
    select?: recommendPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendPostsInclude<ExtArgs> | null
    /**
     * The data needed to create a recommendPosts.
     */
    data: XOR<recommendPostsCreateInput, recommendPostsUncheckedCreateInput>
  }


  /**
   * recommendPosts createMany
   */
  export type recommendPostsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many recommendPosts.
     */
    data: recommendPostsCreateManyInput | recommendPostsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * recommendPosts update
   */
  export type recommendPostsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendPosts
     */
    select?: recommendPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendPostsInclude<ExtArgs> | null
    /**
     * The data needed to update a recommendPosts.
     */
    data: XOR<recommendPostsUpdateInput, recommendPostsUncheckedUpdateInput>
    /**
     * Choose, which recommendPosts to update.
     */
    where: recommendPostsWhereUniqueInput
  }


  /**
   * recommendPosts updateMany
   */
  export type recommendPostsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update recommendPosts.
     */
    data: XOR<recommendPostsUpdateManyMutationInput, recommendPostsUncheckedUpdateManyInput>
    /**
     * Filter which recommendPosts to update
     */
    where?: recommendPostsWhereInput
  }


  /**
   * recommendPosts upsert
   */
  export type recommendPostsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendPosts
     */
    select?: recommendPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendPostsInclude<ExtArgs> | null
    /**
     * The filter to search for the recommendPosts to update in case it exists.
     */
    where: recommendPostsWhereUniqueInput
    /**
     * In case the recommendPosts found by the `where` argument doesn't exist, create a new recommendPosts with this data.
     */
    create: XOR<recommendPostsCreateInput, recommendPostsUncheckedCreateInput>
    /**
     * In case the recommendPosts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recommendPostsUpdateInput, recommendPostsUncheckedUpdateInput>
  }


  /**
   * recommendPosts delete
   */
  export type recommendPostsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendPosts
     */
    select?: recommendPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendPostsInclude<ExtArgs> | null
    /**
     * Filter which recommendPosts to delete.
     */
    where: recommendPostsWhereUniqueInput
  }


  /**
   * recommendPosts deleteMany
   */
  export type recommendPostsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recommendPosts to delete
     */
    where?: recommendPostsWhereInput
  }


  /**
   * recommendPosts.users
   */
  export type recommendPosts$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }


  /**
   * recommendPosts without action
   */
  export type recommendPostsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendPosts
     */
    select?: recommendPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendPostsInclude<ExtArgs> | null
  }



  /**
   * Model reportedPosts
   */

  export type AggregateReportedPosts = {
    _count: ReportedPostsCountAggregateOutputType | null
    _avg: ReportedPostsAvgAggregateOutputType | null
    _sum: ReportedPostsSumAggregateOutputType | null
    _min: ReportedPostsMinAggregateOutputType | null
    _max: ReportedPostsMaxAggregateOutputType | null
  }

  export type ReportedPostsAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type ReportedPostsSumAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type ReportedPostsMinAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    reason: string | null
    createdDate: Date | null
  }

  export type ReportedPostsMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    reason: string | null
    createdDate: Date | null
  }

  export type ReportedPostsCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    reason: number
    createdDate: number
    _all: number
  }


  export type ReportedPostsAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type ReportedPostsSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type ReportedPostsMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    reason?: true
    createdDate?: true
  }

  export type ReportedPostsMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    reason?: true
    createdDate?: true
  }

  export type ReportedPostsCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    reason?: true
    createdDate?: true
    _all?: true
  }

  export type ReportedPostsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reportedPosts to aggregate.
     */
    where?: reportedPostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportedPosts to fetch.
     */
    orderBy?: reportedPostsOrderByWithRelationInput | reportedPostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reportedPostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportedPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportedPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reportedPosts
    **/
    _count?: true | ReportedPostsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportedPostsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportedPostsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportedPostsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportedPostsMaxAggregateInputType
  }

  export type GetReportedPostsAggregateType<T extends ReportedPostsAggregateArgs> = {
        [P in keyof T & keyof AggregateReportedPosts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportedPosts[P]>
      : GetScalarType<T[P], AggregateReportedPosts[P]>
  }




  export type reportedPostsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportedPostsWhereInput
    orderBy?: reportedPostsOrderByWithAggregationInput | reportedPostsOrderByWithAggregationInput[]
    by: ReportedPostsScalarFieldEnum[] | ReportedPostsScalarFieldEnum
    having?: reportedPostsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportedPostsCountAggregateInputType | true
    _avg?: ReportedPostsAvgAggregateInputType
    _sum?: ReportedPostsSumAggregateInputType
    _min?: ReportedPostsMinAggregateInputType
    _max?: ReportedPostsMaxAggregateInputType
  }

  export type ReportedPostsGroupByOutputType = {
    id: number
    postId: number
    userId: number
    reason: string
    createdDate: Date
    _count: ReportedPostsCountAggregateOutputType | null
    _avg: ReportedPostsAvgAggregateOutputType | null
    _sum: ReportedPostsSumAggregateOutputType | null
    _min: ReportedPostsMinAggregateOutputType | null
    _max: ReportedPostsMaxAggregateOutputType | null
  }

  type GetReportedPostsGroupByPayload<T extends reportedPostsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportedPostsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportedPostsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportedPostsGroupByOutputType[P]>
            : GetScalarType<T[P], ReportedPostsGroupByOutputType[P]>
        }
      >
    >


  export type reportedPostsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    reason?: boolean
    createdDate?: boolean
    users?: boolean | reportedPosts$usersArgs<ExtArgs>
    post?: boolean | postsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reportedPosts"]>

  export type reportedPostsSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    reason?: boolean
    createdDate?: boolean
  }

  export type reportedPostsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | reportedPosts$usersArgs<ExtArgs>
    post?: boolean | postsDefaultArgs<ExtArgs>
  }


  export type $reportedPostsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reportedPosts"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
      post: Prisma.$postsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postId: number
      userId: number
      reason: string
      createdDate: Date
    }, ExtArgs["result"]["reportedPosts"]>
    composites: {}
  }


  type reportedPostsGetPayload<S extends boolean | null | undefined | reportedPostsDefaultArgs> = $Result.GetResult<Prisma.$reportedPostsPayload, S>

  type reportedPostsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<reportedPostsFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ReportedPostsCountAggregateInputType | true
    }

  export interface reportedPostsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reportedPosts'], meta: { name: 'reportedPosts' } }
    /**
     * Find zero or one ReportedPosts that matches the filter.
     * @param {reportedPostsFindUniqueArgs} args - Arguments to find a ReportedPosts
     * @example
     * // Get one ReportedPosts
     * const reportedPosts = await prisma.reportedPosts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reportedPostsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, reportedPostsFindUniqueArgs<ExtArgs>>
    ): Prisma__reportedPostsClient<$Result.GetResult<Prisma.$reportedPostsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ReportedPosts that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reportedPostsFindUniqueOrThrowArgs} args - Arguments to find a ReportedPosts
     * @example
     * // Get one ReportedPosts
     * const reportedPosts = await prisma.reportedPosts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reportedPostsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedPostsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__reportedPostsClient<$Result.GetResult<Prisma.$reportedPostsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ReportedPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedPostsFindFirstArgs} args - Arguments to find a ReportedPosts
     * @example
     * // Get one ReportedPosts
     * const reportedPosts = await prisma.reportedPosts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reportedPostsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedPostsFindFirstArgs<ExtArgs>>
    ): Prisma__reportedPostsClient<$Result.GetResult<Prisma.$reportedPostsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ReportedPosts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedPostsFindFirstOrThrowArgs} args - Arguments to find a ReportedPosts
     * @example
     * // Get one ReportedPosts
     * const reportedPosts = await prisma.reportedPosts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reportedPostsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedPostsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__reportedPostsClient<$Result.GetResult<Prisma.$reportedPostsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ReportedPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedPostsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportedPosts
     * const reportedPosts = await prisma.reportedPosts.findMany()
     * 
     * // Get first 10 ReportedPosts
     * const reportedPosts = await prisma.reportedPosts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportedPostsWithIdOnly = await prisma.reportedPosts.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends reportedPostsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedPostsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportedPostsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ReportedPosts.
     * @param {reportedPostsCreateArgs} args - Arguments to create a ReportedPosts.
     * @example
     * // Create one ReportedPosts
     * const ReportedPosts = await prisma.reportedPosts.create({
     *   data: {
     *     // ... data to create a ReportedPosts
     *   }
     * })
     * 
    **/
    create<T extends reportedPostsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, reportedPostsCreateArgs<ExtArgs>>
    ): Prisma__reportedPostsClient<$Result.GetResult<Prisma.$reportedPostsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ReportedPosts.
     *     @param {reportedPostsCreateManyArgs} args - Arguments to create many ReportedPosts.
     *     @example
     *     // Create many ReportedPosts
     *     const reportedPosts = await prisma.reportedPosts.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reportedPostsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedPostsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReportedPosts.
     * @param {reportedPostsDeleteArgs} args - Arguments to delete one ReportedPosts.
     * @example
     * // Delete one ReportedPosts
     * const ReportedPosts = await prisma.reportedPosts.delete({
     *   where: {
     *     // ... filter to delete one ReportedPosts
     *   }
     * })
     * 
    **/
    delete<T extends reportedPostsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, reportedPostsDeleteArgs<ExtArgs>>
    ): Prisma__reportedPostsClient<$Result.GetResult<Prisma.$reportedPostsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ReportedPosts.
     * @param {reportedPostsUpdateArgs} args - Arguments to update one ReportedPosts.
     * @example
     * // Update one ReportedPosts
     * const reportedPosts = await prisma.reportedPosts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reportedPostsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, reportedPostsUpdateArgs<ExtArgs>>
    ): Prisma__reportedPostsClient<$Result.GetResult<Prisma.$reportedPostsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ReportedPosts.
     * @param {reportedPostsDeleteManyArgs} args - Arguments to filter ReportedPosts to delete.
     * @example
     * // Delete a few ReportedPosts
     * const { count } = await prisma.reportedPosts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reportedPostsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedPostsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportedPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedPostsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportedPosts
     * const reportedPosts = await prisma.reportedPosts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reportedPostsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, reportedPostsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportedPosts.
     * @param {reportedPostsUpsertArgs} args - Arguments to update or create a ReportedPosts.
     * @example
     * // Update or create a ReportedPosts
     * const reportedPosts = await prisma.reportedPosts.upsert({
     *   create: {
     *     // ... data to create a ReportedPosts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportedPosts we want to update
     *   }
     * })
    **/
    upsert<T extends reportedPostsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, reportedPostsUpsertArgs<ExtArgs>>
    ): Prisma__reportedPostsClient<$Result.GetResult<Prisma.$reportedPostsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ReportedPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedPostsCountArgs} args - Arguments to filter ReportedPosts to count.
     * @example
     * // Count the number of ReportedPosts
     * const count = await prisma.reportedPosts.count({
     *   where: {
     *     // ... the filter for the ReportedPosts we want to count
     *   }
     * })
    **/
    count<T extends reportedPostsCountArgs>(
      args?: Subset<T, reportedPostsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportedPostsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportedPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportedPostsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportedPostsAggregateArgs>(args: Subset<T, ReportedPostsAggregateArgs>): Prisma.PrismaPromise<GetReportedPostsAggregateType<T>>

    /**
     * Group by ReportedPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedPostsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reportedPostsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reportedPostsGroupByArgs['orderBy'] }
        : { orderBy?: reportedPostsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reportedPostsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportedPostsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reportedPosts model
   */
  readonly fields: reportedPostsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reportedPosts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reportedPostsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends reportedPosts$usersArgs<ExtArgs> = {}>(args?: Subset<T, reportedPosts$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    post<T extends postsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, postsDefaultArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the reportedPosts model
   */ 
  interface reportedPostsFieldRefs {
    readonly id: FieldRef<"reportedPosts", 'Int'>
    readonly postId: FieldRef<"reportedPosts", 'Int'>
    readonly userId: FieldRef<"reportedPosts", 'Int'>
    readonly reason: FieldRef<"reportedPosts", 'String'>
    readonly createdDate: FieldRef<"reportedPosts", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * reportedPosts findUnique
   */
  export type reportedPostsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedPosts
     */
    select?: reportedPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedPostsInclude<ExtArgs> | null
    /**
     * Filter, which reportedPosts to fetch.
     */
    where: reportedPostsWhereUniqueInput
  }


  /**
   * reportedPosts findUniqueOrThrow
   */
  export type reportedPostsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedPosts
     */
    select?: reportedPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedPostsInclude<ExtArgs> | null
    /**
     * Filter, which reportedPosts to fetch.
     */
    where: reportedPostsWhereUniqueInput
  }


  /**
   * reportedPosts findFirst
   */
  export type reportedPostsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedPosts
     */
    select?: reportedPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedPostsInclude<ExtArgs> | null
    /**
     * Filter, which reportedPosts to fetch.
     */
    where?: reportedPostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportedPosts to fetch.
     */
    orderBy?: reportedPostsOrderByWithRelationInput | reportedPostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reportedPosts.
     */
    cursor?: reportedPostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportedPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportedPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reportedPosts.
     */
    distinct?: ReportedPostsScalarFieldEnum | ReportedPostsScalarFieldEnum[]
  }


  /**
   * reportedPosts findFirstOrThrow
   */
  export type reportedPostsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedPosts
     */
    select?: reportedPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedPostsInclude<ExtArgs> | null
    /**
     * Filter, which reportedPosts to fetch.
     */
    where?: reportedPostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportedPosts to fetch.
     */
    orderBy?: reportedPostsOrderByWithRelationInput | reportedPostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reportedPosts.
     */
    cursor?: reportedPostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportedPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportedPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reportedPosts.
     */
    distinct?: ReportedPostsScalarFieldEnum | ReportedPostsScalarFieldEnum[]
  }


  /**
   * reportedPosts findMany
   */
  export type reportedPostsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedPosts
     */
    select?: reportedPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedPostsInclude<ExtArgs> | null
    /**
     * Filter, which reportedPosts to fetch.
     */
    where?: reportedPostsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportedPosts to fetch.
     */
    orderBy?: reportedPostsOrderByWithRelationInput | reportedPostsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reportedPosts.
     */
    cursor?: reportedPostsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportedPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportedPosts.
     */
    skip?: number
    distinct?: ReportedPostsScalarFieldEnum | ReportedPostsScalarFieldEnum[]
  }


  /**
   * reportedPosts create
   */
  export type reportedPostsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedPosts
     */
    select?: reportedPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedPostsInclude<ExtArgs> | null
    /**
     * The data needed to create a reportedPosts.
     */
    data: XOR<reportedPostsCreateInput, reportedPostsUncheckedCreateInput>
  }


  /**
   * reportedPosts createMany
   */
  export type reportedPostsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reportedPosts.
     */
    data: reportedPostsCreateManyInput | reportedPostsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * reportedPosts update
   */
  export type reportedPostsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedPosts
     */
    select?: reportedPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedPostsInclude<ExtArgs> | null
    /**
     * The data needed to update a reportedPosts.
     */
    data: XOR<reportedPostsUpdateInput, reportedPostsUncheckedUpdateInput>
    /**
     * Choose, which reportedPosts to update.
     */
    where: reportedPostsWhereUniqueInput
  }


  /**
   * reportedPosts updateMany
   */
  export type reportedPostsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reportedPosts.
     */
    data: XOR<reportedPostsUpdateManyMutationInput, reportedPostsUncheckedUpdateManyInput>
    /**
     * Filter which reportedPosts to update
     */
    where?: reportedPostsWhereInput
  }


  /**
   * reportedPosts upsert
   */
  export type reportedPostsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedPosts
     */
    select?: reportedPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedPostsInclude<ExtArgs> | null
    /**
     * The filter to search for the reportedPosts to update in case it exists.
     */
    where: reportedPostsWhereUniqueInput
    /**
     * In case the reportedPosts found by the `where` argument doesn't exist, create a new reportedPosts with this data.
     */
    create: XOR<reportedPostsCreateInput, reportedPostsUncheckedCreateInput>
    /**
     * In case the reportedPosts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reportedPostsUpdateInput, reportedPostsUncheckedUpdateInput>
  }


  /**
   * reportedPosts delete
   */
  export type reportedPostsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedPosts
     */
    select?: reportedPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedPostsInclude<ExtArgs> | null
    /**
     * Filter which reportedPosts to delete.
     */
    where: reportedPostsWhereUniqueInput
  }


  /**
   * reportedPosts deleteMany
   */
  export type reportedPostsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reportedPosts to delete
     */
    where?: reportedPostsWhereInput
  }


  /**
   * reportedPosts.users
   */
  export type reportedPosts$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }


  /**
   * reportedPosts without action
   */
  export type reportedPostsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedPosts
     */
    select?: reportedPostsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedPostsInclude<ExtArgs> | null
  }



  /**
   * Model recommendComments
   */

  export type AggregateRecommendComments = {
    _count: RecommendCommentsCountAggregateOutputType | null
    _avg: RecommendCommentsAvgAggregateOutputType | null
    _sum: RecommendCommentsSumAggregateOutputType | null
    _min: RecommendCommentsMinAggregateOutputType | null
    _max: RecommendCommentsMaxAggregateOutputType | null
  }

  export type RecommendCommentsAvgAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
  }

  export type RecommendCommentsSumAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
  }

  export type RecommendCommentsMinAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
    createdDate: Date | null
  }

  export type RecommendCommentsMaxAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
    createdDate: Date | null
  }

  export type RecommendCommentsCountAggregateOutputType = {
    id: number
    commentId: number
    userId: number
    createdDate: number
    _all: number
  }


  export type RecommendCommentsAvgAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
  }

  export type RecommendCommentsSumAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
  }

  export type RecommendCommentsMinAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    createdDate?: true
  }

  export type RecommendCommentsMaxAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    createdDate?: true
  }

  export type RecommendCommentsCountAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    createdDate?: true
    _all?: true
  }

  export type RecommendCommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recommendComments to aggregate.
     */
    where?: recommendCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recommendComments to fetch.
     */
    orderBy?: recommendCommentsOrderByWithRelationInput | recommendCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recommendCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recommendComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recommendComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recommendComments
    **/
    _count?: true | RecommendCommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecommendCommentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecommendCommentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecommendCommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecommendCommentsMaxAggregateInputType
  }

  export type GetRecommendCommentsAggregateType<T extends RecommendCommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateRecommendComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecommendComments[P]>
      : GetScalarType<T[P], AggregateRecommendComments[P]>
  }




  export type recommendCommentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recommendCommentsWhereInput
    orderBy?: recommendCommentsOrderByWithAggregationInput | recommendCommentsOrderByWithAggregationInput[]
    by: RecommendCommentsScalarFieldEnum[] | RecommendCommentsScalarFieldEnum
    having?: recommendCommentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecommendCommentsCountAggregateInputType | true
    _avg?: RecommendCommentsAvgAggregateInputType
    _sum?: RecommendCommentsSumAggregateInputType
    _min?: RecommendCommentsMinAggregateInputType
    _max?: RecommendCommentsMaxAggregateInputType
  }

  export type RecommendCommentsGroupByOutputType = {
    id: number
    commentId: number
    userId: number
    createdDate: Date
    _count: RecommendCommentsCountAggregateOutputType | null
    _avg: RecommendCommentsAvgAggregateOutputType | null
    _sum: RecommendCommentsSumAggregateOutputType | null
    _min: RecommendCommentsMinAggregateOutputType | null
    _max: RecommendCommentsMaxAggregateOutputType | null
  }

  type GetRecommendCommentsGroupByPayload<T extends recommendCommentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecommendCommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecommendCommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecommendCommentsGroupByOutputType[P]>
            : GetScalarType<T[P], RecommendCommentsGroupByOutputType[P]>
        }
      >
    >


  export type recommendCommentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    userId?: boolean
    createdDate?: boolean
    comment?: boolean | commentsDefaultArgs<ExtArgs>
    users?: boolean | recommendComments$usersArgs<ExtArgs>
  }, ExtArgs["result"]["recommendComments"]>

  export type recommendCommentsSelectScalar = {
    id?: boolean
    commentId?: boolean
    userId?: boolean
    createdDate?: boolean
  }

  export type recommendCommentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | commentsDefaultArgs<ExtArgs>
    users?: boolean | recommendComments$usersArgs<ExtArgs>
  }


  export type $recommendCommentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "recommendComments"
    objects: {
      comment: Prisma.$commentsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      commentId: number
      userId: number
      createdDate: Date
    }, ExtArgs["result"]["recommendComments"]>
    composites: {}
  }


  type recommendCommentsGetPayload<S extends boolean | null | undefined | recommendCommentsDefaultArgs> = $Result.GetResult<Prisma.$recommendCommentsPayload, S>

  type recommendCommentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<recommendCommentsFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RecommendCommentsCountAggregateInputType | true
    }

  export interface recommendCommentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['recommendComments'], meta: { name: 'recommendComments' } }
    /**
     * Find zero or one RecommendComments that matches the filter.
     * @param {recommendCommentsFindUniqueArgs} args - Arguments to find a RecommendComments
     * @example
     * // Get one RecommendComments
     * const recommendComments = await prisma.recommendComments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends recommendCommentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, recommendCommentsFindUniqueArgs<ExtArgs>>
    ): Prisma__recommendCommentsClient<$Result.GetResult<Prisma.$recommendCommentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one RecommendComments that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {recommendCommentsFindUniqueOrThrowArgs} args - Arguments to find a RecommendComments
     * @example
     * // Get one RecommendComments
     * const recommendComments = await prisma.recommendComments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends recommendCommentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, recommendCommentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__recommendCommentsClient<$Result.GetResult<Prisma.$recommendCommentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first RecommendComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommendCommentsFindFirstArgs} args - Arguments to find a RecommendComments
     * @example
     * // Get one RecommendComments
     * const recommendComments = await prisma.recommendComments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends recommendCommentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, recommendCommentsFindFirstArgs<ExtArgs>>
    ): Prisma__recommendCommentsClient<$Result.GetResult<Prisma.$recommendCommentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first RecommendComments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommendCommentsFindFirstOrThrowArgs} args - Arguments to find a RecommendComments
     * @example
     * // Get one RecommendComments
     * const recommendComments = await prisma.recommendComments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends recommendCommentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, recommendCommentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__recommendCommentsClient<$Result.GetResult<Prisma.$recommendCommentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more RecommendComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommendCommentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RecommendComments
     * const recommendComments = await prisma.recommendComments.findMany()
     * 
     * // Get first 10 RecommendComments
     * const recommendComments = await prisma.recommendComments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recommendCommentsWithIdOnly = await prisma.recommendComments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends recommendCommentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, recommendCommentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recommendCommentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a RecommendComments.
     * @param {recommendCommentsCreateArgs} args - Arguments to create a RecommendComments.
     * @example
     * // Create one RecommendComments
     * const RecommendComments = await prisma.recommendComments.create({
     *   data: {
     *     // ... data to create a RecommendComments
     *   }
     * })
     * 
    **/
    create<T extends recommendCommentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, recommendCommentsCreateArgs<ExtArgs>>
    ): Prisma__recommendCommentsClient<$Result.GetResult<Prisma.$recommendCommentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many RecommendComments.
     *     @param {recommendCommentsCreateManyArgs} args - Arguments to create many RecommendComments.
     *     @example
     *     // Create many RecommendComments
     *     const recommendComments = await prisma.recommendComments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends recommendCommentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, recommendCommentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RecommendComments.
     * @param {recommendCommentsDeleteArgs} args - Arguments to delete one RecommendComments.
     * @example
     * // Delete one RecommendComments
     * const RecommendComments = await prisma.recommendComments.delete({
     *   where: {
     *     // ... filter to delete one RecommendComments
     *   }
     * })
     * 
    **/
    delete<T extends recommendCommentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, recommendCommentsDeleteArgs<ExtArgs>>
    ): Prisma__recommendCommentsClient<$Result.GetResult<Prisma.$recommendCommentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one RecommendComments.
     * @param {recommendCommentsUpdateArgs} args - Arguments to update one RecommendComments.
     * @example
     * // Update one RecommendComments
     * const recommendComments = await prisma.recommendComments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends recommendCommentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, recommendCommentsUpdateArgs<ExtArgs>>
    ): Prisma__recommendCommentsClient<$Result.GetResult<Prisma.$recommendCommentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more RecommendComments.
     * @param {recommendCommentsDeleteManyArgs} args - Arguments to filter RecommendComments to delete.
     * @example
     * // Delete a few RecommendComments
     * const { count } = await prisma.recommendComments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends recommendCommentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, recommendCommentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RecommendComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommendCommentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RecommendComments
     * const recommendComments = await prisma.recommendComments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends recommendCommentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, recommendCommentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RecommendComments.
     * @param {recommendCommentsUpsertArgs} args - Arguments to update or create a RecommendComments.
     * @example
     * // Update or create a RecommendComments
     * const recommendComments = await prisma.recommendComments.upsert({
     *   create: {
     *     // ... data to create a RecommendComments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RecommendComments we want to update
     *   }
     * })
    **/
    upsert<T extends recommendCommentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, recommendCommentsUpsertArgs<ExtArgs>>
    ): Prisma__recommendCommentsClient<$Result.GetResult<Prisma.$recommendCommentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of RecommendComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommendCommentsCountArgs} args - Arguments to filter RecommendComments to count.
     * @example
     * // Count the number of RecommendComments
     * const count = await prisma.recommendComments.count({
     *   where: {
     *     // ... the filter for the RecommendComments we want to count
     *   }
     * })
    **/
    count<T extends recommendCommentsCountArgs>(
      args?: Subset<T, recommendCommentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecommendCommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RecommendComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecommendCommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecommendCommentsAggregateArgs>(args: Subset<T, RecommendCommentsAggregateArgs>): Prisma.PrismaPromise<GetRecommendCommentsAggregateType<T>>

    /**
     * Group by RecommendComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recommendCommentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends recommendCommentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: recommendCommentsGroupByArgs['orderBy'] }
        : { orderBy?: recommendCommentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, recommendCommentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecommendCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the recommendComments model
   */
  readonly fields: recommendCommentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for recommendComments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__recommendCommentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    comment<T extends commentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, commentsDefaultArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    users<T extends recommendComments$usersArgs<ExtArgs> = {}>(args?: Subset<T, recommendComments$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the recommendComments model
   */ 
  interface recommendCommentsFieldRefs {
    readonly id: FieldRef<"recommendComments", 'Int'>
    readonly commentId: FieldRef<"recommendComments", 'Int'>
    readonly userId: FieldRef<"recommendComments", 'Int'>
    readonly createdDate: FieldRef<"recommendComments", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * recommendComments findUnique
   */
  export type recommendCommentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendComments
     */
    select?: recommendCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendCommentsInclude<ExtArgs> | null
    /**
     * Filter, which recommendComments to fetch.
     */
    where: recommendCommentsWhereUniqueInput
  }


  /**
   * recommendComments findUniqueOrThrow
   */
  export type recommendCommentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendComments
     */
    select?: recommendCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendCommentsInclude<ExtArgs> | null
    /**
     * Filter, which recommendComments to fetch.
     */
    where: recommendCommentsWhereUniqueInput
  }


  /**
   * recommendComments findFirst
   */
  export type recommendCommentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendComments
     */
    select?: recommendCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendCommentsInclude<ExtArgs> | null
    /**
     * Filter, which recommendComments to fetch.
     */
    where?: recommendCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recommendComments to fetch.
     */
    orderBy?: recommendCommentsOrderByWithRelationInput | recommendCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recommendComments.
     */
    cursor?: recommendCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recommendComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recommendComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recommendComments.
     */
    distinct?: RecommendCommentsScalarFieldEnum | RecommendCommentsScalarFieldEnum[]
  }


  /**
   * recommendComments findFirstOrThrow
   */
  export type recommendCommentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendComments
     */
    select?: recommendCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendCommentsInclude<ExtArgs> | null
    /**
     * Filter, which recommendComments to fetch.
     */
    where?: recommendCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recommendComments to fetch.
     */
    orderBy?: recommendCommentsOrderByWithRelationInput | recommendCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recommendComments.
     */
    cursor?: recommendCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recommendComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recommendComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recommendComments.
     */
    distinct?: RecommendCommentsScalarFieldEnum | RecommendCommentsScalarFieldEnum[]
  }


  /**
   * recommendComments findMany
   */
  export type recommendCommentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendComments
     */
    select?: recommendCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendCommentsInclude<ExtArgs> | null
    /**
     * Filter, which recommendComments to fetch.
     */
    where?: recommendCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recommendComments to fetch.
     */
    orderBy?: recommendCommentsOrderByWithRelationInput | recommendCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recommendComments.
     */
    cursor?: recommendCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recommendComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recommendComments.
     */
    skip?: number
    distinct?: RecommendCommentsScalarFieldEnum | RecommendCommentsScalarFieldEnum[]
  }


  /**
   * recommendComments create
   */
  export type recommendCommentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendComments
     */
    select?: recommendCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendCommentsInclude<ExtArgs> | null
    /**
     * The data needed to create a recommendComments.
     */
    data: XOR<recommendCommentsCreateInput, recommendCommentsUncheckedCreateInput>
  }


  /**
   * recommendComments createMany
   */
  export type recommendCommentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many recommendComments.
     */
    data: recommendCommentsCreateManyInput | recommendCommentsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * recommendComments update
   */
  export type recommendCommentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendComments
     */
    select?: recommendCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendCommentsInclude<ExtArgs> | null
    /**
     * The data needed to update a recommendComments.
     */
    data: XOR<recommendCommentsUpdateInput, recommendCommentsUncheckedUpdateInput>
    /**
     * Choose, which recommendComments to update.
     */
    where: recommendCommentsWhereUniqueInput
  }


  /**
   * recommendComments updateMany
   */
  export type recommendCommentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update recommendComments.
     */
    data: XOR<recommendCommentsUpdateManyMutationInput, recommendCommentsUncheckedUpdateManyInput>
    /**
     * Filter which recommendComments to update
     */
    where?: recommendCommentsWhereInput
  }


  /**
   * recommendComments upsert
   */
  export type recommendCommentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendComments
     */
    select?: recommendCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendCommentsInclude<ExtArgs> | null
    /**
     * The filter to search for the recommendComments to update in case it exists.
     */
    where: recommendCommentsWhereUniqueInput
    /**
     * In case the recommendComments found by the `where` argument doesn't exist, create a new recommendComments with this data.
     */
    create: XOR<recommendCommentsCreateInput, recommendCommentsUncheckedCreateInput>
    /**
     * In case the recommendComments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recommendCommentsUpdateInput, recommendCommentsUncheckedUpdateInput>
  }


  /**
   * recommendComments delete
   */
  export type recommendCommentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendComments
     */
    select?: recommendCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendCommentsInclude<ExtArgs> | null
    /**
     * Filter which recommendComments to delete.
     */
    where: recommendCommentsWhereUniqueInput
  }


  /**
   * recommendComments deleteMany
   */
  export type recommendCommentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recommendComments to delete
     */
    where?: recommendCommentsWhereInput
  }


  /**
   * recommendComments.users
   */
  export type recommendComments$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }


  /**
   * recommendComments without action
   */
  export type recommendCommentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recommendComments
     */
    select?: recommendCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: recommendCommentsInclude<ExtArgs> | null
  }



  /**
   * Model reportedComments
   */

  export type AggregateReportedComments = {
    _count: ReportedCommentsCountAggregateOutputType | null
    _avg: ReportedCommentsAvgAggregateOutputType | null
    _sum: ReportedCommentsSumAggregateOutputType | null
    _min: ReportedCommentsMinAggregateOutputType | null
    _max: ReportedCommentsMaxAggregateOutputType | null
  }

  export type ReportedCommentsAvgAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
  }

  export type ReportedCommentsSumAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
  }

  export type ReportedCommentsMinAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
    reason: string | null
    createdDate: Date | null
  }

  export type ReportedCommentsMaxAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
    reason: string | null
    createdDate: Date | null
  }

  export type ReportedCommentsCountAggregateOutputType = {
    id: number
    commentId: number
    userId: number
    reason: number
    createdDate: number
    _all: number
  }


  export type ReportedCommentsAvgAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
  }

  export type ReportedCommentsSumAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
  }

  export type ReportedCommentsMinAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    reason?: true
    createdDate?: true
  }

  export type ReportedCommentsMaxAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    reason?: true
    createdDate?: true
  }

  export type ReportedCommentsCountAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    reason?: true
    createdDate?: true
    _all?: true
  }

  export type ReportedCommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reportedComments to aggregate.
     */
    where?: reportedCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportedComments to fetch.
     */
    orderBy?: reportedCommentsOrderByWithRelationInput | reportedCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reportedCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportedComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportedComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reportedComments
    **/
    _count?: true | ReportedCommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportedCommentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportedCommentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportedCommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportedCommentsMaxAggregateInputType
  }

  export type GetReportedCommentsAggregateType<T extends ReportedCommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateReportedComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportedComments[P]>
      : GetScalarType<T[P], AggregateReportedComments[P]>
  }




  export type reportedCommentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportedCommentsWhereInput
    orderBy?: reportedCommentsOrderByWithAggregationInput | reportedCommentsOrderByWithAggregationInput[]
    by: ReportedCommentsScalarFieldEnum[] | ReportedCommentsScalarFieldEnum
    having?: reportedCommentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportedCommentsCountAggregateInputType | true
    _avg?: ReportedCommentsAvgAggregateInputType
    _sum?: ReportedCommentsSumAggregateInputType
    _min?: ReportedCommentsMinAggregateInputType
    _max?: ReportedCommentsMaxAggregateInputType
  }

  export type ReportedCommentsGroupByOutputType = {
    id: number
    commentId: number
    userId: number
    reason: string
    createdDate: Date
    _count: ReportedCommentsCountAggregateOutputType | null
    _avg: ReportedCommentsAvgAggregateOutputType | null
    _sum: ReportedCommentsSumAggregateOutputType | null
    _min: ReportedCommentsMinAggregateOutputType | null
    _max: ReportedCommentsMaxAggregateOutputType | null
  }

  type GetReportedCommentsGroupByPayload<T extends reportedCommentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportedCommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportedCommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportedCommentsGroupByOutputType[P]>
            : GetScalarType<T[P], ReportedCommentsGroupByOutputType[P]>
        }
      >
    >


  export type reportedCommentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    userId?: boolean
    reason?: boolean
    createdDate?: boolean
    comment?: boolean | commentsDefaultArgs<ExtArgs>
    users?: boolean | reportedComments$usersArgs<ExtArgs>
  }, ExtArgs["result"]["reportedComments"]>

  export type reportedCommentsSelectScalar = {
    id?: boolean
    commentId?: boolean
    userId?: boolean
    reason?: boolean
    createdDate?: boolean
  }

  export type reportedCommentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | commentsDefaultArgs<ExtArgs>
    users?: boolean | reportedComments$usersArgs<ExtArgs>
  }


  export type $reportedCommentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reportedComments"
    objects: {
      comment: Prisma.$commentsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      commentId: number
      userId: number
      reason: string
      createdDate: Date
    }, ExtArgs["result"]["reportedComments"]>
    composites: {}
  }


  type reportedCommentsGetPayload<S extends boolean | null | undefined | reportedCommentsDefaultArgs> = $Result.GetResult<Prisma.$reportedCommentsPayload, S>

  type reportedCommentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<reportedCommentsFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ReportedCommentsCountAggregateInputType | true
    }

  export interface reportedCommentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reportedComments'], meta: { name: 'reportedComments' } }
    /**
     * Find zero or one ReportedComments that matches the filter.
     * @param {reportedCommentsFindUniqueArgs} args - Arguments to find a ReportedComments
     * @example
     * // Get one ReportedComments
     * const reportedComments = await prisma.reportedComments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reportedCommentsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, reportedCommentsFindUniqueArgs<ExtArgs>>
    ): Prisma__reportedCommentsClient<$Result.GetResult<Prisma.$reportedCommentsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ReportedComments that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reportedCommentsFindUniqueOrThrowArgs} args - Arguments to find a ReportedComments
     * @example
     * // Get one ReportedComments
     * const reportedComments = await prisma.reportedComments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reportedCommentsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedCommentsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__reportedCommentsClient<$Result.GetResult<Prisma.$reportedCommentsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ReportedComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedCommentsFindFirstArgs} args - Arguments to find a ReportedComments
     * @example
     * // Get one ReportedComments
     * const reportedComments = await prisma.reportedComments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reportedCommentsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedCommentsFindFirstArgs<ExtArgs>>
    ): Prisma__reportedCommentsClient<$Result.GetResult<Prisma.$reportedCommentsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ReportedComments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedCommentsFindFirstOrThrowArgs} args - Arguments to find a ReportedComments
     * @example
     * // Get one ReportedComments
     * const reportedComments = await prisma.reportedComments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reportedCommentsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedCommentsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__reportedCommentsClient<$Result.GetResult<Prisma.$reportedCommentsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ReportedComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedCommentsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportedComments
     * const reportedComments = await prisma.reportedComments.findMany()
     * 
     * // Get first 10 ReportedComments
     * const reportedComments = await prisma.reportedComments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportedCommentsWithIdOnly = await prisma.reportedComments.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends reportedCommentsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedCommentsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportedCommentsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ReportedComments.
     * @param {reportedCommentsCreateArgs} args - Arguments to create a ReportedComments.
     * @example
     * // Create one ReportedComments
     * const ReportedComments = await prisma.reportedComments.create({
     *   data: {
     *     // ... data to create a ReportedComments
     *   }
     * })
     * 
    **/
    create<T extends reportedCommentsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, reportedCommentsCreateArgs<ExtArgs>>
    ): Prisma__reportedCommentsClient<$Result.GetResult<Prisma.$reportedCommentsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ReportedComments.
     *     @param {reportedCommentsCreateManyArgs} args - Arguments to create many ReportedComments.
     *     @example
     *     // Create many ReportedComments
     *     const reportedComments = await prisma.reportedComments.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reportedCommentsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedCommentsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReportedComments.
     * @param {reportedCommentsDeleteArgs} args - Arguments to delete one ReportedComments.
     * @example
     * // Delete one ReportedComments
     * const ReportedComments = await prisma.reportedComments.delete({
     *   where: {
     *     // ... filter to delete one ReportedComments
     *   }
     * })
     * 
    **/
    delete<T extends reportedCommentsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, reportedCommentsDeleteArgs<ExtArgs>>
    ): Prisma__reportedCommentsClient<$Result.GetResult<Prisma.$reportedCommentsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ReportedComments.
     * @param {reportedCommentsUpdateArgs} args - Arguments to update one ReportedComments.
     * @example
     * // Update one ReportedComments
     * const reportedComments = await prisma.reportedComments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reportedCommentsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, reportedCommentsUpdateArgs<ExtArgs>>
    ): Prisma__reportedCommentsClient<$Result.GetResult<Prisma.$reportedCommentsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ReportedComments.
     * @param {reportedCommentsDeleteManyArgs} args - Arguments to filter ReportedComments to delete.
     * @example
     * // Delete a few ReportedComments
     * const { count } = await prisma.reportedComments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reportedCommentsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedCommentsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportedComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedCommentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportedComments
     * const reportedComments = await prisma.reportedComments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reportedCommentsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, reportedCommentsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportedComments.
     * @param {reportedCommentsUpsertArgs} args - Arguments to update or create a ReportedComments.
     * @example
     * // Update or create a ReportedComments
     * const reportedComments = await prisma.reportedComments.upsert({
     *   create: {
     *     // ... data to create a ReportedComments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportedComments we want to update
     *   }
     * })
    **/
    upsert<T extends reportedCommentsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, reportedCommentsUpsertArgs<ExtArgs>>
    ): Prisma__reportedCommentsClient<$Result.GetResult<Prisma.$reportedCommentsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ReportedComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedCommentsCountArgs} args - Arguments to filter ReportedComments to count.
     * @example
     * // Count the number of ReportedComments
     * const count = await prisma.reportedComments.count({
     *   where: {
     *     // ... the filter for the ReportedComments we want to count
     *   }
     * })
    **/
    count<T extends reportedCommentsCountArgs>(
      args?: Subset<T, reportedCommentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportedCommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportedComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportedCommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportedCommentsAggregateArgs>(args: Subset<T, ReportedCommentsAggregateArgs>): Prisma.PrismaPromise<GetReportedCommentsAggregateType<T>>

    /**
     * Group by ReportedComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedCommentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reportedCommentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reportedCommentsGroupByArgs['orderBy'] }
        : { orderBy?: reportedCommentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reportedCommentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportedCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reportedComments model
   */
  readonly fields: reportedCommentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reportedComments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reportedCommentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    comment<T extends commentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, commentsDefaultArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    users<T extends reportedComments$usersArgs<ExtArgs> = {}>(args?: Subset<T, reportedComments$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the reportedComments model
   */ 
  interface reportedCommentsFieldRefs {
    readonly id: FieldRef<"reportedComments", 'Int'>
    readonly commentId: FieldRef<"reportedComments", 'Int'>
    readonly userId: FieldRef<"reportedComments", 'Int'>
    readonly reason: FieldRef<"reportedComments", 'String'>
    readonly createdDate: FieldRef<"reportedComments", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * reportedComments findUnique
   */
  export type reportedCommentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedComments
     */
    select?: reportedCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedCommentsInclude<ExtArgs> | null
    /**
     * Filter, which reportedComments to fetch.
     */
    where: reportedCommentsWhereUniqueInput
  }


  /**
   * reportedComments findUniqueOrThrow
   */
  export type reportedCommentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedComments
     */
    select?: reportedCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedCommentsInclude<ExtArgs> | null
    /**
     * Filter, which reportedComments to fetch.
     */
    where: reportedCommentsWhereUniqueInput
  }


  /**
   * reportedComments findFirst
   */
  export type reportedCommentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedComments
     */
    select?: reportedCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedCommentsInclude<ExtArgs> | null
    /**
     * Filter, which reportedComments to fetch.
     */
    where?: reportedCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportedComments to fetch.
     */
    orderBy?: reportedCommentsOrderByWithRelationInput | reportedCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reportedComments.
     */
    cursor?: reportedCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportedComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportedComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reportedComments.
     */
    distinct?: ReportedCommentsScalarFieldEnum | ReportedCommentsScalarFieldEnum[]
  }


  /**
   * reportedComments findFirstOrThrow
   */
  export type reportedCommentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedComments
     */
    select?: reportedCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedCommentsInclude<ExtArgs> | null
    /**
     * Filter, which reportedComments to fetch.
     */
    where?: reportedCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportedComments to fetch.
     */
    orderBy?: reportedCommentsOrderByWithRelationInput | reportedCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reportedComments.
     */
    cursor?: reportedCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportedComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportedComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reportedComments.
     */
    distinct?: ReportedCommentsScalarFieldEnum | ReportedCommentsScalarFieldEnum[]
  }


  /**
   * reportedComments findMany
   */
  export type reportedCommentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedComments
     */
    select?: reportedCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedCommentsInclude<ExtArgs> | null
    /**
     * Filter, which reportedComments to fetch.
     */
    where?: reportedCommentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportedComments to fetch.
     */
    orderBy?: reportedCommentsOrderByWithRelationInput | reportedCommentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reportedComments.
     */
    cursor?: reportedCommentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportedComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportedComments.
     */
    skip?: number
    distinct?: ReportedCommentsScalarFieldEnum | ReportedCommentsScalarFieldEnum[]
  }


  /**
   * reportedComments create
   */
  export type reportedCommentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedComments
     */
    select?: reportedCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedCommentsInclude<ExtArgs> | null
    /**
     * The data needed to create a reportedComments.
     */
    data: XOR<reportedCommentsCreateInput, reportedCommentsUncheckedCreateInput>
  }


  /**
   * reportedComments createMany
   */
  export type reportedCommentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reportedComments.
     */
    data: reportedCommentsCreateManyInput | reportedCommentsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * reportedComments update
   */
  export type reportedCommentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedComments
     */
    select?: reportedCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedCommentsInclude<ExtArgs> | null
    /**
     * The data needed to update a reportedComments.
     */
    data: XOR<reportedCommentsUpdateInput, reportedCommentsUncheckedUpdateInput>
    /**
     * Choose, which reportedComments to update.
     */
    where: reportedCommentsWhereUniqueInput
  }


  /**
   * reportedComments updateMany
   */
  export type reportedCommentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reportedComments.
     */
    data: XOR<reportedCommentsUpdateManyMutationInput, reportedCommentsUncheckedUpdateManyInput>
    /**
     * Filter which reportedComments to update
     */
    where?: reportedCommentsWhereInput
  }


  /**
   * reportedComments upsert
   */
  export type reportedCommentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedComments
     */
    select?: reportedCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedCommentsInclude<ExtArgs> | null
    /**
     * The filter to search for the reportedComments to update in case it exists.
     */
    where: reportedCommentsWhereUniqueInput
    /**
     * In case the reportedComments found by the `where` argument doesn't exist, create a new reportedComments with this data.
     */
    create: XOR<reportedCommentsCreateInput, reportedCommentsUncheckedCreateInput>
    /**
     * In case the reportedComments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reportedCommentsUpdateInput, reportedCommentsUncheckedUpdateInput>
  }


  /**
   * reportedComments delete
   */
  export type reportedCommentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedComments
     */
    select?: reportedCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedCommentsInclude<ExtArgs> | null
    /**
     * Filter which reportedComments to delete.
     */
    where: reportedCommentsWhereUniqueInput
  }


  /**
   * reportedComments deleteMany
   */
  export type reportedCommentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reportedComments to delete
     */
    where?: reportedCommentsWhereInput
  }


  /**
   * reportedComments.users
   */
  export type reportedComments$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }


  /**
   * reportedComments without action
   */
  export type reportedCommentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedComments
     */
    select?: reportedCommentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedCommentsInclude<ExtArgs> | null
  }



  /**
   * Model reportedUsers
   */

  export type AggregateReportedUsers = {
    _count: ReportedUsersCountAggregateOutputType | null
    _avg: ReportedUsersAvgAggregateOutputType | null
    _sum: ReportedUsersSumAggregateOutputType | null
    _min: ReportedUsersMinAggregateOutputType | null
    _max: ReportedUsersMaxAggregateOutputType | null
  }

  export type ReportedUsersAvgAggregateOutputType = {
    id: number | null
    targetUserId: number | null
    reportingUserId: number | null
  }

  export type ReportedUsersSumAggregateOutputType = {
    id: number | null
    targetUserId: number | null
    reportingUserId: number | null
  }

  export type ReportedUsersMinAggregateOutputType = {
    id: number | null
    targetUserId: number | null
    reportingUserId: number | null
    reason: string | null
    createdDate: Date | null
  }

  export type ReportedUsersMaxAggregateOutputType = {
    id: number | null
    targetUserId: number | null
    reportingUserId: number | null
    reason: string | null
    createdDate: Date | null
  }

  export type ReportedUsersCountAggregateOutputType = {
    id: number
    targetUserId: number
    reportingUserId: number
    reason: number
    createdDate: number
    _all: number
  }


  export type ReportedUsersAvgAggregateInputType = {
    id?: true
    targetUserId?: true
    reportingUserId?: true
  }

  export type ReportedUsersSumAggregateInputType = {
    id?: true
    targetUserId?: true
    reportingUserId?: true
  }

  export type ReportedUsersMinAggregateInputType = {
    id?: true
    targetUserId?: true
    reportingUserId?: true
    reason?: true
    createdDate?: true
  }

  export type ReportedUsersMaxAggregateInputType = {
    id?: true
    targetUserId?: true
    reportingUserId?: true
    reason?: true
    createdDate?: true
  }

  export type ReportedUsersCountAggregateInputType = {
    id?: true
    targetUserId?: true
    reportingUserId?: true
    reason?: true
    createdDate?: true
    _all?: true
  }

  export type ReportedUsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reportedUsers to aggregate.
     */
    where?: reportedUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportedUsers to fetch.
     */
    orderBy?: reportedUsersOrderByWithRelationInput | reportedUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reportedUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reportedUsers
    **/
    _count?: true | ReportedUsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportedUsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportedUsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportedUsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportedUsersMaxAggregateInputType
  }

  export type GetReportedUsersAggregateType<T extends ReportedUsersAggregateArgs> = {
        [P in keyof T & keyof AggregateReportedUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportedUsers[P]>
      : GetScalarType<T[P], AggregateReportedUsers[P]>
  }




  export type reportedUsersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reportedUsersWhereInput
    orderBy?: reportedUsersOrderByWithAggregationInput | reportedUsersOrderByWithAggregationInput[]
    by: ReportedUsersScalarFieldEnum[] | ReportedUsersScalarFieldEnum
    having?: reportedUsersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportedUsersCountAggregateInputType | true
    _avg?: ReportedUsersAvgAggregateInputType
    _sum?: ReportedUsersSumAggregateInputType
    _min?: ReportedUsersMinAggregateInputType
    _max?: ReportedUsersMaxAggregateInputType
  }

  export type ReportedUsersGroupByOutputType = {
    id: number
    targetUserId: number
    reportingUserId: number
    reason: string
    createdDate: Date
    _count: ReportedUsersCountAggregateOutputType | null
    _avg: ReportedUsersAvgAggregateOutputType | null
    _sum: ReportedUsersSumAggregateOutputType | null
    _min: ReportedUsersMinAggregateOutputType | null
    _max: ReportedUsersMaxAggregateOutputType | null
  }

  type GetReportedUsersGroupByPayload<T extends reportedUsersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportedUsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportedUsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportedUsersGroupByOutputType[P]>
            : GetScalarType<T[P], ReportedUsersGroupByOutputType[P]>
        }
      >
    >


  export type reportedUsersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetUserId?: boolean
    reportingUserId?: boolean
    reason?: boolean
    createdDate?: boolean
    users?: boolean | reportedUsers$usersArgs<ExtArgs>
  }, ExtArgs["result"]["reportedUsers"]>

  export type reportedUsersSelectScalar = {
    id?: boolean
    targetUserId?: boolean
    reportingUserId?: boolean
    reason?: boolean
    createdDate?: boolean
  }

  export type reportedUsersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | reportedUsers$usersArgs<ExtArgs>
  }


  export type $reportedUsersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reportedUsers"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      targetUserId: number
      reportingUserId: number
      reason: string
      createdDate: Date
    }, ExtArgs["result"]["reportedUsers"]>
    composites: {}
  }


  type reportedUsersGetPayload<S extends boolean | null | undefined | reportedUsersDefaultArgs> = $Result.GetResult<Prisma.$reportedUsersPayload, S>

  type reportedUsersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<reportedUsersFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ReportedUsersCountAggregateInputType | true
    }

  export interface reportedUsersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reportedUsers'], meta: { name: 'reportedUsers' } }
    /**
     * Find zero or one ReportedUsers that matches the filter.
     * @param {reportedUsersFindUniqueArgs} args - Arguments to find a ReportedUsers
     * @example
     * // Get one ReportedUsers
     * const reportedUsers = await prisma.reportedUsers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reportedUsersFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, reportedUsersFindUniqueArgs<ExtArgs>>
    ): Prisma__reportedUsersClient<$Result.GetResult<Prisma.$reportedUsersPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ReportedUsers that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reportedUsersFindUniqueOrThrowArgs} args - Arguments to find a ReportedUsers
     * @example
     * // Get one ReportedUsers
     * const reportedUsers = await prisma.reportedUsers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reportedUsersFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedUsersFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__reportedUsersClient<$Result.GetResult<Prisma.$reportedUsersPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ReportedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedUsersFindFirstArgs} args - Arguments to find a ReportedUsers
     * @example
     * // Get one ReportedUsers
     * const reportedUsers = await prisma.reportedUsers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reportedUsersFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedUsersFindFirstArgs<ExtArgs>>
    ): Prisma__reportedUsersClient<$Result.GetResult<Prisma.$reportedUsersPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ReportedUsers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedUsersFindFirstOrThrowArgs} args - Arguments to find a ReportedUsers
     * @example
     * // Get one ReportedUsers
     * const reportedUsers = await prisma.reportedUsers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reportedUsersFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedUsersFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__reportedUsersClient<$Result.GetResult<Prisma.$reportedUsersPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ReportedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedUsersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReportedUsers
     * const reportedUsers = await prisma.reportedUsers.findMany()
     * 
     * // Get first 10 ReportedUsers
     * const reportedUsers = await prisma.reportedUsers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportedUsersWithIdOnly = await prisma.reportedUsers.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends reportedUsersFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedUsersFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reportedUsersPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ReportedUsers.
     * @param {reportedUsersCreateArgs} args - Arguments to create a ReportedUsers.
     * @example
     * // Create one ReportedUsers
     * const ReportedUsers = await prisma.reportedUsers.create({
     *   data: {
     *     // ... data to create a ReportedUsers
     *   }
     * })
     * 
    **/
    create<T extends reportedUsersCreateArgs<ExtArgs>>(
      args: SelectSubset<T, reportedUsersCreateArgs<ExtArgs>>
    ): Prisma__reportedUsersClient<$Result.GetResult<Prisma.$reportedUsersPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ReportedUsers.
     *     @param {reportedUsersCreateManyArgs} args - Arguments to create many ReportedUsers.
     *     @example
     *     // Create many ReportedUsers
     *     const reportedUsers = await prisma.reportedUsers.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reportedUsersCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedUsersCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReportedUsers.
     * @param {reportedUsersDeleteArgs} args - Arguments to delete one ReportedUsers.
     * @example
     * // Delete one ReportedUsers
     * const ReportedUsers = await prisma.reportedUsers.delete({
     *   where: {
     *     // ... filter to delete one ReportedUsers
     *   }
     * })
     * 
    **/
    delete<T extends reportedUsersDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, reportedUsersDeleteArgs<ExtArgs>>
    ): Prisma__reportedUsersClient<$Result.GetResult<Prisma.$reportedUsersPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ReportedUsers.
     * @param {reportedUsersUpdateArgs} args - Arguments to update one ReportedUsers.
     * @example
     * // Update one ReportedUsers
     * const reportedUsers = await prisma.reportedUsers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reportedUsersUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, reportedUsersUpdateArgs<ExtArgs>>
    ): Prisma__reportedUsersClient<$Result.GetResult<Prisma.$reportedUsersPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ReportedUsers.
     * @param {reportedUsersDeleteManyArgs} args - Arguments to filter ReportedUsers to delete.
     * @example
     * // Delete a few ReportedUsers
     * const { count } = await prisma.reportedUsers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reportedUsersDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, reportedUsersDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReportedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedUsersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReportedUsers
     * const reportedUsers = await prisma.reportedUsers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reportedUsersUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, reportedUsersUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReportedUsers.
     * @param {reportedUsersUpsertArgs} args - Arguments to update or create a ReportedUsers.
     * @example
     * // Update or create a ReportedUsers
     * const reportedUsers = await prisma.reportedUsers.upsert({
     *   create: {
     *     // ... data to create a ReportedUsers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReportedUsers we want to update
     *   }
     * })
    **/
    upsert<T extends reportedUsersUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, reportedUsersUpsertArgs<ExtArgs>>
    ): Prisma__reportedUsersClient<$Result.GetResult<Prisma.$reportedUsersPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ReportedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedUsersCountArgs} args - Arguments to filter ReportedUsers to count.
     * @example
     * // Count the number of ReportedUsers
     * const count = await prisma.reportedUsers.count({
     *   where: {
     *     // ... the filter for the ReportedUsers we want to count
     *   }
     * })
    **/
    count<T extends reportedUsersCountArgs>(
      args?: Subset<T, reportedUsersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportedUsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReportedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportedUsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportedUsersAggregateArgs>(args: Subset<T, ReportedUsersAggregateArgs>): Prisma.PrismaPromise<GetReportedUsersAggregateType<T>>

    /**
     * Group by ReportedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportedUsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reportedUsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reportedUsersGroupByArgs['orderBy'] }
        : { orderBy?: reportedUsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reportedUsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportedUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reportedUsers model
   */
  readonly fields: reportedUsersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reportedUsers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reportedUsersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends reportedUsers$usersArgs<ExtArgs> = {}>(args?: Subset<T, reportedUsers$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the reportedUsers model
   */ 
  interface reportedUsersFieldRefs {
    readonly id: FieldRef<"reportedUsers", 'Int'>
    readonly targetUserId: FieldRef<"reportedUsers", 'Int'>
    readonly reportingUserId: FieldRef<"reportedUsers", 'Int'>
    readonly reason: FieldRef<"reportedUsers", 'String'>
    readonly createdDate: FieldRef<"reportedUsers", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * reportedUsers findUnique
   */
  export type reportedUsersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedUsers
     */
    select?: reportedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedUsersInclude<ExtArgs> | null
    /**
     * Filter, which reportedUsers to fetch.
     */
    where: reportedUsersWhereUniqueInput
  }


  /**
   * reportedUsers findUniqueOrThrow
   */
  export type reportedUsersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedUsers
     */
    select?: reportedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedUsersInclude<ExtArgs> | null
    /**
     * Filter, which reportedUsers to fetch.
     */
    where: reportedUsersWhereUniqueInput
  }


  /**
   * reportedUsers findFirst
   */
  export type reportedUsersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedUsers
     */
    select?: reportedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedUsersInclude<ExtArgs> | null
    /**
     * Filter, which reportedUsers to fetch.
     */
    where?: reportedUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportedUsers to fetch.
     */
    orderBy?: reportedUsersOrderByWithRelationInput | reportedUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reportedUsers.
     */
    cursor?: reportedUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reportedUsers.
     */
    distinct?: ReportedUsersScalarFieldEnum | ReportedUsersScalarFieldEnum[]
  }


  /**
   * reportedUsers findFirstOrThrow
   */
  export type reportedUsersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedUsers
     */
    select?: reportedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedUsersInclude<ExtArgs> | null
    /**
     * Filter, which reportedUsers to fetch.
     */
    where?: reportedUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportedUsers to fetch.
     */
    orderBy?: reportedUsersOrderByWithRelationInput | reportedUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reportedUsers.
     */
    cursor?: reportedUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reportedUsers.
     */
    distinct?: ReportedUsersScalarFieldEnum | ReportedUsersScalarFieldEnum[]
  }


  /**
   * reportedUsers findMany
   */
  export type reportedUsersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedUsers
     */
    select?: reportedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedUsersInclude<ExtArgs> | null
    /**
     * Filter, which reportedUsers to fetch.
     */
    where?: reportedUsersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reportedUsers to fetch.
     */
    orderBy?: reportedUsersOrderByWithRelationInput | reportedUsersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reportedUsers.
     */
    cursor?: reportedUsersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reportedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reportedUsers.
     */
    skip?: number
    distinct?: ReportedUsersScalarFieldEnum | ReportedUsersScalarFieldEnum[]
  }


  /**
   * reportedUsers create
   */
  export type reportedUsersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedUsers
     */
    select?: reportedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedUsersInclude<ExtArgs> | null
    /**
     * The data needed to create a reportedUsers.
     */
    data: XOR<reportedUsersCreateInput, reportedUsersUncheckedCreateInput>
  }


  /**
   * reportedUsers createMany
   */
  export type reportedUsersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reportedUsers.
     */
    data: reportedUsersCreateManyInput | reportedUsersCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * reportedUsers update
   */
  export type reportedUsersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedUsers
     */
    select?: reportedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedUsersInclude<ExtArgs> | null
    /**
     * The data needed to update a reportedUsers.
     */
    data: XOR<reportedUsersUpdateInput, reportedUsersUncheckedUpdateInput>
    /**
     * Choose, which reportedUsers to update.
     */
    where: reportedUsersWhereUniqueInput
  }


  /**
   * reportedUsers updateMany
   */
  export type reportedUsersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reportedUsers.
     */
    data: XOR<reportedUsersUpdateManyMutationInput, reportedUsersUncheckedUpdateManyInput>
    /**
     * Filter which reportedUsers to update
     */
    where?: reportedUsersWhereInput
  }


  /**
   * reportedUsers upsert
   */
  export type reportedUsersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedUsers
     */
    select?: reportedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedUsersInclude<ExtArgs> | null
    /**
     * The filter to search for the reportedUsers to update in case it exists.
     */
    where: reportedUsersWhereUniqueInput
    /**
     * In case the reportedUsers found by the `where` argument doesn't exist, create a new reportedUsers with this data.
     */
    create: XOR<reportedUsersCreateInput, reportedUsersUncheckedCreateInput>
    /**
     * In case the reportedUsers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reportedUsersUpdateInput, reportedUsersUncheckedUpdateInput>
  }


  /**
   * reportedUsers delete
   */
  export type reportedUsersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedUsers
     */
    select?: reportedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedUsersInclude<ExtArgs> | null
    /**
     * Filter which reportedUsers to delete.
     */
    where: reportedUsersWhereUniqueInput
  }


  /**
   * reportedUsers deleteMany
   */
  export type reportedUsersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reportedUsers to delete
     */
    where?: reportedUsersWhereInput
  }


  /**
   * reportedUsers.users
   */
  export type reportedUsers$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }


  /**
   * reportedUsers without action
   */
  export type reportedUsersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reportedUsers
     */
    select?: reportedUsersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportedUsersInclude<ExtArgs> | null
  }



  /**
   * Model company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    id: number | null
    longitude: number | null
    latitude: number | null
    bigJobKindId: number | null
    midJobKindId: number | null
    smallJobKindId: number | null
  }

  export type CompanySumAggregateOutputType = {
    id: number | null
    longitude: number | null
    latitude: number | null
    bigJobKindId: number | null
    midJobKindId: number | null
    smallJobKindId: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    longitude: number | null
    latitude: number | null
    scale: string | null
    bigJobKindId: number | null
    midJobKindId: number | null
    smallJobKindId: number | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    longitude: number | null
    latitude: number | null
    scale: string | null
    bigJobKindId: number | null
    midJobKindId: number | null
    smallJobKindId: number | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    address: number
    longitude: number
    latitude: number
    scale: number
    bigJobKindId: number
    midJobKindId: number
    smallJobKindId: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    id?: true
    longitude?: true
    latitude?: true
    bigJobKindId?: true
    midJobKindId?: true
    smallJobKindId?: true
  }

  export type CompanySumAggregateInputType = {
    id?: true
    longitude?: true
    latitude?: true
    bigJobKindId?: true
    midJobKindId?: true
    smallJobKindId?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    longitude?: true
    latitude?: true
    scale?: true
    bigJobKindId?: true
    midJobKindId?: true
    smallJobKindId?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    longitude?: true
    latitude?: true
    scale?: true
    bigJobKindId?: true
    midJobKindId?: true
    smallJobKindId?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    longitude?: true
    latitude?: true
    scale?: true
    bigJobKindId?: true
    midJobKindId?: true
    smallJobKindId?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company to aggregate.
     */
    where?: companyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type companyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyWhereInput
    orderBy?: companyOrderByWithAggregationInput | companyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: companyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: number
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    bigJobKindId: number
    midJobKindId: number
    smallJobKindId: number
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends companyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type companySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    longitude?: boolean
    latitude?: boolean
    scale?: boolean
    bigJobKindId?: boolean
    midJobKindId?: boolean
    smallJobKindId?: boolean
    bigJobKind?: boolean | bigJobKindDefaultArgs<ExtArgs>
    midJobKind?: boolean | midJobKindDefaultArgs<ExtArgs>
    smallJobKind?: boolean | smallJobKindDefaultArgs<ExtArgs>
    incumebent?: boolean | company$incumebentArgs<ExtArgs>
    student?: boolean | company$studentArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type companySelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    longitude?: boolean
    latitude?: boolean
    scale?: boolean
    bigJobKindId?: boolean
    midJobKindId?: boolean
    smallJobKindId?: boolean
  }

  export type companyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bigJobKind?: boolean | bigJobKindDefaultArgs<ExtArgs>
    midJobKind?: boolean | midJobKindDefaultArgs<ExtArgs>
    smallJobKind?: boolean | smallJobKindDefaultArgs<ExtArgs>
    incumebent?: boolean | company$incumebentArgs<ExtArgs>
    student?: boolean | company$studentArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $companyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company"
    objects: {
      bigJobKind: Prisma.$bigJobKindPayload<ExtArgs>
      midJobKind: Prisma.$midJobKindPayload<ExtArgs>
      smallJobKind: Prisma.$smallJobKindPayload<ExtArgs>
      incumebent: Prisma.$incumbentsAdditionalPayload<ExtArgs>[]
      student: Prisma.$studentsAdditionalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string
      longitude: number
      latitude: number
      scale: string
      bigJobKindId: number
      midJobKindId: number
      smallJobKindId: number
    }, ExtArgs["result"]["company"]>
    composites: {}
  }


  type companyGetPayload<S extends boolean | null | undefined | companyDefaultArgs> = $Result.GetResult<Prisma.$companyPayload, S>

  type companyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<companyFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface companyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company'], meta: { name: 'company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {companyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends companyFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, companyFindUniqueArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Company that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {companyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends companyFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, companyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends companyFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, companyFindFirstArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends companyFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, companyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends companyFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, companyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Company.
     * @param {companyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
    **/
    create<T extends companyCreateArgs<ExtArgs>>(
      args: SelectSubset<T, companyCreateArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Companies.
     *     @param {companyCreateManyArgs} args - Arguments to create many Companies.
     *     @example
     *     // Create many Companies
     *     const company = await prisma.company.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends companyCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, companyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company.
     * @param {companyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
    **/
    delete<T extends companyDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, companyDeleteArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Company.
     * @param {companyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends companyUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, companyUpdateArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Companies.
     * @param {companyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends companyDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, companyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends companyUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, companyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company.
     * @param {companyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
    **/
    upsert<T extends companyUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, companyUpsertArgs<ExtArgs>>
    ): Prisma__companyClient<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends companyCountArgs>(
      args?: Subset<T, companyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companyGroupByArgs['orderBy'] }
        : { orderBy?: companyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company model
   */
  readonly fields: companyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    bigJobKind<T extends bigJobKindDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bigJobKindDefaultArgs<ExtArgs>>): Prisma__bigJobKindClient<$Result.GetResult<Prisma.$bigJobKindPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    midJobKind<T extends midJobKindDefaultArgs<ExtArgs> = {}>(args?: Subset<T, midJobKindDefaultArgs<ExtArgs>>): Prisma__midJobKindClient<$Result.GetResult<Prisma.$midJobKindPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    smallJobKind<T extends smallJobKindDefaultArgs<ExtArgs> = {}>(args?: Subset<T, smallJobKindDefaultArgs<ExtArgs>>): Prisma__smallJobKindClient<$Result.GetResult<Prisma.$smallJobKindPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    incumebent<T extends company$incumebentArgs<ExtArgs> = {}>(args?: Subset<T, company$incumebentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$incumbentsAdditionalPayload<ExtArgs>, T, 'findMany'> | Null>;

    student<T extends company$studentArgs<ExtArgs> = {}>(args?: Subset<T, company$studentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsAdditionalPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the company model
   */ 
  interface companyFieldRefs {
    readonly id: FieldRef<"company", 'Int'>
    readonly name: FieldRef<"company", 'String'>
    readonly address: FieldRef<"company", 'String'>
    readonly longitude: FieldRef<"company", 'Float'>
    readonly latitude: FieldRef<"company", 'Float'>
    readonly scale: FieldRef<"company", 'String'>
    readonly bigJobKindId: FieldRef<"company", 'Int'>
    readonly midJobKindId: FieldRef<"company", 'Int'>
    readonly smallJobKindId: FieldRef<"company", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * company findUnique
   */
  export type companyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter, which company to fetch.
     */
    where: companyWhereUniqueInput
  }


  /**
   * company findUniqueOrThrow
   */
  export type companyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter, which company to fetch.
     */
    where: companyWhereUniqueInput
  }


  /**
   * company findFirst
   */
  export type companyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter, which company to fetch.
     */
    where?: companyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }


  /**
   * company findFirstOrThrow
   */
  export type companyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter, which company to fetch.
     */
    where?: companyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }


  /**
   * company findMany
   */
  export type companyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companies.
     */
    cursor?: companyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }


  /**
   * company create
   */
  export type companyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * The data needed to create a company.
     */
    data: XOR<companyCreateInput, companyUncheckedCreateInput>
  }


  /**
   * company createMany
   */
  export type companyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companies.
     */
    data: companyCreateManyInput | companyCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * company update
   */
  export type companyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * The data needed to update a company.
     */
    data: XOR<companyUpdateInput, companyUncheckedUpdateInput>
    /**
     * Choose, which company to update.
     */
    where: companyWhereUniqueInput
  }


  /**
   * company updateMany
   */
  export type companyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companies.
     */
    data: XOR<companyUpdateManyMutationInput, companyUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companyWhereInput
  }


  /**
   * company upsert
   */
  export type companyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * The filter to search for the company to update in case it exists.
     */
    where: companyWhereUniqueInput
    /**
     * In case the company found by the `where` argument doesn't exist, create a new company with this data.
     */
    create: XOR<companyCreateInput, companyUncheckedCreateInput>
    /**
     * In case the company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companyUpdateInput, companyUncheckedUpdateInput>
  }


  /**
   * company delete
   */
  export type companyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    /**
     * Filter which company to delete.
     */
    where: companyWhereUniqueInput
  }


  /**
   * company deleteMany
   */
  export type companyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to delete
     */
    where?: companyWhereInput
  }


  /**
   * company.incumebent
   */
  export type company$incumebentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incumbentsAdditional
     */
    select?: incumbentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incumbentsAdditionalInclude<ExtArgs> | null
    where?: incumbentsAdditionalWhereInput
    orderBy?: incumbentsAdditionalOrderByWithRelationInput | incumbentsAdditionalOrderByWithRelationInput[]
    cursor?: incumbentsAdditionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncumbentsAdditionalScalarFieldEnum | IncumbentsAdditionalScalarFieldEnum[]
  }


  /**
   * company.student
   */
  export type company$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentsAdditional
     */
    select?: studentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: studentsAdditionalInclude<ExtArgs> | null
    where?: studentsAdditionalWhereInput
    orderBy?: studentsAdditionalOrderByWithRelationInput | studentsAdditionalOrderByWithRelationInput[]
    cursor?: studentsAdditionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentsAdditionalScalarFieldEnum | StudentsAdditionalScalarFieldEnum[]
  }


  /**
   * company without action
   */
  export type companyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
  }



  /**
   * Model school
   */

  export type AggregateSchool = {
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  export type SchoolAvgAggregateOutputType = {
    id: number | null
  }

  export type SchoolSumAggregateOutputType = {
    id: number | null
  }

  export type SchoolMinAggregateOutputType = {
    id: number | null
    name: string | null
    branch: string | null
  }

  export type SchoolMaxAggregateOutputType = {
    id: number | null
    name: string | null
    branch: string | null
  }

  export type SchoolCountAggregateOutputType = {
    id: number
    name: number
    branch: number
    _all: number
  }


  export type SchoolAvgAggregateInputType = {
    id?: true
  }

  export type SchoolSumAggregateInputType = {
    id?: true
  }

  export type SchoolMinAggregateInputType = {
    id?: true
    name?: true
    branch?: true
  }

  export type SchoolMaxAggregateInputType = {
    id?: true
    name?: true
    branch?: true
  }

  export type SchoolCountAggregateInputType = {
    id?: true
    name?: true
    branch?: true
    _all?: true
  }

  export type SchoolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which school to aggregate.
     */
    where?: schoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schools to fetch.
     */
    orderBy?: schoolOrderByWithRelationInput | schoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: schoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned schools
    **/
    _count?: true | SchoolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolMaxAggregateInputType
  }

  export type GetSchoolAggregateType<T extends SchoolAggregateArgs> = {
        [P in keyof T & keyof AggregateSchool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchool[P]>
      : GetScalarType<T[P], AggregateSchool[P]>
  }




  export type schoolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: schoolWhereInput
    orderBy?: schoolOrderByWithAggregationInput | schoolOrderByWithAggregationInput[]
    by: SchoolScalarFieldEnum[] | SchoolScalarFieldEnum
    having?: schoolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolCountAggregateInputType | true
    _avg?: SchoolAvgAggregateInputType
    _sum?: SchoolSumAggregateInputType
    _min?: SchoolMinAggregateInputType
    _max?: SchoolMaxAggregateInputType
  }

  export type SchoolGroupByOutputType = {
    id: number
    name: string
    branch: string
    _count: SchoolCountAggregateOutputType | null
    _avg: SchoolAvgAggregateOutputType | null
    _sum: SchoolSumAggregateOutputType | null
    _min: SchoolMinAggregateOutputType | null
    _max: SchoolMaxAggregateOutputType | null
  }

  type GetSchoolGroupByPayload<T extends schoolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolGroupByOutputType[P]>
        }
      >
    >


  export type schoolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    branch?: boolean
    major?: boolean | school$majorArgs<ExtArgs>
    incumebent?: boolean | school$incumebentArgs<ExtArgs>
    student?: boolean | school$studentArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["school"]>

  export type schoolSelectScalar = {
    id?: boolean
    name?: boolean
    branch?: boolean
  }

  export type schoolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    major?: boolean | school$majorArgs<ExtArgs>
    incumebent?: boolean | school$incumebentArgs<ExtArgs>
    student?: boolean | school$studentArgs<ExtArgs>
    _count?: boolean | SchoolCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $schoolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "school"
    objects: {
      major: Prisma.$majorPayload<ExtArgs>[]
      incumebent: Prisma.$incumbentsAdditionalPayload<ExtArgs>[]
      student: Prisma.$studentsAdditionalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      branch: string
    }, ExtArgs["result"]["school"]>
    composites: {}
  }


  type schoolGetPayload<S extends boolean | null | undefined | schoolDefaultArgs> = $Result.GetResult<Prisma.$schoolPayload, S>

  type schoolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<schoolFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SchoolCountAggregateInputType | true
    }

  export interface schoolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['school'], meta: { name: 'school' } }
    /**
     * Find zero or one School that matches the filter.
     * @param {schoolFindUniqueArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends schoolFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, schoolFindUniqueArgs<ExtArgs>>
    ): Prisma__schoolClient<$Result.GetResult<Prisma.$schoolPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one School that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {schoolFindUniqueOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends schoolFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, schoolFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__schoolClient<$Result.GetResult<Prisma.$schoolPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first School that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolFindFirstArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends schoolFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, schoolFindFirstArgs<ExtArgs>>
    ): Prisma__schoolClient<$Result.GetResult<Prisma.$schoolPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first School that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolFindFirstOrThrowArgs} args - Arguments to find a School
     * @example
     * // Get one School
     * const school = await prisma.school.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends schoolFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, schoolFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__schoolClient<$Result.GetResult<Prisma.$schoolPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Schools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schools
     * const schools = await prisma.school.findMany()
     * 
     * // Get first 10 Schools
     * const schools = await prisma.school.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolWithIdOnly = await prisma.school.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends schoolFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, schoolFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$schoolPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a School.
     * @param {schoolCreateArgs} args - Arguments to create a School.
     * @example
     * // Create one School
     * const School = await prisma.school.create({
     *   data: {
     *     // ... data to create a School
     *   }
     * })
     * 
    **/
    create<T extends schoolCreateArgs<ExtArgs>>(
      args: SelectSubset<T, schoolCreateArgs<ExtArgs>>
    ): Prisma__schoolClient<$Result.GetResult<Prisma.$schoolPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Schools.
     *     @param {schoolCreateManyArgs} args - Arguments to create many Schools.
     *     @example
     *     // Create many Schools
     *     const school = await prisma.school.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends schoolCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, schoolCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a School.
     * @param {schoolDeleteArgs} args - Arguments to delete one School.
     * @example
     * // Delete one School
     * const School = await prisma.school.delete({
     *   where: {
     *     // ... filter to delete one School
     *   }
     * })
     * 
    **/
    delete<T extends schoolDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, schoolDeleteArgs<ExtArgs>>
    ): Prisma__schoolClient<$Result.GetResult<Prisma.$schoolPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one School.
     * @param {schoolUpdateArgs} args - Arguments to update one School.
     * @example
     * // Update one School
     * const school = await prisma.school.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends schoolUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, schoolUpdateArgs<ExtArgs>>
    ): Prisma__schoolClient<$Result.GetResult<Prisma.$schoolPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Schools.
     * @param {schoolDeleteManyArgs} args - Arguments to filter Schools to delete.
     * @example
     * // Delete a few Schools
     * const { count } = await prisma.school.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends schoolDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, schoolDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schools
     * const school = await prisma.school.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends schoolUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, schoolUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one School.
     * @param {schoolUpsertArgs} args - Arguments to update or create a School.
     * @example
     * // Update or create a School
     * const school = await prisma.school.upsert({
     *   create: {
     *     // ... data to create a School
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the School we want to update
     *   }
     * })
    **/
    upsert<T extends schoolUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, schoolUpsertArgs<ExtArgs>>
    ): Prisma__schoolClient<$Result.GetResult<Prisma.$schoolPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Schools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolCountArgs} args - Arguments to filter Schools to count.
     * @example
     * // Count the number of Schools
     * const count = await prisma.school.count({
     *   where: {
     *     // ... the filter for the Schools we want to count
     *   }
     * })
    **/
    count<T extends schoolCountArgs>(
      args?: Subset<T, schoolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolAggregateArgs>(args: Subset<T, SchoolAggregateArgs>): Prisma.PrismaPromise<GetSchoolAggregateType<T>>

    /**
     * Group by School.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {schoolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends schoolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: schoolGroupByArgs['orderBy'] }
        : { orderBy?: schoolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, schoolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the school model
   */
  readonly fields: schoolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for school.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__schoolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    major<T extends school$majorArgs<ExtArgs> = {}>(args?: Subset<T, school$majorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$majorPayload<ExtArgs>, T, 'findMany'> | Null>;

    incumebent<T extends school$incumebentArgs<ExtArgs> = {}>(args?: Subset<T, school$incumebentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$incumbentsAdditionalPayload<ExtArgs>, T, 'findMany'> | Null>;

    student<T extends school$studentArgs<ExtArgs> = {}>(args?: Subset<T, school$studentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsAdditionalPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the school model
   */ 
  interface schoolFieldRefs {
    readonly id: FieldRef<"school", 'Int'>
    readonly name: FieldRef<"school", 'String'>
    readonly branch: FieldRef<"school", 'String'>
  }
    

  // Custom InputTypes

  /**
   * school findUnique
   */
  export type schoolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school
     */
    select?: schoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolInclude<ExtArgs> | null
    /**
     * Filter, which school to fetch.
     */
    where: schoolWhereUniqueInput
  }


  /**
   * school findUniqueOrThrow
   */
  export type schoolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school
     */
    select?: schoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolInclude<ExtArgs> | null
    /**
     * Filter, which school to fetch.
     */
    where: schoolWhereUniqueInput
  }


  /**
   * school findFirst
   */
  export type schoolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school
     */
    select?: schoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolInclude<ExtArgs> | null
    /**
     * Filter, which school to fetch.
     */
    where?: schoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schools to fetch.
     */
    orderBy?: schoolOrderByWithRelationInput | schoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schools.
     */
    cursor?: schoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }


  /**
   * school findFirstOrThrow
   */
  export type schoolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school
     */
    select?: schoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolInclude<ExtArgs> | null
    /**
     * Filter, which school to fetch.
     */
    where?: schoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schools to fetch.
     */
    orderBy?: schoolOrderByWithRelationInput | schoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for schools.
     */
    cursor?: schoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of schools.
     */
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }


  /**
   * school findMany
   */
  export type schoolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school
     */
    select?: schoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolInclude<ExtArgs> | null
    /**
     * Filter, which schools to fetch.
     */
    where?: schoolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of schools to fetch.
     */
    orderBy?: schoolOrderByWithRelationInput | schoolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing schools.
     */
    cursor?: schoolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` schools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` schools.
     */
    skip?: number
    distinct?: SchoolScalarFieldEnum | SchoolScalarFieldEnum[]
  }


  /**
   * school create
   */
  export type schoolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school
     */
    select?: schoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolInclude<ExtArgs> | null
    /**
     * The data needed to create a school.
     */
    data: XOR<schoolCreateInput, schoolUncheckedCreateInput>
  }


  /**
   * school createMany
   */
  export type schoolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many schools.
     */
    data: schoolCreateManyInput | schoolCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * school update
   */
  export type schoolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school
     */
    select?: schoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolInclude<ExtArgs> | null
    /**
     * The data needed to update a school.
     */
    data: XOR<schoolUpdateInput, schoolUncheckedUpdateInput>
    /**
     * Choose, which school to update.
     */
    where: schoolWhereUniqueInput
  }


  /**
   * school updateMany
   */
  export type schoolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update schools.
     */
    data: XOR<schoolUpdateManyMutationInput, schoolUncheckedUpdateManyInput>
    /**
     * Filter which schools to update
     */
    where?: schoolWhereInput
  }


  /**
   * school upsert
   */
  export type schoolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school
     */
    select?: schoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolInclude<ExtArgs> | null
    /**
     * The filter to search for the school to update in case it exists.
     */
    where: schoolWhereUniqueInput
    /**
     * In case the school found by the `where` argument doesn't exist, create a new school with this data.
     */
    create: XOR<schoolCreateInput, schoolUncheckedCreateInput>
    /**
     * In case the school was found with the provided `where` argument, update it with this data.
     */
    update: XOR<schoolUpdateInput, schoolUncheckedUpdateInput>
  }


  /**
   * school delete
   */
  export type schoolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school
     */
    select?: schoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolInclude<ExtArgs> | null
    /**
     * Filter which school to delete.
     */
    where: schoolWhereUniqueInput
  }


  /**
   * school deleteMany
   */
  export type schoolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which schools to delete
     */
    where?: schoolWhereInput
  }


  /**
   * school.major
   */
  export type school$majorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the major
     */
    select?: majorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: majorInclude<ExtArgs> | null
    where?: majorWhereInput
    orderBy?: majorOrderByWithRelationInput | majorOrderByWithRelationInput[]
    cursor?: majorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MajorScalarFieldEnum | MajorScalarFieldEnum[]
  }


  /**
   * school.incumebent
   */
  export type school$incumebentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incumbentsAdditional
     */
    select?: incumbentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incumbentsAdditionalInclude<ExtArgs> | null
    where?: incumbentsAdditionalWhereInput
    orderBy?: incumbentsAdditionalOrderByWithRelationInput | incumbentsAdditionalOrderByWithRelationInput[]
    cursor?: incumbentsAdditionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncumbentsAdditionalScalarFieldEnum | IncumbentsAdditionalScalarFieldEnum[]
  }


  /**
   * school.student
   */
  export type school$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentsAdditional
     */
    select?: studentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: studentsAdditionalInclude<ExtArgs> | null
    where?: studentsAdditionalWhereInput
    orderBy?: studentsAdditionalOrderByWithRelationInput | studentsAdditionalOrderByWithRelationInput[]
    cursor?: studentsAdditionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentsAdditionalScalarFieldEnum | StudentsAdditionalScalarFieldEnum[]
  }


  /**
   * school without action
   */
  export type schoolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the school
     */
    select?: schoolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: schoolInclude<ExtArgs> | null
  }



  /**
   * Model major
   */

  export type AggregateMajor = {
    _count: MajorCountAggregateOutputType | null
    _avg: MajorAvgAggregateOutputType | null
    _sum: MajorSumAggregateOutputType | null
    _min: MajorMinAggregateOutputType | null
    _max: MajorMaxAggregateOutputType | null
  }

  export type MajorAvgAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type MajorSumAggregateOutputType = {
    id: number | null
    schoolId: number | null
  }

  export type MajorMinAggregateOutputType = {
    id: number | null
    schoolId: number | null
    name: string | null
    dayAndNight: string | null
  }

  export type MajorMaxAggregateOutputType = {
    id: number | null
    schoolId: number | null
    name: string | null
    dayAndNight: string | null
  }

  export type MajorCountAggregateOutputType = {
    id: number
    schoolId: number
    name: number
    dayAndNight: number
    _all: number
  }


  export type MajorAvgAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type MajorSumAggregateInputType = {
    id?: true
    schoolId?: true
  }

  export type MajorMinAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    dayAndNight?: true
  }

  export type MajorMaxAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    dayAndNight?: true
  }

  export type MajorCountAggregateInputType = {
    id?: true
    schoolId?: true
    name?: true
    dayAndNight?: true
    _all?: true
  }

  export type MajorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which major to aggregate.
     */
    where?: majorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of majors to fetch.
     */
    orderBy?: majorOrderByWithRelationInput | majorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: majorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` majors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` majors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned majors
    **/
    _count?: true | MajorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MajorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MajorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MajorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MajorMaxAggregateInputType
  }

  export type GetMajorAggregateType<T extends MajorAggregateArgs> = {
        [P in keyof T & keyof AggregateMajor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMajor[P]>
      : GetScalarType<T[P], AggregateMajor[P]>
  }




  export type majorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: majorWhereInput
    orderBy?: majorOrderByWithAggregationInput | majorOrderByWithAggregationInput[]
    by: MajorScalarFieldEnum[] | MajorScalarFieldEnum
    having?: majorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MajorCountAggregateInputType | true
    _avg?: MajorAvgAggregateInputType
    _sum?: MajorSumAggregateInputType
    _min?: MajorMinAggregateInputType
    _max?: MajorMaxAggregateInputType
  }

  export type MajorGroupByOutputType = {
    id: number
    schoolId: number
    name: string
    dayAndNight: string
    _count: MajorCountAggregateOutputType | null
    _avg: MajorAvgAggregateOutputType | null
    _sum: MajorSumAggregateOutputType | null
    _min: MajorMinAggregateOutputType | null
    _max: MajorMaxAggregateOutputType | null
  }

  type GetMajorGroupByPayload<T extends majorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MajorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MajorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MajorGroupByOutputType[P]>
            : GetScalarType<T[P], MajorGroupByOutputType[P]>
        }
      >
    >


  export type majorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schoolId?: boolean
    name?: boolean
    dayAndNight?: boolean
    school?: boolean | schoolDefaultArgs<ExtArgs>
    incumebent?: boolean | major$incumebentArgs<ExtArgs>
    student?: boolean | major$studentArgs<ExtArgs>
    _count?: boolean | MajorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["major"]>

  export type majorSelectScalar = {
    id?: boolean
    schoolId?: boolean
    name?: boolean
    dayAndNight?: boolean
  }

  export type majorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    school?: boolean | schoolDefaultArgs<ExtArgs>
    incumebent?: boolean | major$incumebentArgs<ExtArgs>
    student?: boolean | major$studentArgs<ExtArgs>
    _count?: boolean | MajorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $majorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "major"
    objects: {
      school: Prisma.$schoolPayload<ExtArgs>
      incumebent: Prisma.$incumbentsAdditionalPayload<ExtArgs>[]
      student: Prisma.$studentsAdditionalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      schoolId: number
      name: string
      dayAndNight: string
    }, ExtArgs["result"]["major"]>
    composites: {}
  }


  type majorGetPayload<S extends boolean | null | undefined | majorDefaultArgs> = $Result.GetResult<Prisma.$majorPayload, S>

  type majorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<majorFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MajorCountAggregateInputType | true
    }

  export interface majorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['major'], meta: { name: 'major' } }
    /**
     * Find zero or one Major that matches the filter.
     * @param {majorFindUniqueArgs} args - Arguments to find a Major
     * @example
     * // Get one Major
     * const major = await prisma.major.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends majorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, majorFindUniqueArgs<ExtArgs>>
    ): Prisma__majorClient<$Result.GetResult<Prisma.$majorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Major that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {majorFindUniqueOrThrowArgs} args - Arguments to find a Major
     * @example
     * // Get one Major
     * const major = await prisma.major.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends majorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, majorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__majorClient<$Result.GetResult<Prisma.$majorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Major that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {majorFindFirstArgs} args - Arguments to find a Major
     * @example
     * // Get one Major
     * const major = await prisma.major.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends majorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, majorFindFirstArgs<ExtArgs>>
    ): Prisma__majorClient<$Result.GetResult<Prisma.$majorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Major that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {majorFindFirstOrThrowArgs} args - Arguments to find a Major
     * @example
     * // Get one Major
     * const major = await prisma.major.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends majorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, majorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__majorClient<$Result.GetResult<Prisma.$majorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Majors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {majorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Majors
     * const majors = await prisma.major.findMany()
     * 
     * // Get first 10 Majors
     * const majors = await prisma.major.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const majorWithIdOnly = await prisma.major.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends majorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, majorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$majorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Major.
     * @param {majorCreateArgs} args - Arguments to create a Major.
     * @example
     * // Create one Major
     * const Major = await prisma.major.create({
     *   data: {
     *     // ... data to create a Major
     *   }
     * })
     * 
    **/
    create<T extends majorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, majorCreateArgs<ExtArgs>>
    ): Prisma__majorClient<$Result.GetResult<Prisma.$majorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Majors.
     *     @param {majorCreateManyArgs} args - Arguments to create many Majors.
     *     @example
     *     // Create many Majors
     *     const major = await prisma.major.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends majorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, majorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Major.
     * @param {majorDeleteArgs} args - Arguments to delete one Major.
     * @example
     * // Delete one Major
     * const Major = await prisma.major.delete({
     *   where: {
     *     // ... filter to delete one Major
     *   }
     * })
     * 
    **/
    delete<T extends majorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, majorDeleteArgs<ExtArgs>>
    ): Prisma__majorClient<$Result.GetResult<Prisma.$majorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Major.
     * @param {majorUpdateArgs} args - Arguments to update one Major.
     * @example
     * // Update one Major
     * const major = await prisma.major.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends majorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, majorUpdateArgs<ExtArgs>>
    ): Prisma__majorClient<$Result.GetResult<Prisma.$majorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Majors.
     * @param {majorDeleteManyArgs} args - Arguments to filter Majors to delete.
     * @example
     * // Delete a few Majors
     * const { count } = await prisma.major.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends majorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, majorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Majors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {majorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Majors
     * const major = await prisma.major.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends majorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, majorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Major.
     * @param {majorUpsertArgs} args - Arguments to update or create a Major.
     * @example
     * // Update or create a Major
     * const major = await prisma.major.upsert({
     *   create: {
     *     // ... data to create a Major
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Major we want to update
     *   }
     * })
    **/
    upsert<T extends majorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, majorUpsertArgs<ExtArgs>>
    ): Prisma__majorClient<$Result.GetResult<Prisma.$majorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Majors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {majorCountArgs} args - Arguments to filter Majors to count.
     * @example
     * // Count the number of Majors
     * const count = await prisma.major.count({
     *   where: {
     *     // ... the filter for the Majors we want to count
     *   }
     * })
    **/
    count<T extends majorCountArgs>(
      args?: Subset<T, majorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MajorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Major.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MajorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MajorAggregateArgs>(args: Subset<T, MajorAggregateArgs>): Prisma.PrismaPromise<GetMajorAggregateType<T>>

    /**
     * Group by Major.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {majorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends majorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: majorGroupByArgs['orderBy'] }
        : { orderBy?: majorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, majorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMajorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the major model
   */
  readonly fields: majorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for major.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__majorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    school<T extends schoolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, schoolDefaultArgs<ExtArgs>>): Prisma__schoolClient<$Result.GetResult<Prisma.$schoolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    incumebent<T extends major$incumebentArgs<ExtArgs> = {}>(args?: Subset<T, major$incumebentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$incumbentsAdditionalPayload<ExtArgs>, T, 'findMany'> | Null>;

    student<T extends major$studentArgs<ExtArgs> = {}>(args?: Subset<T, major$studentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsAdditionalPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the major model
   */ 
  interface majorFieldRefs {
    readonly id: FieldRef<"major", 'Int'>
    readonly schoolId: FieldRef<"major", 'Int'>
    readonly name: FieldRef<"major", 'String'>
    readonly dayAndNight: FieldRef<"major", 'String'>
  }
    

  // Custom InputTypes

  /**
   * major findUnique
   */
  export type majorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the major
     */
    select?: majorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: majorInclude<ExtArgs> | null
    /**
     * Filter, which major to fetch.
     */
    where: majorWhereUniqueInput
  }


  /**
   * major findUniqueOrThrow
   */
  export type majorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the major
     */
    select?: majorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: majorInclude<ExtArgs> | null
    /**
     * Filter, which major to fetch.
     */
    where: majorWhereUniqueInput
  }


  /**
   * major findFirst
   */
  export type majorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the major
     */
    select?: majorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: majorInclude<ExtArgs> | null
    /**
     * Filter, which major to fetch.
     */
    where?: majorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of majors to fetch.
     */
    orderBy?: majorOrderByWithRelationInput | majorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for majors.
     */
    cursor?: majorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` majors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` majors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of majors.
     */
    distinct?: MajorScalarFieldEnum | MajorScalarFieldEnum[]
  }


  /**
   * major findFirstOrThrow
   */
  export type majorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the major
     */
    select?: majorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: majorInclude<ExtArgs> | null
    /**
     * Filter, which major to fetch.
     */
    where?: majorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of majors to fetch.
     */
    orderBy?: majorOrderByWithRelationInput | majorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for majors.
     */
    cursor?: majorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` majors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` majors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of majors.
     */
    distinct?: MajorScalarFieldEnum | MajorScalarFieldEnum[]
  }


  /**
   * major findMany
   */
  export type majorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the major
     */
    select?: majorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: majorInclude<ExtArgs> | null
    /**
     * Filter, which majors to fetch.
     */
    where?: majorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of majors to fetch.
     */
    orderBy?: majorOrderByWithRelationInput | majorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing majors.
     */
    cursor?: majorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` majors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` majors.
     */
    skip?: number
    distinct?: MajorScalarFieldEnum | MajorScalarFieldEnum[]
  }


  /**
   * major create
   */
  export type majorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the major
     */
    select?: majorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: majorInclude<ExtArgs> | null
    /**
     * The data needed to create a major.
     */
    data: XOR<majorCreateInput, majorUncheckedCreateInput>
  }


  /**
   * major createMany
   */
  export type majorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many majors.
     */
    data: majorCreateManyInput | majorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * major update
   */
  export type majorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the major
     */
    select?: majorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: majorInclude<ExtArgs> | null
    /**
     * The data needed to update a major.
     */
    data: XOR<majorUpdateInput, majorUncheckedUpdateInput>
    /**
     * Choose, which major to update.
     */
    where: majorWhereUniqueInput
  }


  /**
   * major updateMany
   */
  export type majorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update majors.
     */
    data: XOR<majorUpdateManyMutationInput, majorUncheckedUpdateManyInput>
    /**
     * Filter which majors to update
     */
    where?: majorWhereInput
  }


  /**
   * major upsert
   */
  export type majorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the major
     */
    select?: majorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: majorInclude<ExtArgs> | null
    /**
     * The filter to search for the major to update in case it exists.
     */
    where: majorWhereUniqueInput
    /**
     * In case the major found by the `where` argument doesn't exist, create a new major with this data.
     */
    create: XOR<majorCreateInput, majorUncheckedCreateInput>
    /**
     * In case the major was found with the provided `where` argument, update it with this data.
     */
    update: XOR<majorUpdateInput, majorUncheckedUpdateInput>
  }


  /**
   * major delete
   */
  export type majorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the major
     */
    select?: majorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: majorInclude<ExtArgs> | null
    /**
     * Filter which major to delete.
     */
    where: majorWhereUniqueInput
  }


  /**
   * major deleteMany
   */
  export type majorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which majors to delete
     */
    where?: majorWhereInput
  }


  /**
   * major.incumebent
   */
  export type major$incumebentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incumbentsAdditional
     */
    select?: incumbentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incumbentsAdditionalInclude<ExtArgs> | null
    where?: incumbentsAdditionalWhereInput
    orderBy?: incumbentsAdditionalOrderByWithRelationInput | incumbentsAdditionalOrderByWithRelationInput[]
    cursor?: incumbentsAdditionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncumbentsAdditionalScalarFieldEnum | IncumbentsAdditionalScalarFieldEnum[]
  }


  /**
   * major.student
   */
  export type major$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentsAdditional
     */
    select?: studentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: studentsAdditionalInclude<ExtArgs> | null
    where?: studentsAdditionalWhereInput
    orderBy?: studentsAdditionalOrderByWithRelationInput | studentsAdditionalOrderByWithRelationInput[]
    cursor?: studentsAdditionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentsAdditionalScalarFieldEnum | StudentsAdditionalScalarFieldEnum[]
  }


  /**
   * major without action
   */
  export type majorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the major
     */
    select?: majorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: majorInclude<ExtArgs> | null
  }



  /**
   * Model bigJobKind
   */

  export type AggregateBigJobKind = {
    _count: BigJobKindCountAggregateOutputType | null
    _avg: BigJobKindAvgAggregateOutputType | null
    _sum: BigJobKindSumAggregateOutputType | null
    _min: BigJobKindMinAggregateOutputType | null
    _max: BigJobKindMaxAggregateOutputType | null
  }

  export type BigJobKindAvgAggregateOutputType = {
    id: number | null
  }

  export type BigJobKindSumAggregateOutputType = {
    id: number | null
  }

  export type BigJobKindMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type BigJobKindMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type BigJobKindCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type BigJobKindAvgAggregateInputType = {
    id?: true
  }

  export type BigJobKindSumAggregateInputType = {
    id?: true
  }

  export type BigJobKindMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type BigJobKindMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type BigJobKindCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type BigJobKindAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bigJobKind to aggregate.
     */
    where?: bigJobKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bigJobKinds to fetch.
     */
    orderBy?: bigJobKindOrderByWithRelationInput | bigJobKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bigJobKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bigJobKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bigJobKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bigJobKinds
    **/
    _count?: true | BigJobKindCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BigJobKindAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BigJobKindSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BigJobKindMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BigJobKindMaxAggregateInputType
  }

  export type GetBigJobKindAggregateType<T extends BigJobKindAggregateArgs> = {
        [P in keyof T & keyof AggregateBigJobKind]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBigJobKind[P]>
      : GetScalarType<T[P], AggregateBigJobKind[P]>
  }




  export type bigJobKindGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bigJobKindWhereInput
    orderBy?: bigJobKindOrderByWithAggregationInput | bigJobKindOrderByWithAggregationInput[]
    by: BigJobKindScalarFieldEnum[] | BigJobKindScalarFieldEnum
    having?: bigJobKindScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BigJobKindCountAggregateInputType | true
    _avg?: BigJobKindAvgAggregateInputType
    _sum?: BigJobKindSumAggregateInputType
    _min?: BigJobKindMinAggregateInputType
    _max?: BigJobKindMaxAggregateInputType
  }

  export type BigJobKindGroupByOutputType = {
    id: number
    name: string
    _count: BigJobKindCountAggregateOutputType | null
    _avg: BigJobKindAvgAggregateOutputType | null
    _sum: BigJobKindSumAggregateOutputType | null
    _min: BigJobKindMinAggregateOutputType | null
    _max: BigJobKindMaxAggregateOutputType | null
  }

  type GetBigJobKindGroupByPayload<T extends bigJobKindGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BigJobKindGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BigJobKindGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BigJobKindGroupByOutputType[P]>
            : GetScalarType<T[P], BigJobKindGroupByOutputType[P]>
        }
      >
    >


  export type bigJobKindSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    company?: boolean | bigJobKind$companyArgs<ExtArgs>
    midJobKind?: boolean | bigJobKind$midJobKindArgs<ExtArgs>
    _count?: boolean | BigJobKindCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bigJobKind"]>

  export type bigJobKindSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type bigJobKindInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | bigJobKind$companyArgs<ExtArgs>
    midJobKind?: boolean | bigJobKind$midJobKindArgs<ExtArgs>
    _count?: boolean | BigJobKindCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $bigJobKindPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bigJobKind"
    objects: {
      company: Prisma.$companyPayload<ExtArgs>[]
      midJobKind: Prisma.$midJobKindPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["bigJobKind"]>
    composites: {}
  }


  type bigJobKindGetPayload<S extends boolean | null | undefined | bigJobKindDefaultArgs> = $Result.GetResult<Prisma.$bigJobKindPayload, S>

  type bigJobKindCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<bigJobKindFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: BigJobKindCountAggregateInputType | true
    }

  export interface bigJobKindDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bigJobKind'], meta: { name: 'bigJobKind' } }
    /**
     * Find zero or one BigJobKind that matches the filter.
     * @param {bigJobKindFindUniqueArgs} args - Arguments to find a BigJobKind
     * @example
     * // Get one BigJobKind
     * const bigJobKind = await prisma.bigJobKind.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bigJobKindFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, bigJobKindFindUniqueArgs<ExtArgs>>
    ): Prisma__bigJobKindClient<$Result.GetResult<Prisma.$bigJobKindPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one BigJobKind that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bigJobKindFindUniqueOrThrowArgs} args - Arguments to find a BigJobKind
     * @example
     * // Get one BigJobKind
     * const bigJobKind = await prisma.bigJobKind.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bigJobKindFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bigJobKindFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__bigJobKindClient<$Result.GetResult<Prisma.$bigJobKindPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first BigJobKind that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bigJobKindFindFirstArgs} args - Arguments to find a BigJobKind
     * @example
     * // Get one BigJobKind
     * const bigJobKind = await prisma.bigJobKind.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bigJobKindFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, bigJobKindFindFirstArgs<ExtArgs>>
    ): Prisma__bigJobKindClient<$Result.GetResult<Prisma.$bigJobKindPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first BigJobKind that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bigJobKindFindFirstOrThrowArgs} args - Arguments to find a BigJobKind
     * @example
     * // Get one BigJobKind
     * const bigJobKind = await prisma.bigJobKind.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bigJobKindFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, bigJobKindFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__bigJobKindClient<$Result.GetResult<Prisma.$bigJobKindPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more BigJobKinds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bigJobKindFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BigJobKinds
     * const bigJobKinds = await prisma.bigJobKind.findMany()
     * 
     * // Get first 10 BigJobKinds
     * const bigJobKinds = await prisma.bigJobKind.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bigJobKindWithIdOnly = await prisma.bigJobKind.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bigJobKindFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bigJobKindFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bigJobKindPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a BigJobKind.
     * @param {bigJobKindCreateArgs} args - Arguments to create a BigJobKind.
     * @example
     * // Create one BigJobKind
     * const BigJobKind = await prisma.bigJobKind.create({
     *   data: {
     *     // ... data to create a BigJobKind
     *   }
     * })
     * 
    **/
    create<T extends bigJobKindCreateArgs<ExtArgs>>(
      args: SelectSubset<T, bigJobKindCreateArgs<ExtArgs>>
    ): Prisma__bigJobKindClient<$Result.GetResult<Prisma.$bigJobKindPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many BigJobKinds.
     *     @param {bigJobKindCreateManyArgs} args - Arguments to create many BigJobKinds.
     *     @example
     *     // Create many BigJobKinds
     *     const bigJobKind = await prisma.bigJobKind.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends bigJobKindCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bigJobKindCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BigJobKind.
     * @param {bigJobKindDeleteArgs} args - Arguments to delete one BigJobKind.
     * @example
     * // Delete one BigJobKind
     * const BigJobKind = await prisma.bigJobKind.delete({
     *   where: {
     *     // ... filter to delete one BigJobKind
     *   }
     * })
     * 
    **/
    delete<T extends bigJobKindDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, bigJobKindDeleteArgs<ExtArgs>>
    ): Prisma__bigJobKindClient<$Result.GetResult<Prisma.$bigJobKindPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one BigJobKind.
     * @param {bigJobKindUpdateArgs} args - Arguments to update one BigJobKind.
     * @example
     * // Update one BigJobKind
     * const bigJobKind = await prisma.bigJobKind.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bigJobKindUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, bigJobKindUpdateArgs<ExtArgs>>
    ): Prisma__bigJobKindClient<$Result.GetResult<Prisma.$bigJobKindPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more BigJobKinds.
     * @param {bigJobKindDeleteManyArgs} args - Arguments to filter BigJobKinds to delete.
     * @example
     * // Delete a few BigJobKinds
     * const { count } = await prisma.bigJobKind.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bigJobKindDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, bigJobKindDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BigJobKinds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bigJobKindUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BigJobKinds
     * const bigJobKind = await prisma.bigJobKind.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bigJobKindUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, bigJobKindUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BigJobKind.
     * @param {bigJobKindUpsertArgs} args - Arguments to update or create a BigJobKind.
     * @example
     * // Update or create a BigJobKind
     * const bigJobKind = await prisma.bigJobKind.upsert({
     *   create: {
     *     // ... data to create a BigJobKind
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BigJobKind we want to update
     *   }
     * })
    **/
    upsert<T extends bigJobKindUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, bigJobKindUpsertArgs<ExtArgs>>
    ): Prisma__bigJobKindClient<$Result.GetResult<Prisma.$bigJobKindPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of BigJobKinds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bigJobKindCountArgs} args - Arguments to filter BigJobKinds to count.
     * @example
     * // Count the number of BigJobKinds
     * const count = await prisma.bigJobKind.count({
     *   where: {
     *     // ... the filter for the BigJobKinds we want to count
     *   }
     * })
    **/
    count<T extends bigJobKindCountArgs>(
      args?: Subset<T, bigJobKindCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BigJobKindCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BigJobKind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BigJobKindAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BigJobKindAggregateArgs>(args: Subset<T, BigJobKindAggregateArgs>): Prisma.PrismaPromise<GetBigJobKindAggregateType<T>>

    /**
     * Group by BigJobKind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bigJobKindGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bigJobKindGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bigJobKindGroupByArgs['orderBy'] }
        : { orderBy?: bigJobKindGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bigJobKindGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBigJobKindGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bigJobKind model
   */
  readonly fields: bigJobKindFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bigJobKind.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bigJobKindClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends bigJobKind$companyArgs<ExtArgs> = {}>(args?: Subset<T, bigJobKind$companyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findMany'> | Null>;

    midJobKind<T extends bigJobKind$midJobKindArgs<ExtArgs> = {}>(args?: Subset<T, bigJobKind$midJobKindArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$midJobKindPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the bigJobKind model
   */ 
  interface bigJobKindFieldRefs {
    readonly id: FieldRef<"bigJobKind", 'Int'>
    readonly name: FieldRef<"bigJobKind", 'String'>
  }
    

  // Custom InputTypes

  /**
   * bigJobKind findUnique
   */
  export type bigJobKindFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bigJobKind
     */
    select?: bigJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bigJobKindInclude<ExtArgs> | null
    /**
     * Filter, which bigJobKind to fetch.
     */
    where: bigJobKindWhereUniqueInput
  }


  /**
   * bigJobKind findUniqueOrThrow
   */
  export type bigJobKindFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bigJobKind
     */
    select?: bigJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bigJobKindInclude<ExtArgs> | null
    /**
     * Filter, which bigJobKind to fetch.
     */
    where: bigJobKindWhereUniqueInput
  }


  /**
   * bigJobKind findFirst
   */
  export type bigJobKindFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bigJobKind
     */
    select?: bigJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bigJobKindInclude<ExtArgs> | null
    /**
     * Filter, which bigJobKind to fetch.
     */
    where?: bigJobKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bigJobKinds to fetch.
     */
    orderBy?: bigJobKindOrderByWithRelationInput | bigJobKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bigJobKinds.
     */
    cursor?: bigJobKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bigJobKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bigJobKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bigJobKinds.
     */
    distinct?: BigJobKindScalarFieldEnum | BigJobKindScalarFieldEnum[]
  }


  /**
   * bigJobKind findFirstOrThrow
   */
  export type bigJobKindFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bigJobKind
     */
    select?: bigJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bigJobKindInclude<ExtArgs> | null
    /**
     * Filter, which bigJobKind to fetch.
     */
    where?: bigJobKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bigJobKinds to fetch.
     */
    orderBy?: bigJobKindOrderByWithRelationInput | bigJobKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bigJobKinds.
     */
    cursor?: bigJobKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bigJobKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bigJobKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bigJobKinds.
     */
    distinct?: BigJobKindScalarFieldEnum | BigJobKindScalarFieldEnum[]
  }


  /**
   * bigJobKind findMany
   */
  export type bigJobKindFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bigJobKind
     */
    select?: bigJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bigJobKindInclude<ExtArgs> | null
    /**
     * Filter, which bigJobKinds to fetch.
     */
    where?: bigJobKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bigJobKinds to fetch.
     */
    orderBy?: bigJobKindOrderByWithRelationInput | bigJobKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bigJobKinds.
     */
    cursor?: bigJobKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bigJobKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bigJobKinds.
     */
    skip?: number
    distinct?: BigJobKindScalarFieldEnum | BigJobKindScalarFieldEnum[]
  }


  /**
   * bigJobKind create
   */
  export type bigJobKindCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bigJobKind
     */
    select?: bigJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bigJobKindInclude<ExtArgs> | null
    /**
     * The data needed to create a bigJobKind.
     */
    data: XOR<bigJobKindCreateInput, bigJobKindUncheckedCreateInput>
  }


  /**
   * bigJobKind createMany
   */
  export type bigJobKindCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bigJobKinds.
     */
    data: bigJobKindCreateManyInput | bigJobKindCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * bigJobKind update
   */
  export type bigJobKindUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bigJobKind
     */
    select?: bigJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bigJobKindInclude<ExtArgs> | null
    /**
     * The data needed to update a bigJobKind.
     */
    data: XOR<bigJobKindUpdateInput, bigJobKindUncheckedUpdateInput>
    /**
     * Choose, which bigJobKind to update.
     */
    where: bigJobKindWhereUniqueInput
  }


  /**
   * bigJobKind updateMany
   */
  export type bigJobKindUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bigJobKinds.
     */
    data: XOR<bigJobKindUpdateManyMutationInput, bigJobKindUncheckedUpdateManyInput>
    /**
     * Filter which bigJobKinds to update
     */
    where?: bigJobKindWhereInput
  }


  /**
   * bigJobKind upsert
   */
  export type bigJobKindUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bigJobKind
     */
    select?: bigJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bigJobKindInclude<ExtArgs> | null
    /**
     * The filter to search for the bigJobKind to update in case it exists.
     */
    where: bigJobKindWhereUniqueInput
    /**
     * In case the bigJobKind found by the `where` argument doesn't exist, create a new bigJobKind with this data.
     */
    create: XOR<bigJobKindCreateInput, bigJobKindUncheckedCreateInput>
    /**
     * In case the bigJobKind was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bigJobKindUpdateInput, bigJobKindUncheckedUpdateInput>
  }


  /**
   * bigJobKind delete
   */
  export type bigJobKindDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bigJobKind
     */
    select?: bigJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bigJobKindInclude<ExtArgs> | null
    /**
     * Filter which bigJobKind to delete.
     */
    where: bigJobKindWhereUniqueInput
  }


  /**
   * bigJobKind deleteMany
   */
  export type bigJobKindDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bigJobKinds to delete
     */
    where?: bigJobKindWhereInput
  }


  /**
   * bigJobKind.company
   */
  export type bigJobKind$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    where?: companyWhereInput
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    cursor?: companyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }


  /**
   * bigJobKind.midJobKind
   */
  export type bigJobKind$midJobKindArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midJobKind
     */
    select?: midJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: midJobKindInclude<ExtArgs> | null
    where?: midJobKindWhereInput
    orderBy?: midJobKindOrderByWithRelationInput | midJobKindOrderByWithRelationInput[]
    cursor?: midJobKindWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MidJobKindScalarFieldEnum | MidJobKindScalarFieldEnum[]
  }


  /**
   * bigJobKind without action
   */
  export type bigJobKindDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bigJobKind
     */
    select?: bigJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bigJobKindInclude<ExtArgs> | null
  }



  /**
   * Model midJobKind
   */

  export type AggregateMidJobKind = {
    _count: MidJobKindCountAggregateOutputType | null
    _avg: MidJobKindAvgAggregateOutputType | null
    _sum: MidJobKindSumAggregateOutputType | null
    _min: MidJobKindMinAggregateOutputType | null
    _max: MidJobKindMaxAggregateOutputType | null
  }

  export type MidJobKindAvgAggregateOutputType = {
    id: number | null
    bigJobKindId: number | null
  }

  export type MidJobKindSumAggregateOutputType = {
    id: number | null
    bigJobKindId: number | null
  }

  export type MidJobKindMinAggregateOutputType = {
    id: number | null
    bigJobKindId: number | null
    name: string | null
  }

  export type MidJobKindMaxAggregateOutputType = {
    id: number | null
    bigJobKindId: number | null
    name: string | null
  }

  export type MidJobKindCountAggregateOutputType = {
    id: number
    bigJobKindId: number
    name: number
    _all: number
  }


  export type MidJobKindAvgAggregateInputType = {
    id?: true
    bigJobKindId?: true
  }

  export type MidJobKindSumAggregateInputType = {
    id?: true
    bigJobKindId?: true
  }

  export type MidJobKindMinAggregateInputType = {
    id?: true
    bigJobKindId?: true
    name?: true
  }

  export type MidJobKindMaxAggregateInputType = {
    id?: true
    bigJobKindId?: true
    name?: true
  }

  export type MidJobKindCountAggregateInputType = {
    id?: true
    bigJobKindId?: true
    name?: true
    _all?: true
  }

  export type MidJobKindAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which midJobKind to aggregate.
     */
    where?: midJobKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of midJobKinds to fetch.
     */
    orderBy?: midJobKindOrderByWithRelationInput | midJobKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: midJobKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` midJobKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` midJobKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned midJobKinds
    **/
    _count?: true | MidJobKindCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MidJobKindAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MidJobKindSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MidJobKindMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MidJobKindMaxAggregateInputType
  }

  export type GetMidJobKindAggregateType<T extends MidJobKindAggregateArgs> = {
        [P in keyof T & keyof AggregateMidJobKind]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMidJobKind[P]>
      : GetScalarType<T[P], AggregateMidJobKind[P]>
  }




  export type midJobKindGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: midJobKindWhereInput
    orderBy?: midJobKindOrderByWithAggregationInput | midJobKindOrderByWithAggregationInput[]
    by: MidJobKindScalarFieldEnum[] | MidJobKindScalarFieldEnum
    having?: midJobKindScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MidJobKindCountAggregateInputType | true
    _avg?: MidJobKindAvgAggregateInputType
    _sum?: MidJobKindSumAggregateInputType
    _min?: MidJobKindMinAggregateInputType
    _max?: MidJobKindMaxAggregateInputType
  }

  export type MidJobKindGroupByOutputType = {
    id: number
    bigJobKindId: number
    name: string
    _count: MidJobKindCountAggregateOutputType | null
    _avg: MidJobKindAvgAggregateOutputType | null
    _sum: MidJobKindSumAggregateOutputType | null
    _min: MidJobKindMinAggregateOutputType | null
    _max: MidJobKindMaxAggregateOutputType | null
  }

  type GetMidJobKindGroupByPayload<T extends midJobKindGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MidJobKindGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MidJobKindGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MidJobKindGroupByOutputType[P]>
            : GetScalarType<T[P], MidJobKindGroupByOutputType[P]>
        }
      >
    >


  export type midJobKindSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bigJobKindId?: boolean
    name?: boolean
    company?: boolean | midJobKind$companyArgs<ExtArgs>
    bigJobKind?: boolean | bigJobKindDefaultArgs<ExtArgs>
    smallJobKind?: boolean | midJobKind$smallJobKindArgs<ExtArgs>
    _count?: boolean | MidJobKindCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["midJobKind"]>

  export type midJobKindSelectScalar = {
    id?: boolean
    bigJobKindId?: boolean
    name?: boolean
  }

  export type midJobKindInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | midJobKind$companyArgs<ExtArgs>
    bigJobKind?: boolean | bigJobKindDefaultArgs<ExtArgs>
    smallJobKind?: boolean | midJobKind$smallJobKindArgs<ExtArgs>
    _count?: boolean | MidJobKindCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $midJobKindPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "midJobKind"
    objects: {
      company: Prisma.$companyPayload<ExtArgs>[]
      bigJobKind: Prisma.$bigJobKindPayload<ExtArgs>
      smallJobKind: Prisma.$smallJobKindPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bigJobKindId: number
      name: string
    }, ExtArgs["result"]["midJobKind"]>
    composites: {}
  }


  type midJobKindGetPayload<S extends boolean | null | undefined | midJobKindDefaultArgs> = $Result.GetResult<Prisma.$midJobKindPayload, S>

  type midJobKindCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<midJobKindFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MidJobKindCountAggregateInputType | true
    }

  export interface midJobKindDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['midJobKind'], meta: { name: 'midJobKind' } }
    /**
     * Find zero or one MidJobKind that matches the filter.
     * @param {midJobKindFindUniqueArgs} args - Arguments to find a MidJobKind
     * @example
     * // Get one MidJobKind
     * const midJobKind = await prisma.midJobKind.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends midJobKindFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, midJobKindFindUniqueArgs<ExtArgs>>
    ): Prisma__midJobKindClient<$Result.GetResult<Prisma.$midJobKindPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one MidJobKind that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {midJobKindFindUniqueOrThrowArgs} args - Arguments to find a MidJobKind
     * @example
     * // Get one MidJobKind
     * const midJobKind = await prisma.midJobKind.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends midJobKindFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, midJobKindFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__midJobKindClient<$Result.GetResult<Prisma.$midJobKindPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first MidJobKind that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {midJobKindFindFirstArgs} args - Arguments to find a MidJobKind
     * @example
     * // Get one MidJobKind
     * const midJobKind = await prisma.midJobKind.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends midJobKindFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, midJobKindFindFirstArgs<ExtArgs>>
    ): Prisma__midJobKindClient<$Result.GetResult<Prisma.$midJobKindPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first MidJobKind that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {midJobKindFindFirstOrThrowArgs} args - Arguments to find a MidJobKind
     * @example
     * // Get one MidJobKind
     * const midJobKind = await prisma.midJobKind.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends midJobKindFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, midJobKindFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__midJobKindClient<$Result.GetResult<Prisma.$midJobKindPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more MidJobKinds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {midJobKindFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MidJobKinds
     * const midJobKinds = await prisma.midJobKind.findMany()
     * 
     * // Get first 10 MidJobKinds
     * const midJobKinds = await prisma.midJobKind.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const midJobKindWithIdOnly = await prisma.midJobKind.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends midJobKindFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, midJobKindFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$midJobKindPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a MidJobKind.
     * @param {midJobKindCreateArgs} args - Arguments to create a MidJobKind.
     * @example
     * // Create one MidJobKind
     * const MidJobKind = await prisma.midJobKind.create({
     *   data: {
     *     // ... data to create a MidJobKind
     *   }
     * })
     * 
    **/
    create<T extends midJobKindCreateArgs<ExtArgs>>(
      args: SelectSubset<T, midJobKindCreateArgs<ExtArgs>>
    ): Prisma__midJobKindClient<$Result.GetResult<Prisma.$midJobKindPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many MidJobKinds.
     *     @param {midJobKindCreateManyArgs} args - Arguments to create many MidJobKinds.
     *     @example
     *     // Create many MidJobKinds
     *     const midJobKind = await prisma.midJobKind.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends midJobKindCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, midJobKindCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MidJobKind.
     * @param {midJobKindDeleteArgs} args - Arguments to delete one MidJobKind.
     * @example
     * // Delete one MidJobKind
     * const MidJobKind = await prisma.midJobKind.delete({
     *   where: {
     *     // ... filter to delete one MidJobKind
     *   }
     * })
     * 
    **/
    delete<T extends midJobKindDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, midJobKindDeleteArgs<ExtArgs>>
    ): Prisma__midJobKindClient<$Result.GetResult<Prisma.$midJobKindPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one MidJobKind.
     * @param {midJobKindUpdateArgs} args - Arguments to update one MidJobKind.
     * @example
     * // Update one MidJobKind
     * const midJobKind = await prisma.midJobKind.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends midJobKindUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, midJobKindUpdateArgs<ExtArgs>>
    ): Prisma__midJobKindClient<$Result.GetResult<Prisma.$midJobKindPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more MidJobKinds.
     * @param {midJobKindDeleteManyArgs} args - Arguments to filter MidJobKinds to delete.
     * @example
     * // Delete a few MidJobKinds
     * const { count } = await prisma.midJobKind.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends midJobKindDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, midJobKindDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MidJobKinds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {midJobKindUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MidJobKinds
     * const midJobKind = await prisma.midJobKind.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends midJobKindUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, midJobKindUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MidJobKind.
     * @param {midJobKindUpsertArgs} args - Arguments to update or create a MidJobKind.
     * @example
     * // Update or create a MidJobKind
     * const midJobKind = await prisma.midJobKind.upsert({
     *   create: {
     *     // ... data to create a MidJobKind
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MidJobKind we want to update
     *   }
     * })
    **/
    upsert<T extends midJobKindUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, midJobKindUpsertArgs<ExtArgs>>
    ): Prisma__midJobKindClient<$Result.GetResult<Prisma.$midJobKindPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of MidJobKinds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {midJobKindCountArgs} args - Arguments to filter MidJobKinds to count.
     * @example
     * // Count the number of MidJobKinds
     * const count = await prisma.midJobKind.count({
     *   where: {
     *     // ... the filter for the MidJobKinds we want to count
     *   }
     * })
    **/
    count<T extends midJobKindCountArgs>(
      args?: Subset<T, midJobKindCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MidJobKindCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MidJobKind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MidJobKindAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MidJobKindAggregateArgs>(args: Subset<T, MidJobKindAggregateArgs>): Prisma.PrismaPromise<GetMidJobKindAggregateType<T>>

    /**
     * Group by MidJobKind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {midJobKindGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends midJobKindGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: midJobKindGroupByArgs['orderBy'] }
        : { orderBy?: midJobKindGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, midJobKindGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMidJobKindGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the midJobKind model
   */
  readonly fields: midJobKindFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for midJobKind.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__midJobKindClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends midJobKind$companyArgs<ExtArgs> = {}>(args?: Subset<T, midJobKind$companyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findMany'> | Null>;

    bigJobKind<T extends bigJobKindDefaultArgs<ExtArgs> = {}>(args?: Subset<T, bigJobKindDefaultArgs<ExtArgs>>): Prisma__bigJobKindClient<$Result.GetResult<Prisma.$bigJobKindPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    smallJobKind<T extends midJobKind$smallJobKindArgs<ExtArgs> = {}>(args?: Subset<T, midJobKind$smallJobKindArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$smallJobKindPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the midJobKind model
   */ 
  interface midJobKindFieldRefs {
    readonly id: FieldRef<"midJobKind", 'Int'>
    readonly bigJobKindId: FieldRef<"midJobKind", 'Int'>
    readonly name: FieldRef<"midJobKind", 'String'>
  }
    

  // Custom InputTypes

  /**
   * midJobKind findUnique
   */
  export type midJobKindFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midJobKind
     */
    select?: midJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: midJobKindInclude<ExtArgs> | null
    /**
     * Filter, which midJobKind to fetch.
     */
    where: midJobKindWhereUniqueInput
  }


  /**
   * midJobKind findUniqueOrThrow
   */
  export type midJobKindFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midJobKind
     */
    select?: midJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: midJobKindInclude<ExtArgs> | null
    /**
     * Filter, which midJobKind to fetch.
     */
    where: midJobKindWhereUniqueInput
  }


  /**
   * midJobKind findFirst
   */
  export type midJobKindFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midJobKind
     */
    select?: midJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: midJobKindInclude<ExtArgs> | null
    /**
     * Filter, which midJobKind to fetch.
     */
    where?: midJobKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of midJobKinds to fetch.
     */
    orderBy?: midJobKindOrderByWithRelationInput | midJobKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for midJobKinds.
     */
    cursor?: midJobKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` midJobKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` midJobKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of midJobKinds.
     */
    distinct?: MidJobKindScalarFieldEnum | MidJobKindScalarFieldEnum[]
  }


  /**
   * midJobKind findFirstOrThrow
   */
  export type midJobKindFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midJobKind
     */
    select?: midJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: midJobKindInclude<ExtArgs> | null
    /**
     * Filter, which midJobKind to fetch.
     */
    where?: midJobKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of midJobKinds to fetch.
     */
    orderBy?: midJobKindOrderByWithRelationInput | midJobKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for midJobKinds.
     */
    cursor?: midJobKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` midJobKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` midJobKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of midJobKinds.
     */
    distinct?: MidJobKindScalarFieldEnum | MidJobKindScalarFieldEnum[]
  }


  /**
   * midJobKind findMany
   */
  export type midJobKindFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midJobKind
     */
    select?: midJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: midJobKindInclude<ExtArgs> | null
    /**
     * Filter, which midJobKinds to fetch.
     */
    where?: midJobKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of midJobKinds to fetch.
     */
    orderBy?: midJobKindOrderByWithRelationInput | midJobKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing midJobKinds.
     */
    cursor?: midJobKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` midJobKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` midJobKinds.
     */
    skip?: number
    distinct?: MidJobKindScalarFieldEnum | MidJobKindScalarFieldEnum[]
  }


  /**
   * midJobKind create
   */
  export type midJobKindCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midJobKind
     */
    select?: midJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: midJobKindInclude<ExtArgs> | null
    /**
     * The data needed to create a midJobKind.
     */
    data: XOR<midJobKindCreateInput, midJobKindUncheckedCreateInput>
  }


  /**
   * midJobKind createMany
   */
  export type midJobKindCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many midJobKinds.
     */
    data: midJobKindCreateManyInput | midJobKindCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * midJobKind update
   */
  export type midJobKindUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midJobKind
     */
    select?: midJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: midJobKindInclude<ExtArgs> | null
    /**
     * The data needed to update a midJobKind.
     */
    data: XOR<midJobKindUpdateInput, midJobKindUncheckedUpdateInput>
    /**
     * Choose, which midJobKind to update.
     */
    where: midJobKindWhereUniqueInput
  }


  /**
   * midJobKind updateMany
   */
  export type midJobKindUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update midJobKinds.
     */
    data: XOR<midJobKindUpdateManyMutationInput, midJobKindUncheckedUpdateManyInput>
    /**
     * Filter which midJobKinds to update
     */
    where?: midJobKindWhereInput
  }


  /**
   * midJobKind upsert
   */
  export type midJobKindUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midJobKind
     */
    select?: midJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: midJobKindInclude<ExtArgs> | null
    /**
     * The filter to search for the midJobKind to update in case it exists.
     */
    where: midJobKindWhereUniqueInput
    /**
     * In case the midJobKind found by the `where` argument doesn't exist, create a new midJobKind with this data.
     */
    create: XOR<midJobKindCreateInput, midJobKindUncheckedCreateInput>
    /**
     * In case the midJobKind was found with the provided `where` argument, update it with this data.
     */
    update: XOR<midJobKindUpdateInput, midJobKindUncheckedUpdateInput>
  }


  /**
   * midJobKind delete
   */
  export type midJobKindDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midJobKind
     */
    select?: midJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: midJobKindInclude<ExtArgs> | null
    /**
     * Filter which midJobKind to delete.
     */
    where: midJobKindWhereUniqueInput
  }


  /**
   * midJobKind deleteMany
   */
  export type midJobKindDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which midJobKinds to delete
     */
    where?: midJobKindWhereInput
  }


  /**
   * midJobKind.company
   */
  export type midJobKind$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    where?: companyWhereInput
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    cursor?: companyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }


  /**
   * midJobKind.smallJobKind
   */
  export type midJobKind$smallJobKindArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallJobKind
     */
    select?: smallJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: smallJobKindInclude<ExtArgs> | null
    where?: smallJobKindWhereInput
    orderBy?: smallJobKindOrderByWithRelationInput | smallJobKindOrderByWithRelationInput[]
    cursor?: smallJobKindWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SmallJobKindScalarFieldEnum | SmallJobKindScalarFieldEnum[]
  }


  /**
   * midJobKind without action
   */
  export type midJobKindDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the midJobKind
     */
    select?: midJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: midJobKindInclude<ExtArgs> | null
  }



  /**
   * Model smallJobKind
   */

  export type AggregateSmallJobKind = {
    _count: SmallJobKindCountAggregateOutputType | null
    _avg: SmallJobKindAvgAggregateOutputType | null
    _sum: SmallJobKindSumAggregateOutputType | null
    _min: SmallJobKindMinAggregateOutputType | null
    _max: SmallJobKindMaxAggregateOutputType | null
  }

  export type SmallJobKindAvgAggregateOutputType = {
    id: number | null
    midJobKindId: number | null
  }

  export type SmallJobKindSumAggregateOutputType = {
    id: number | null
    midJobKindId: number | null
  }

  export type SmallJobKindMinAggregateOutputType = {
    id: number | null
    midJobKindId: number | null
    name: string | null
  }

  export type SmallJobKindMaxAggregateOutputType = {
    id: number | null
    midJobKindId: number | null
    name: string | null
  }

  export type SmallJobKindCountAggregateOutputType = {
    id: number
    midJobKindId: number
    name: number
    _all: number
  }


  export type SmallJobKindAvgAggregateInputType = {
    id?: true
    midJobKindId?: true
  }

  export type SmallJobKindSumAggregateInputType = {
    id?: true
    midJobKindId?: true
  }

  export type SmallJobKindMinAggregateInputType = {
    id?: true
    midJobKindId?: true
    name?: true
  }

  export type SmallJobKindMaxAggregateInputType = {
    id?: true
    midJobKindId?: true
    name?: true
  }

  export type SmallJobKindCountAggregateInputType = {
    id?: true
    midJobKindId?: true
    name?: true
    _all?: true
  }

  export type SmallJobKindAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which smallJobKind to aggregate.
     */
    where?: smallJobKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of smallJobKinds to fetch.
     */
    orderBy?: smallJobKindOrderByWithRelationInput | smallJobKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: smallJobKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` smallJobKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` smallJobKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned smallJobKinds
    **/
    _count?: true | SmallJobKindCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SmallJobKindAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SmallJobKindSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SmallJobKindMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SmallJobKindMaxAggregateInputType
  }

  export type GetSmallJobKindAggregateType<T extends SmallJobKindAggregateArgs> = {
        [P in keyof T & keyof AggregateSmallJobKind]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSmallJobKind[P]>
      : GetScalarType<T[P], AggregateSmallJobKind[P]>
  }




  export type smallJobKindGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: smallJobKindWhereInput
    orderBy?: smallJobKindOrderByWithAggregationInput | smallJobKindOrderByWithAggregationInput[]
    by: SmallJobKindScalarFieldEnum[] | SmallJobKindScalarFieldEnum
    having?: smallJobKindScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SmallJobKindCountAggregateInputType | true
    _avg?: SmallJobKindAvgAggregateInputType
    _sum?: SmallJobKindSumAggregateInputType
    _min?: SmallJobKindMinAggregateInputType
    _max?: SmallJobKindMaxAggregateInputType
  }

  export type SmallJobKindGroupByOutputType = {
    id: number
    midJobKindId: number
    name: string
    _count: SmallJobKindCountAggregateOutputType | null
    _avg: SmallJobKindAvgAggregateOutputType | null
    _sum: SmallJobKindSumAggregateOutputType | null
    _min: SmallJobKindMinAggregateOutputType | null
    _max: SmallJobKindMaxAggregateOutputType | null
  }

  type GetSmallJobKindGroupByPayload<T extends smallJobKindGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SmallJobKindGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SmallJobKindGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SmallJobKindGroupByOutputType[P]>
            : GetScalarType<T[P], SmallJobKindGroupByOutputType[P]>
        }
      >
    >


  export type smallJobKindSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    midJobKindId?: boolean
    name?: boolean
    company?: boolean | smallJobKind$companyArgs<ExtArgs>
    midJobKind?: boolean | midJobKindDefaultArgs<ExtArgs>
    _count?: boolean | SmallJobKindCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["smallJobKind"]>

  export type smallJobKindSelectScalar = {
    id?: boolean
    midJobKindId?: boolean
    name?: boolean
  }

  export type smallJobKindInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | smallJobKind$companyArgs<ExtArgs>
    midJobKind?: boolean | midJobKindDefaultArgs<ExtArgs>
    _count?: boolean | SmallJobKindCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $smallJobKindPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "smallJobKind"
    objects: {
      company: Prisma.$companyPayload<ExtArgs>[]
      midJobKind: Prisma.$midJobKindPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      midJobKindId: number
      name: string
    }, ExtArgs["result"]["smallJobKind"]>
    composites: {}
  }


  type smallJobKindGetPayload<S extends boolean | null | undefined | smallJobKindDefaultArgs> = $Result.GetResult<Prisma.$smallJobKindPayload, S>

  type smallJobKindCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<smallJobKindFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: SmallJobKindCountAggregateInputType | true
    }

  export interface smallJobKindDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['smallJobKind'], meta: { name: 'smallJobKind' } }
    /**
     * Find zero or one SmallJobKind that matches the filter.
     * @param {smallJobKindFindUniqueArgs} args - Arguments to find a SmallJobKind
     * @example
     * // Get one SmallJobKind
     * const smallJobKind = await prisma.smallJobKind.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends smallJobKindFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, smallJobKindFindUniqueArgs<ExtArgs>>
    ): Prisma__smallJobKindClient<$Result.GetResult<Prisma.$smallJobKindPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SmallJobKind that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {smallJobKindFindUniqueOrThrowArgs} args - Arguments to find a SmallJobKind
     * @example
     * // Get one SmallJobKind
     * const smallJobKind = await prisma.smallJobKind.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends smallJobKindFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, smallJobKindFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__smallJobKindClient<$Result.GetResult<Prisma.$smallJobKindPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SmallJobKind that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smallJobKindFindFirstArgs} args - Arguments to find a SmallJobKind
     * @example
     * // Get one SmallJobKind
     * const smallJobKind = await prisma.smallJobKind.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends smallJobKindFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, smallJobKindFindFirstArgs<ExtArgs>>
    ): Prisma__smallJobKindClient<$Result.GetResult<Prisma.$smallJobKindPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SmallJobKind that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smallJobKindFindFirstOrThrowArgs} args - Arguments to find a SmallJobKind
     * @example
     * // Get one SmallJobKind
     * const smallJobKind = await prisma.smallJobKind.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends smallJobKindFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, smallJobKindFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__smallJobKindClient<$Result.GetResult<Prisma.$smallJobKindPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SmallJobKinds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smallJobKindFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SmallJobKinds
     * const smallJobKinds = await prisma.smallJobKind.findMany()
     * 
     * // Get first 10 SmallJobKinds
     * const smallJobKinds = await prisma.smallJobKind.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const smallJobKindWithIdOnly = await prisma.smallJobKind.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends smallJobKindFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, smallJobKindFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$smallJobKindPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SmallJobKind.
     * @param {smallJobKindCreateArgs} args - Arguments to create a SmallJobKind.
     * @example
     * // Create one SmallJobKind
     * const SmallJobKind = await prisma.smallJobKind.create({
     *   data: {
     *     // ... data to create a SmallJobKind
     *   }
     * })
     * 
    **/
    create<T extends smallJobKindCreateArgs<ExtArgs>>(
      args: SelectSubset<T, smallJobKindCreateArgs<ExtArgs>>
    ): Prisma__smallJobKindClient<$Result.GetResult<Prisma.$smallJobKindPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SmallJobKinds.
     *     @param {smallJobKindCreateManyArgs} args - Arguments to create many SmallJobKinds.
     *     @example
     *     // Create many SmallJobKinds
     *     const smallJobKind = await prisma.smallJobKind.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends smallJobKindCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, smallJobKindCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SmallJobKind.
     * @param {smallJobKindDeleteArgs} args - Arguments to delete one SmallJobKind.
     * @example
     * // Delete one SmallJobKind
     * const SmallJobKind = await prisma.smallJobKind.delete({
     *   where: {
     *     // ... filter to delete one SmallJobKind
     *   }
     * })
     * 
    **/
    delete<T extends smallJobKindDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, smallJobKindDeleteArgs<ExtArgs>>
    ): Prisma__smallJobKindClient<$Result.GetResult<Prisma.$smallJobKindPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SmallJobKind.
     * @param {smallJobKindUpdateArgs} args - Arguments to update one SmallJobKind.
     * @example
     * // Update one SmallJobKind
     * const smallJobKind = await prisma.smallJobKind.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends smallJobKindUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, smallJobKindUpdateArgs<ExtArgs>>
    ): Prisma__smallJobKindClient<$Result.GetResult<Prisma.$smallJobKindPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SmallJobKinds.
     * @param {smallJobKindDeleteManyArgs} args - Arguments to filter SmallJobKinds to delete.
     * @example
     * // Delete a few SmallJobKinds
     * const { count } = await prisma.smallJobKind.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends smallJobKindDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, smallJobKindDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SmallJobKinds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smallJobKindUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SmallJobKinds
     * const smallJobKind = await prisma.smallJobKind.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends smallJobKindUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, smallJobKindUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SmallJobKind.
     * @param {smallJobKindUpsertArgs} args - Arguments to update or create a SmallJobKind.
     * @example
     * // Update or create a SmallJobKind
     * const smallJobKind = await prisma.smallJobKind.upsert({
     *   create: {
     *     // ... data to create a SmallJobKind
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SmallJobKind we want to update
     *   }
     * })
    **/
    upsert<T extends smallJobKindUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, smallJobKindUpsertArgs<ExtArgs>>
    ): Prisma__smallJobKindClient<$Result.GetResult<Prisma.$smallJobKindPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of SmallJobKinds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smallJobKindCountArgs} args - Arguments to filter SmallJobKinds to count.
     * @example
     * // Count the number of SmallJobKinds
     * const count = await prisma.smallJobKind.count({
     *   where: {
     *     // ... the filter for the SmallJobKinds we want to count
     *   }
     * })
    **/
    count<T extends smallJobKindCountArgs>(
      args?: Subset<T, smallJobKindCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SmallJobKindCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SmallJobKind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SmallJobKindAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SmallJobKindAggregateArgs>(args: Subset<T, SmallJobKindAggregateArgs>): Prisma.PrismaPromise<GetSmallJobKindAggregateType<T>>

    /**
     * Group by SmallJobKind.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {smallJobKindGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends smallJobKindGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: smallJobKindGroupByArgs['orderBy'] }
        : { orderBy?: smallJobKindGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, smallJobKindGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSmallJobKindGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the smallJobKind model
   */
  readonly fields: smallJobKindFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for smallJobKind.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__smallJobKindClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    company<T extends smallJobKind$companyArgs<ExtArgs> = {}>(args?: Subset<T, smallJobKind$companyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyPayload<ExtArgs>, T, 'findMany'> | Null>;

    midJobKind<T extends midJobKindDefaultArgs<ExtArgs> = {}>(args?: Subset<T, midJobKindDefaultArgs<ExtArgs>>): Prisma__midJobKindClient<$Result.GetResult<Prisma.$midJobKindPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the smallJobKind model
   */ 
  interface smallJobKindFieldRefs {
    readonly id: FieldRef<"smallJobKind", 'Int'>
    readonly midJobKindId: FieldRef<"smallJobKind", 'Int'>
    readonly name: FieldRef<"smallJobKind", 'String'>
  }
    

  // Custom InputTypes

  /**
   * smallJobKind findUnique
   */
  export type smallJobKindFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallJobKind
     */
    select?: smallJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: smallJobKindInclude<ExtArgs> | null
    /**
     * Filter, which smallJobKind to fetch.
     */
    where: smallJobKindWhereUniqueInput
  }


  /**
   * smallJobKind findUniqueOrThrow
   */
  export type smallJobKindFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallJobKind
     */
    select?: smallJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: smallJobKindInclude<ExtArgs> | null
    /**
     * Filter, which smallJobKind to fetch.
     */
    where: smallJobKindWhereUniqueInput
  }


  /**
   * smallJobKind findFirst
   */
  export type smallJobKindFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallJobKind
     */
    select?: smallJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: smallJobKindInclude<ExtArgs> | null
    /**
     * Filter, which smallJobKind to fetch.
     */
    where?: smallJobKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of smallJobKinds to fetch.
     */
    orderBy?: smallJobKindOrderByWithRelationInput | smallJobKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for smallJobKinds.
     */
    cursor?: smallJobKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` smallJobKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` smallJobKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of smallJobKinds.
     */
    distinct?: SmallJobKindScalarFieldEnum | SmallJobKindScalarFieldEnum[]
  }


  /**
   * smallJobKind findFirstOrThrow
   */
  export type smallJobKindFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallJobKind
     */
    select?: smallJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: smallJobKindInclude<ExtArgs> | null
    /**
     * Filter, which smallJobKind to fetch.
     */
    where?: smallJobKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of smallJobKinds to fetch.
     */
    orderBy?: smallJobKindOrderByWithRelationInput | smallJobKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for smallJobKinds.
     */
    cursor?: smallJobKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` smallJobKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` smallJobKinds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of smallJobKinds.
     */
    distinct?: SmallJobKindScalarFieldEnum | SmallJobKindScalarFieldEnum[]
  }


  /**
   * smallJobKind findMany
   */
  export type smallJobKindFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallJobKind
     */
    select?: smallJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: smallJobKindInclude<ExtArgs> | null
    /**
     * Filter, which smallJobKinds to fetch.
     */
    where?: smallJobKindWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of smallJobKinds to fetch.
     */
    orderBy?: smallJobKindOrderByWithRelationInput | smallJobKindOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing smallJobKinds.
     */
    cursor?: smallJobKindWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` smallJobKinds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` smallJobKinds.
     */
    skip?: number
    distinct?: SmallJobKindScalarFieldEnum | SmallJobKindScalarFieldEnum[]
  }


  /**
   * smallJobKind create
   */
  export type smallJobKindCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallJobKind
     */
    select?: smallJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: smallJobKindInclude<ExtArgs> | null
    /**
     * The data needed to create a smallJobKind.
     */
    data: XOR<smallJobKindCreateInput, smallJobKindUncheckedCreateInput>
  }


  /**
   * smallJobKind createMany
   */
  export type smallJobKindCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many smallJobKinds.
     */
    data: smallJobKindCreateManyInput | smallJobKindCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * smallJobKind update
   */
  export type smallJobKindUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallJobKind
     */
    select?: smallJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: smallJobKindInclude<ExtArgs> | null
    /**
     * The data needed to update a smallJobKind.
     */
    data: XOR<smallJobKindUpdateInput, smallJobKindUncheckedUpdateInput>
    /**
     * Choose, which smallJobKind to update.
     */
    where: smallJobKindWhereUniqueInput
  }


  /**
   * smallJobKind updateMany
   */
  export type smallJobKindUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update smallJobKinds.
     */
    data: XOR<smallJobKindUpdateManyMutationInput, smallJobKindUncheckedUpdateManyInput>
    /**
     * Filter which smallJobKinds to update
     */
    where?: smallJobKindWhereInput
  }


  /**
   * smallJobKind upsert
   */
  export type smallJobKindUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallJobKind
     */
    select?: smallJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: smallJobKindInclude<ExtArgs> | null
    /**
     * The filter to search for the smallJobKind to update in case it exists.
     */
    where: smallJobKindWhereUniqueInput
    /**
     * In case the smallJobKind found by the `where` argument doesn't exist, create a new smallJobKind with this data.
     */
    create: XOR<smallJobKindCreateInput, smallJobKindUncheckedCreateInput>
    /**
     * In case the smallJobKind was found with the provided `where` argument, update it with this data.
     */
    update: XOR<smallJobKindUpdateInput, smallJobKindUncheckedUpdateInput>
  }


  /**
   * smallJobKind delete
   */
  export type smallJobKindDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallJobKind
     */
    select?: smallJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: smallJobKindInclude<ExtArgs> | null
    /**
     * Filter which smallJobKind to delete.
     */
    where: smallJobKindWhereUniqueInput
  }


  /**
   * smallJobKind deleteMany
   */
  export type smallJobKindDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which smallJobKinds to delete
     */
    where?: smallJobKindWhereInput
  }


  /**
   * smallJobKind.company
   */
  export type smallJobKind$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company
     */
    select?: companySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: companyInclude<ExtArgs> | null
    where?: companyWhereInput
    orderBy?: companyOrderByWithRelationInput | companyOrderByWithRelationInput[]
    cursor?: companyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }


  /**
   * smallJobKind without action
   */
  export type smallJobKindDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the smallJobKind
     */
    select?: smallJobKindSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: smallJobKindInclude<ExtArgs> | null
  }



  /**
   * Model job
   */

  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobAvgAggregateOutputType = {
    id: number | null
    clusteringGroup: number | null
  }

  export type JobSumAggregateOutputType = {
    id: number | null
    clusteringGroup: number | null
  }

  export type JobMinAggregateOutputType = {
    id: number | null
    clusteringGroup: number | null
    name: string | null
  }

  export type JobMaxAggregateOutputType = {
    id: number | null
    clusteringGroup: number | null
    name: string | null
  }

  export type JobCountAggregateOutputType = {
    id: number
    clusteringGroup: number
    name: number
    _all: number
  }


  export type JobAvgAggregateInputType = {
    id?: true
    clusteringGroup?: true
  }

  export type JobSumAggregateInputType = {
    id?: true
    clusteringGroup?: true
  }

  export type JobMinAggregateInputType = {
    id?: true
    clusteringGroup?: true
    name?: true
  }

  export type JobMaxAggregateInputType = {
    id?: true
    clusteringGroup?: true
    name?: true
  }

  export type JobCountAggregateInputType = {
    id?: true
    clusteringGroup?: true
    name?: true
    _all?: true
  }

  export type JobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job to aggregate.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type jobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobWhereInput
    orderBy?: jobOrderByWithAggregationInput | jobOrderByWithAggregationInput[]
    by: JobScalarFieldEnum[] | JobScalarFieldEnum
    having?: jobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _avg?: JobAvgAggregateInputType
    _sum?: JobSumAggregateInputType
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }

  export type JobGroupByOutputType = {
    id: number
    clusteringGroup: number
    name: string
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends jobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type jobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clusteringGroup?: boolean
    name?: boolean
    incumebent?: boolean | job$incumebentArgs<ExtArgs>
    student?: boolean | job$studentArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>

  export type jobSelectScalar = {
    id?: boolean
    clusteringGroup?: boolean
    name?: boolean
  }

  export type jobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    incumebent?: boolean | job$incumebentArgs<ExtArgs>
    student?: boolean | job$studentArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $jobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job"
    objects: {
      incumebent: Prisma.$incumbentsAdditionalPayload<ExtArgs>[]
      student: Prisma.$studentsAdditionalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      clusteringGroup: number
      name: string
    }, ExtArgs["result"]["job"]>
    composites: {}
  }


  type jobGetPayload<S extends boolean | null | undefined | jobDefaultArgs> = $Result.GetResult<Prisma.$jobPayload, S>

  type jobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<jobFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: JobCountAggregateInputType | true
    }

  export interface jobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job'], meta: { name: 'job' } }
    /**
     * Find zero or one Job that matches the filter.
     * @param {jobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends jobFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, jobFindUniqueArgs<ExtArgs>>
    ): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Job that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {jobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends jobFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, jobFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends jobFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, jobFindFirstArgs<ExtArgs>>
    ): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends jobFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, jobFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobWithIdOnly = await prisma.job.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends jobFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, jobFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Job.
     * @param {jobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
    **/
    create<T extends jobCreateArgs<ExtArgs>>(
      args: SelectSubset<T, jobCreateArgs<ExtArgs>>
    ): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Jobs.
     *     @param {jobCreateManyArgs} args - Arguments to create many Jobs.
     *     @example
     *     // Create many Jobs
     *     const job = await prisma.job.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends jobCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, jobCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Job.
     * @param {jobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
    **/
    delete<T extends jobDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, jobDeleteArgs<ExtArgs>>
    ): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Job.
     * @param {jobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends jobUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, jobUpdateArgs<ExtArgs>>
    ): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Jobs.
     * @param {jobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends jobDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, jobDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends jobUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, jobUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Job.
     * @param {jobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
    **/
    upsert<T extends jobUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, jobUpsertArgs<ExtArgs>>
    ): Prisma__jobClient<$Result.GetResult<Prisma.$jobPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends jobCountArgs>(
      args?: Subset<T, jobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): Prisma.PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jobGroupByArgs['orderBy'] }
        : { orderBy?: jobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job model
   */
  readonly fields: jobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    incumebent<T extends job$incumebentArgs<ExtArgs> = {}>(args?: Subset<T, job$incumebentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$incumbentsAdditionalPayload<ExtArgs>, T, 'findMany'> | Null>;

    student<T extends job$studentArgs<ExtArgs> = {}>(args?: Subset<T, job$studentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$studentsAdditionalPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the job model
   */ 
  interface jobFieldRefs {
    readonly id: FieldRef<"job", 'Int'>
    readonly clusteringGroup: FieldRef<"job", 'Int'>
    readonly name: FieldRef<"job", 'String'>
  }
    

  // Custom InputTypes

  /**
   * job findUnique
   */
  export type jobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where: jobWhereUniqueInput
  }


  /**
   * job findUniqueOrThrow
   */
  export type jobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where: jobWhereUniqueInput
  }


  /**
   * job findFirst
   */
  export type jobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }


  /**
   * job findFirstOrThrow
   */
  export type jobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which job to fetch.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }


  /**
   * job findMany
   */
  export type jobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobOrderByWithRelationInput | jobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jobs.
     */
    cursor?: jobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }


  /**
   * job create
   */
  export type jobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * The data needed to create a job.
     */
    data: XOR<jobCreateInput, jobUncheckedCreateInput>
  }


  /**
   * job createMany
   */
  export type jobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jobs.
     */
    data: jobCreateManyInput | jobCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * job update
   */
  export type jobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * The data needed to update a job.
     */
    data: XOR<jobUpdateInput, jobUncheckedUpdateInput>
    /**
     * Choose, which job to update.
     */
    where: jobWhereUniqueInput
  }


  /**
   * job updateMany
   */
  export type jobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jobs.
     */
    data: XOR<jobUpdateManyMutationInput, jobUncheckedUpdateManyInput>
    /**
     * Filter which jobs to update
     */
    where?: jobWhereInput
  }


  /**
   * job upsert
   */
  export type jobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * The filter to search for the job to update in case it exists.
     */
    where: jobWhereUniqueInput
    /**
     * In case the job found by the `where` argument doesn't exist, create a new job with this data.
     */
    create: XOR<jobCreateInput, jobUncheckedCreateInput>
    /**
     * In case the job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jobUpdateInput, jobUncheckedUpdateInput>
  }


  /**
   * job delete
   */
  export type jobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: jobInclude<ExtArgs> | null
    /**
     * Filter which job to delete.
     */
    where: jobWhereUniqueInput
  }


  /**
   * job deleteMany
   */
  export type jobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobs to delete
     */
    where?: jobWhereInput
  }


  /**
   * job.incumebent
   */
  export type job$incumebentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the incumbentsAdditional
     */
    select?: incumbentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incumbentsAdditionalInclude<ExtArgs> | null
    where?: incumbentsAdditionalWhereInput
    orderBy?: incumbentsAdditionalOrderByWithRelationInput | incumbentsAdditionalOrderByWithRelationInput[]
    cursor?: incumbentsAdditionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IncumbentsAdditionalScalarFieldEnum | IncumbentsAdditionalScalarFieldEnum[]
  }


  /**
   * job.student
   */
  export type job$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the studentsAdditional
     */
    select?: studentsAdditionalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: studentsAdditionalInclude<ExtArgs> | null
    where?: studentsAdditionalWhereInput
    orderBy?: studentsAdditionalOrderByWithRelationInput | studentsAdditionalOrderByWithRelationInput[]
    cursor?: studentsAdditionalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentsAdditionalScalarFieldEnum | StudentsAdditionalScalarFieldEnum[]
  }


  /**
   * job without action
   */
  export type jobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job
     */
    select?: jobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: jobInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    age: 'age',
    gender: 'gender',
    image: 'image',
    type: 'type',
    createdDate: 'createdDate',
    updatedDate: 'updatedDate'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const IncumbentsAdditionalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    schoolId: 'schoolId',
    majorId: 'majorId',
    bigJobId: 'bigJobId',
    midJobId: 'midJobId',
    smallJobId: 'smallJobId',
    jobId: 'jobId',
    shortSpec: 'shortSpec',
    reportedNum: 'reportedNum',
    adviceCount: 'adviceCount',
    estimationCount: 'estimationCount',
    updatedDate: 'updatedDate'
  };

  export type IncumbentsAdditionalScalarFieldEnum = (typeof IncumbentsAdditionalScalarFieldEnum)[keyof typeof IncumbentsAdditionalScalarFieldEnum]


  export const StudentsAdditionalScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    wishCompanyId: 'wishCompanyId',
    schoolId: 'schoolId',
    majorId: 'majorId',
    wishBigJobId: 'wishBigJobId',
    wishMidJobId: 'wishMidJobId',
    wishSmallJobId: 'wishSmallJobId',
    wishJobId: 'wishJobId',
    portfolio: 'portfolio',
    reportedNum: 'reportedNum',
    totalGrade: 'totalGrade',
    adviceCount: 'adviceCount',
    estimationCount: 'estimationCount',
    updatedDate: 'updatedDate'
  };

  export type StudentsAdditionalScalarFieldEnum = (typeof StudentsAdditionalScalarFieldEnum)[keyof typeof StudentsAdditionalScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const PostsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    categoryId: 'categoryId',
    title: 'title',
    content: 'content',
    view: 'view',
    recommend: 'recommend',
    reported: 'reported',
    createdDate: 'createdDate',
    updatedDate: 'updatedDate'
  };

  export type PostsScalarFieldEnum = (typeof PostsScalarFieldEnum)[keyof typeof PostsScalarFieldEnum]


  export const CommentsScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    content: 'content',
    parentCommentId: 'parentCommentId',
    recommend: 'recommend',
    reported: 'reported',
    createdDate: 'createdDate',
    updatedDate: 'updatedDate',
    isDelete: 'isDelete'
  };

  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]


  export const RecommendPostsScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    createdDate: 'createdDate'
  };

  export type RecommendPostsScalarFieldEnum = (typeof RecommendPostsScalarFieldEnum)[keyof typeof RecommendPostsScalarFieldEnum]


  export const ReportedPostsScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    reason: 'reason',
    createdDate: 'createdDate'
  };

  export type ReportedPostsScalarFieldEnum = (typeof ReportedPostsScalarFieldEnum)[keyof typeof ReportedPostsScalarFieldEnum]


  export const RecommendCommentsScalarFieldEnum: {
    id: 'id',
    commentId: 'commentId',
    userId: 'userId',
    createdDate: 'createdDate'
  };

  export type RecommendCommentsScalarFieldEnum = (typeof RecommendCommentsScalarFieldEnum)[keyof typeof RecommendCommentsScalarFieldEnum]


  export const ReportedCommentsScalarFieldEnum: {
    id: 'id',
    commentId: 'commentId',
    userId: 'userId',
    reason: 'reason',
    createdDate: 'createdDate'
  };

  export type ReportedCommentsScalarFieldEnum = (typeof ReportedCommentsScalarFieldEnum)[keyof typeof ReportedCommentsScalarFieldEnum]


  export const ReportedUsersScalarFieldEnum: {
    id: 'id',
    targetUserId: 'targetUserId',
    reportingUserId: 'reportingUserId',
    reason: 'reason',
    createdDate: 'createdDate'
  };

  export type ReportedUsersScalarFieldEnum = (typeof ReportedUsersScalarFieldEnum)[keyof typeof ReportedUsersScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    longitude: 'longitude',
    latitude: 'latitude',
    scale: 'scale',
    bigJobKindId: 'bigJobKindId',
    midJobKindId: 'midJobKindId',
    smallJobKindId: 'smallJobKindId'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const SchoolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    branch: 'branch'
  };

  export type SchoolScalarFieldEnum = (typeof SchoolScalarFieldEnum)[keyof typeof SchoolScalarFieldEnum]


  export const MajorScalarFieldEnum: {
    id: 'id',
    schoolId: 'schoolId',
    name: 'name',
    dayAndNight: 'dayAndNight'
  };

  export type MajorScalarFieldEnum = (typeof MajorScalarFieldEnum)[keyof typeof MajorScalarFieldEnum]


  export const BigJobKindScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type BigJobKindScalarFieldEnum = (typeof BigJobKindScalarFieldEnum)[keyof typeof BigJobKindScalarFieldEnum]


  export const MidJobKindScalarFieldEnum: {
    id: 'id',
    bigJobKindId: 'bigJobKindId',
    name: 'name'
  };

  export type MidJobKindScalarFieldEnum = (typeof MidJobKindScalarFieldEnum)[keyof typeof MidJobKindScalarFieldEnum]


  export const SmallJobKindScalarFieldEnum: {
    id: 'id',
    midJobKindId: 'midJobKindId',
    name: 'name'
  };

  export type SmallJobKindScalarFieldEnum = (typeof SmallJobKindScalarFieldEnum)[keyof typeof SmallJobKindScalarFieldEnum]


  export const JobScalarFieldEnum: {
    id: 'id',
    clusteringGroup: 'clusteringGroup',
    name: 'name'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'userType'
   */
  export type EnumuserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'userType'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    name?: StringFilter<"users"> | string
    age?: IntFilter<"users"> | number
    gender?: EnumGenderFilter<"users"> | $Enums.Gender
    image?: StringNullableFilter<"users"> | string | null
    type?: EnumuserTypeFilter<"users"> | $Enums.userType
    createdDate?: DateTimeFilter<"users"> | Date | string
    updatedDate?: DateTimeFilter<"users"> | Date | string
    incumbent_additional?: XOR<IncumbentsAdditionalNullableRelationFilter, incumbentsAdditionalWhereInput> | null
    student_additional?: XOR<StudentsAdditionalNullableRelationFilter, studentsAdditionalWhereInput> | null
    posts?: PostsListRelationFilter
    comments?: CommentsListRelationFilter
    recommend_posts?: RecommendPostsListRelationFilter
    recommend_comments?: RecommendCommentsListRelationFilter
    reported_posts?: ReportedPostsListRelationFilter
    reported_comments?: ReportedCommentsListRelationFilter
    reported_users?: ReportedUsersListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    image?: SortOrderInput | SortOrder
    type?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
    incumbent_additional?: incumbentsAdditionalOrderByWithRelationInput
    student_additional?: studentsAdditionalOrderByWithRelationInput
    posts?: postsOrderByRelationAggregateInput
    comments?: commentsOrderByRelationAggregateInput
    recommend_posts?: recommendPostsOrderByRelationAggregateInput
    recommend_comments?: recommendCommentsOrderByRelationAggregateInput
    reported_posts?: reportedPostsOrderByRelationAggregateInput
    reported_comments?: reportedCommentsOrderByRelationAggregateInput
    reported_users?: reportedUsersOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    password?: StringFilter<"users"> | string
    name?: StringFilter<"users"> | string
    age?: IntFilter<"users"> | number
    gender?: EnumGenderFilter<"users"> | $Enums.Gender
    image?: StringNullableFilter<"users"> | string | null
    type?: EnumuserTypeFilter<"users"> | $Enums.userType
    createdDate?: DateTimeFilter<"users"> | Date | string
    updatedDate?: DateTimeFilter<"users"> | Date | string
    incumbent_additional?: XOR<IncumbentsAdditionalNullableRelationFilter, incumbentsAdditionalWhereInput> | null
    student_additional?: XOR<StudentsAdditionalNullableRelationFilter, studentsAdditionalWhereInput> | null
    posts?: PostsListRelationFilter
    comments?: CommentsListRelationFilter
    recommend_posts?: RecommendPostsListRelationFilter
    recommend_comments?: RecommendCommentsListRelationFilter
    reported_posts?: ReportedPostsListRelationFilter
    reported_comments?: ReportedCommentsListRelationFilter
    reported_users?: ReportedUsersListRelationFilter
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    image?: SortOrderInput | SortOrder
    type?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    email?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    name?: StringWithAggregatesFilter<"users"> | string
    age?: IntWithAggregatesFilter<"users"> | number
    gender?: EnumGenderWithAggregatesFilter<"users"> | $Enums.Gender
    image?: StringNullableWithAggregatesFilter<"users"> | string | null
    type?: EnumuserTypeWithAggregatesFilter<"users"> | $Enums.userType
    createdDate?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedDate?: DateTimeWithAggregatesFilter<"users"> | Date | string
  }

  export type incumbentsAdditionalWhereInput = {
    AND?: incumbentsAdditionalWhereInput | incumbentsAdditionalWhereInput[]
    OR?: incumbentsAdditionalWhereInput[]
    NOT?: incumbentsAdditionalWhereInput | incumbentsAdditionalWhereInput[]
    id?: IntFilter<"incumbentsAdditional"> | number
    userId?: IntFilter<"incumbentsAdditional"> | number
    companyId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    schoolId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    majorId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    bigJobId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    midJobId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    smallJobId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    jobId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    shortSpec?: StringNullableFilter<"incumbentsAdditional"> | string | null
    reportedNum?: IntFilter<"incumbentsAdditional"> | number
    adviceCount?: IntFilter<"incumbentsAdditional"> | number
    estimationCount?: FloatFilter<"incumbentsAdditional"> | number
    updatedDate?: DateTimeFilter<"incumbentsAdditional"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    company?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
    school?: XOR<SchoolNullableRelationFilter, schoolWhereInput> | null
    major?: XOR<MajorNullableRelationFilter, majorWhereInput> | null
    job?: XOR<JobNullableRelationFilter, jobWhereInput> | null
  }

  export type incumbentsAdditionalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    majorId?: SortOrderInput | SortOrder
    bigJobId?: SortOrderInput | SortOrder
    midJobId?: SortOrderInput | SortOrder
    smallJobId?: SortOrderInput | SortOrder
    jobId?: SortOrderInput | SortOrder
    shortSpec?: SortOrderInput | SortOrder
    reportedNum?: SortOrder
    adviceCount?: SortOrder
    estimationCount?: SortOrder
    updatedDate?: SortOrder
    users?: usersOrderByWithRelationInput
    company?: companyOrderByWithRelationInput
    school?: schoolOrderByWithRelationInput
    major?: majorOrderByWithRelationInput
    job?: jobOrderByWithRelationInput
  }

  export type incumbentsAdditionalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: incumbentsAdditionalWhereInput | incumbentsAdditionalWhereInput[]
    OR?: incumbentsAdditionalWhereInput[]
    NOT?: incumbentsAdditionalWhereInput | incumbentsAdditionalWhereInput[]
    companyId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    schoolId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    majorId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    bigJobId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    midJobId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    smallJobId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    jobId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    shortSpec?: StringNullableFilter<"incumbentsAdditional"> | string | null
    reportedNum?: IntFilter<"incumbentsAdditional"> | number
    adviceCount?: IntFilter<"incumbentsAdditional"> | number
    estimationCount?: FloatFilter<"incumbentsAdditional"> | number
    updatedDate?: DateTimeFilter<"incumbentsAdditional"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    company?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
    school?: XOR<SchoolNullableRelationFilter, schoolWhereInput> | null
    major?: XOR<MajorNullableRelationFilter, majorWhereInput> | null
    job?: XOR<JobNullableRelationFilter, jobWhereInput> | null
  }, "id" | "userId">

  export type incumbentsAdditionalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    majorId?: SortOrderInput | SortOrder
    bigJobId?: SortOrderInput | SortOrder
    midJobId?: SortOrderInput | SortOrder
    smallJobId?: SortOrderInput | SortOrder
    jobId?: SortOrderInput | SortOrder
    shortSpec?: SortOrderInput | SortOrder
    reportedNum?: SortOrder
    adviceCount?: SortOrder
    estimationCount?: SortOrder
    updatedDate?: SortOrder
    _count?: incumbentsAdditionalCountOrderByAggregateInput
    _avg?: incumbentsAdditionalAvgOrderByAggregateInput
    _max?: incumbentsAdditionalMaxOrderByAggregateInput
    _min?: incumbentsAdditionalMinOrderByAggregateInput
    _sum?: incumbentsAdditionalSumOrderByAggregateInput
  }

  export type incumbentsAdditionalScalarWhereWithAggregatesInput = {
    AND?: incumbentsAdditionalScalarWhereWithAggregatesInput | incumbentsAdditionalScalarWhereWithAggregatesInput[]
    OR?: incumbentsAdditionalScalarWhereWithAggregatesInput[]
    NOT?: incumbentsAdditionalScalarWhereWithAggregatesInput | incumbentsAdditionalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"incumbentsAdditional"> | number
    userId?: IntWithAggregatesFilter<"incumbentsAdditional"> | number
    companyId?: IntNullableWithAggregatesFilter<"incumbentsAdditional"> | number | null
    schoolId?: IntNullableWithAggregatesFilter<"incumbentsAdditional"> | number | null
    majorId?: IntNullableWithAggregatesFilter<"incumbentsAdditional"> | number | null
    bigJobId?: IntNullableWithAggregatesFilter<"incumbentsAdditional"> | number | null
    midJobId?: IntNullableWithAggregatesFilter<"incumbentsAdditional"> | number | null
    smallJobId?: IntNullableWithAggregatesFilter<"incumbentsAdditional"> | number | null
    jobId?: IntNullableWithAggregatesFilter<"incumbentsAdditional"> | number | null
    shortSpec?: StringNullableWithAggregatesFilter<"incumbentsAdditional"> | string | null
    reportedNum?: IntWithAggregatesFilter<"incumbentsAdditional"> | number
    adviceCount?: IntWithAggregatesFilter<"incumbentsAdditional"> | number
    estimationCount?: FloatWithAggregatesFilter<"incumbentsAdditional"> | number
    updatedDate?: DateTimeWithAggregatesFilter<"incumbentsAdditional"> | Date | string
  }

  export type studentsAdditionalWhereInput = {
    AND?: studentsAdditionalWhereInput | studentsAdditionalWhereInput[]
    OR?: studentsAdditionalWhereInput[]
    NOT?: studentsAdditionalWhereInput | studentsAdditionalWhereInput[]
    id?: IntFilter<"studentsAdditional"> | number
    userId?: IntFilter<"studentsAdditional"> | number
    wishCompanyId?: IntNullableFilter<"studentsAdditional"> | number | null
    schoolId?: IntNullableFilter<"studentsAdditional"> | number | null
    majorId?: IntNullableFilter<"studentsAdditional"> | number | null
    wishBigJobId?: IntNullableFilter<"studentsAdditional"> | number | null
    wishMidJobId?: IntNullableFilter<"studentsAdditional"> | number | null
    wishSmallJobId?: IntNullableFilter<"studentsAdditional"> | number | null
    wishJobId?: IntNullableFilter<"studentsAdditional"> | number | null
    portfolio?: StringNullableFilter<"studentsAdditional"> | string | null
    reportedNum?: IntFilter<"studentsAdditional"> | number
    totalGrade?: FloatNullableFilter<"studentsAdditional"> | number | null
    adviceCount?: IntFilter<"studentsAdditional"> | number
    estimationCount?: FloatFilter<"studentsAdditional"> | number
    updatedDate?: DateTimeFilter<"studentsAdditional"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    wishCompany?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
    school?: XOR<SchoolNullableRelationFilter, schoolWhereInput> | null
    major?: XOR<MajorNullableRelationFilter, majorWhereInput> | null
    wishJob?: XOR<JobNullableRelationFilter, jobWhereInput> | null
  }

  export type studentsAdditionalOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    wishCompanyId?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    majorId?: SortOrderInput | SortOrder
    wishBigJobId?: SortOrderInput | SortOrder
    wishMidJobId?: SortOrderInput | SortOrder
    wishSmallJobId?: SortOrderInput | SortOrder
    wishJobId?: SortOrderInput | SortOrder
    portfolio?: SortOrderInput | SortOrder
    reportedNum?: SortOrder
    totalGrade?: SortOrderInput | SortOrder
    adviceCount?: SortOrder
    estimationCount?: SortOrder
    updatedDate?: SortOrder
    users?: usersOrderByWithRelationInput
    wishCompany?: companyOrderByWithRelationInput
    school?: schoolOrderByWithRelationInput
    major?: majorOrderByWithRelationInput
    wishJob?: jobOrderByWithRelationInput
  }

  export type studentsAdditionalWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: studentsAdditionalWhereInput | studentsAdditionalWhereInput[]
    OR?: studentsAdditionalWhereInput[]
    NOT?: studentsAdditionalWhereInput | studentsAdditionalWhereInput[]
    wishCompanyId?: IntNullableFilter<"studentsAdditional"> | number | null
    schoolId?: IntNullableFilter<"studentsAdditional"> | number | null
    majorId?: IntNullableFilter<"studentsAdditional"> | number | null
    wishBigJobId?: IntNullableFilter<"studentsAdditional"> | number | null
    wishMidJobId?: IntNullableFilter<"studentsAdditional"> | number | null
    wishSmallJobId?: IntNullableFilter<"studentsAdditional"> | number | null
    wishJobId?: IntNullableFilter<"studentsAdditional"> | number | null
    portfolio?: StringNullableFilter<"studentsAdditional"> | string | null
    reportedNum?: IntFilter<"studentsAdditional"> | number
    totalGrade?: FloatNullableFilter<"studentsAdditional"> | number | null
    adviceCount?: IntFilter<"studentsAdditional"> | number
    estimationCount?: FloatFilter<"studentsAdditional"> | number
    updatedDate?: DateTimeFilter<"studentsAdditional"> | Date | string
    users?: XOR<UsersRelationFilter, usersWhereInput>
    wishCompany?: XOR<CompanyNullableRelationFilter, companyWhereInput> | null
    school?: XOR<SchoolNullableRelationFilter, schoolWhereInput> | null
    major?: XOR<MajorNullableRelationFilter, majorWhereInput> | null
    wishJob?: XOR<JobNullableRelationFilter, jobWhereInput> | null
  }, "id" | "userId">

  export type studentsAdditionalOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    wishCompanyId?: SortOrderInput | SortOrder
    schoolId?: SortOrderInput | SortOrder
    majorId?: SortOrderInput | SortOrder
    wishBigJobId?: SortOrderInput | SortOrder
    wishMidJobId?: SortOrderInput | SortOrder
    wishSmallJobId?: SortOrderInput | SortOrder
    wishJobId?: SortOrderInput | SortOrder
    portfolio?: SortOrderInput | SortOrder
    reportedNum?: SortOrder
    totalGrade?: SortOrderInput | SortOrder
    adviceCount?: SortOrder
    estimationCount?: SortOrder
    updatedDate?: SortOrder
    _count?: studentsAdditionalCountOrderByAggregateInput
    _avg?: studentsAdditionalAvgOrderByAggregateInput
    _max?: studentsAdditionalMaxOrderByAggregateInput
    _min?: studentsAdditionalMinOrderByAggregateInput
    _sum?: studentsAdditionalSumOrderByAggregateInput
  }

  export type studentsAdditionalScalarWhereWithAggregatesInput = {
    AND?: studentsAdditionalScalarWhereWithAggregatesInput | studentsAdditionalScalarWhereWithAggregatesInput[]
    OR?: studentsAdditionalScalarWhereWithAggregatesInput[]
    NOT?: studentsAdditionalScalarWhereWithAggregatesInput | studentsAdditionalScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"studentsAdditional"> | number
    userId?: IntWithAggregatesFilter<"studentsAdditional"> | number
    wishCompanyId?: IntNullableWithAggregatesFilter<"studentsAdditional"> | number | null
    schoolId?: IntNullableWithAggregatesFilter<"studentsAdditional"> | number | null
    majorId?: IntNullableWithAggregatesFilter<"studentsAdditional"> | number | null
    wishBigJobId?: IntNullableWithAggregatesFilter<"studentsAdditional"> | number | null
    wishMidJobId?: IntNullableWithAggregatesFilter<"studentsAdditional"> | number | null
    wishSmallJobId?: IntNullableWithAggregatesFilter<"studentsAdditional"> | number | null
    wishJobId?: IntNullableWithAggregatesFilter<"studentsAdditional"> | number | null
    portfolio?: StringNullableWithAggregatesFilter<"studentsAdditional"> | string | null
    reportedNum?: IntWithAggregatesFilter<"studentsAdditional"> | number
    totalGrade?: FloatNullableWithAggregatesFilter<"studentsAdditional"> | number | null
    adviceCount?: IntWithAggregatesFilter<"studentsAdditional"> | number
    estimationCount?: FloatWithAggregatesFilter<"studentsAdditional"> | number
    updatedDate?: DateTimeWithAggregatesFilter<"studentsAdditional"> | Date | string
  }

  export type categoryWhereInput = {
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    id?: IntFilter<"category"> | number
    name?: StringFilter<"category"> | string
    posts?: PostsListRelationFilter
  }

  export type categoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    posts?: postsOrderByRelationAggregateInput
  }

  export type categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: categoryWhereInput | categoryWhereInput[]
    OR?: categoryWhereInput[]
    NOT?: categoryWhereInput | categoryWhereInput[]
    name?: StringFilter<"category"> | string
    posts?: PostsListRelationFilter
  }, "id">

  export type categoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: categoryCountOrderByAggregateInput
    _avg?: categoryAvgOrderByAggregateInput
    _max?: categoryMaxOrderByAggregateInput
    _min?: categoryMinOrderByAggregateInput
    _sum?: categorySumOrderByAggregateInput
  }

  export type categoryScalarWhereWithAggregatesInput = {
    AND?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    OR?: categoryScalarWhereWithAggregatesInput[]
    NOT?: categoryScalarWhereWithAggregatesInput | categoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"category"> | number
    name?: StringWithAggregatesFilter<"category"> | string
  }

  export type postsWhereInput = {
    AND?: postsWhereInput | postsWhereInput[]
    OR?: postsWhereInput[]
    NOT?: postsWhereInput | postsWhereInput[]
    id?: IntFilter<"posts"> | number
    userId?: IntNullableFilter<"posts"> | number | null
    categoryId?: IntNullableFilter<"posts"> | number | null
    title?: StringFilter<"posts"> | string
    content?: StringFilter<"posts"> | string
    view?: IntFilter<"posts"> | number
    recommend?: IntFilter<"posts"> | number
    reported?: IntFilter<"posts"> | number
    createdDate?: DateTimeFilter<"posts"> | Date | string
    updatedDate?: DateTimeFilter<"posts"> | Date | string
    categories?: XOR<CategoryNullableRelationFilter, categoryWhereInput> | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    comments?: CommentsListRelationFilter
    recommend_posts?: RecommendPostsListRelationFilter
    reported_posts?: ReportedPostsListRelationFilter
  }

  export type postsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    title?: SortOrder
    content?: SortOrder
    view?: SortOrder
    recommend?: SortOrder
    reported?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
    categories?: categoryOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    comments?: commentsOrderByRelationAggregateInput
    recommend_posts?: recommendPostsOrderByRelationAggregateInput
    reported_posts?: reportedPostsOrderByRelationAggregateInput
  }

  export type postsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: postsWhereInput | postsWhereInput[]
    OR?: postsWhereInput[]
    NOT?: postsWhereInput | postsWhereInput[]
    userId?: IntNullableFilter<"posts"> | number | null
    categoryId?: IntNullableFilter<"posts"> | number | null
    title?: StringFilter<"posts"> | string
    content?: StringFilter<"posts"> | string
    view?: IntFilter<"posts"> | number
    recommend?: IntFilter<"posts"> | number
    reported?: IntFilter<"posts"> | number
    createdDate?: DateTimeFilter<"posts"> | Date | string
    updatedDate?: DateTimeFilter<"posts"> | Date | string
    categories?: XOR<CategoryNullableRelationFilter, categoryWhereInput> | null
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    comments?: CommentsListRelationFilter
    recommend_posts?: RecommendPostsListRelationFilter
    reported_posts?: ReportedPostsListRelationFilter
  }, "id">

  export type postsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    title?: SortOrder
    content?: SortOrder
    view?: SortOrder
    recommend?: SortOrder
    reported?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
    _count?: postsCountOrderByAggregateInput
    _avg?: postsAvgOrderByAggregateInput
    _max?: postsMaxOrderByAggregateInput
    _min?: postsMinOrderByAggregateInput
    _sum?: postsSumOrderByAggregateInput
  }

  export type postsScalarWhereWithAggregatesInput = {
    AND?: postsScalarWhereWithAggregatesInput | postsScalarWhereWithAggregatesInput[]
    OR?: postsScalarWhereWithAggregatesInput[]
    NOT?: postsScalarWhereWithAggregatesInput | postsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"posts"> | number
    userId?: IntNullableWithAggregatesFilter<"posts"> | number | null
    categoryId?: IntNullableWithAggregatesFilter<"posts"> | number | null
    title?: StringWithAggregatesFilter<"posts"> | string
    content?: StringWithAggregatesFilter<"posts"> | string
    view?: IntWithAggregatesFilter<"posts"> | number
    recommend?: IntWithAggregatesFilter<"posts"> | number
    reported?: IntWithAggregatesFilter<"posts"> | number
    createdDate?: DateTimeWithAggregatesFilter<"posts"> | Date | string
    updatedDate?: DateTimeWithAggregatesFilter<"posts"> | Date | string
  }

  export type commentsWhereInput = {
    AND?: commentsWhereInput | commentsWhereInput[]
    OR?: commentsWhereInput[]
    NOT?: commentsWhereInput | commentsWhereInput[]
    id?: IntFilter<"comments"> | number
    postId?: IntFilter<"comments"> | number
    userId?: IntNullableFilter<"comments"> | number | null
    content?: StringFilter<"comments"> | string
    parentCommentId?: IntNullableFilter<"comments"> | number | null
    recommend?: IntFilter<"comments"> | number
    reported?: IntFilter<"comments"> | number
    createdDate?: DateTimeFilter<"comments"> | Date | string
    updatedDate?: DateTimeFilter<"comments"> | Date | string
    isDelete?: BoolFilter<"comments"> | boolean
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    post?: XOR<PostsRelationFilter, postsWhereInput>
    parent?: XOR<CommentsNullableRelationFilter, commentsWhereInput> | null
    replies?: CommentsListRelationFilter
    recommend_comments?: RecommendCommentsListRelationFilter
    reported_comments?: ReportedCommentsListRelationFilter
  }

  export type commentsOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrderInput | SortOrder
    content?: SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    recommend?: SortOrder
    reported?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
    isDelete?: SortOrder
    users?: usersOrderByWithRelationInput
    post?: postsOrderByWithRelationInput
    parent?: commentsOrderByWithRelationInput
    replies?: commentsOrderByRelationAggregateInput
    recommend_comments?: recommendCommentsOrderByRelationAggregateInput
    reported_comments?: reportedCommentsOrderByRelationAggregateInput
  }

  export type commentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: commentsWhereInput | commentsWhereInput[]
    OR?: commentsWhereInput[]
    NOT?: commentsWhereInput | commentsWhereInput[]
    postId?: IntFilter<"comments"> | number
    userId?: IntNullableFilter<"comments"> | number | null
    content?: StringFilter<"comments"> | string
    parentCommentId?: IntNullableFilter<"comments"> | number | null
    recommend?: IntFilter<"comments"> | number
    reported?: IntFilter<"comments"> | number
    createdDate?: DateTimeFilter<"comments"> | Date | string
    updatedDate?: DateTimeFilter<"comments"> | Date | string
    isDelete?: BoolFilter<"comments"> | boolean
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    post?: XOR<PostsRelationFilter, postsWhereInput>
    parent?: XOR<CommentsNullableRelationFilter, commentsWhereInput> | null
    replies?: CommentsListRelationFilter
    recommend_comments?: RecommendCommentsListRelationFilter
    reported_comments?: ReportedCommentsListRelationFilter
  }, "id">

  export type commentsOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrderInput | SortOrder
    content?: SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    recommend?: SortOrder
    reported?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
    isDelete?: SortOrder
    _count?: commentsCountOrderByAggregateInput
    _avg?: commentsAvgOrderByAggregateInput
    _max?: commentsMaxOrderByAggregateInput
    _min?: commentsMinOrderByAggregateInput
    _sum?: commentsSumOrderByAggregateInput
  }

  export type commentsScalarWhereWithAggregatesInput = {
    AND?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]
    OR?: commentsScalarWhereWithAggregatesInput[]
    NOT?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"comments"> | number
    postId?: IntWithAggregatesFilter<"comments"> | number
    userId?: IntNullableWithAggregatesFilter<"comments"> | number | null
    content?: StringWithAggregatesFilter<"comments"> | string
    parentCommentId?: IntNullableWithAggregatesFilter<"comments"> | number | null
    recommend?: IntWithAggregatesFilter<"comments"> | number
    reported?: IntWithAggregatesFilter<"comments"> | number
    createdDate?: DateTimeWithAggregatesFilter<"comments"> | Date | string
    updatedDate?: DateTimeWithAggregatesFilter<"comments"> | Date | string
    isDelete?: BoolWithAggregatesFilter<"comments"> | boolean
  }

  export type recommendPostsWhereInput = {
    AND?: recommendPostsWhereInput | recommendPostsWhereInput[]
    OR?: recommendPostsWhereInput[]
    NOT?: recommendPostsWhereInput | recommendPostsWhereInput[]
    id?: IntFilter<"recommendPosts"> | number
    postId?: IntFilter<"recommendPosts"> | number
    userId?: IntFilter<"recommendPosts"> | number
    createdDate?: DateTimeFilter<"recommendPosts"> | Date | string
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    post?: XOR<PostsRelationFilter, postsWhereInput>
  }

  export type recommendPostsOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdDate?: SortOrder
    users?: usersOrderByWithRelationInput
    post?: postsOrderByWithRelationInput
  }

  export type recommendPostsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: recommendPostsWhereInput | recommendPostsWhereInput[]
    OR?: recommendPostsWhereInput[]
    NOT?: recommendPostsWhereInput | recommendPostsWhereInput[]
    postId?: IntFilter<"recommendPosts"> | number
    userId?: IntFilter<"recommendPosts"> | number
    createdDate?: DateTimeFilter<"recommendPosts"> | Date | string
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    post?: XOR<PostsRelationFilter, postsWhereInput>
  }, "id">

  export type recommendPostsOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdDate?: SortOrder
    _count?: recommendPostsCountOrderByAggregateInput
    _avg?: recommendPostsAvgOrderByAggregateInput
    _max?: recommendPostsMaxOrderByAggregateInput
    _min?: recommendPostsMinOrderByAggregateInput
    _sum?: recommendPostsSumOrderByAggregateInput
  }

  export type recommendPostsScalarWhereWithAggregatesInput = {
    AND?: recommendPostsScalarWhereWithAggregatesInput | recommendPostsScalarWhereWithAggregatesInput[]
    OR?: recommendPostsScalarWhereWithAggregatesInput[]
    NOT?: recommendPostsScalarWhereWithAggregatesInput | recommendPostsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"recommendPosts"> | number
    postId?: IntWithAggregatesFilter<"recommendPosts"> | number
    userId?: IntWithAggregatesFilter<"recommendPosts"> | number
    createdDate?: DateTimeWithAggregatesFilter<"recommendPosts"> | Date | string
  }

  export type reportedPostsWhereInput = {
    AND?: reportedPostsWhereInput | reportedPostsWhereInput[]
    OR?: reportedPostsWhereInput[]
    NOT?: reportedPostsWhereInput | reportedPostsWhereInput[]
    id?: IntFilter<"reportedPosts"> | number
    postId?: IntFilter<"reportedPosts"> | number
    userId?: IntFilter<"reportedPosts"> | number
    reason?: StringFilter<"reportedPosts"> | string
    createdDate?: DateTimeFilter<"reportedPosts"> | Date | string
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    post?: XOR<PostsRelationFilter, postsWhereInput>
  }

  export type reportedPostsOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdDate?: SortOrder
    users?: usersOrderByWithRelationInput
    post?: postsOrderByWithRelationInput
  }

  export type reportedPostsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: reportedPostsWhereInput | reportedPostsWhereInput[]
    OR?: reportedPostsWhereInput[]
    NOT?: reportedPostsWhereInput | reportedPostsWhereInput[]
    postId?: IntFilter<"reportedPosts"> | number
    userId?: IntFilter<"reportedPosts"> | number
    reason?: StringFilter<"reportedPosts"> | string
    createdDate?: DateTimeFilter<"reportedPosts"> | Date | string
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
    post?: XOR<PostsRelationFilter, postsWhereInput>
  }, "id">

  export type reportedPostsOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdDate?: SortOrder
    _count?: reportedPostsCountOrderByAggregateInput
    _avg?: reportedPostsAvgOrderByAggregateInput
    _max?: reportedPostsMaxOrderByAggregateInput
    _min?: reportedPostsMinOrderByAggregateInput
    _sum?: reportedPostsSumOrderByAggregateInput
  }

  export type reportedPostsScalarWhereWithAggregatesInput = {
    AND?: reportedPostsScalarWhereWithAggregatesInput | reportedPostsScalarWhereWithAggregatesInput[]
    OR?: reportedPostsScalarWhereWithAggregatesInput[]
    NOT?: reportedPostsScalarWhereWithAggregatesInput | reportedPostsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"reportedPosts"> | number
    postId?: IntWithAggregatesFilter<"reportedPosts"> | number
    userId?: IntWithAggregatesFilter<"reportedPosts"> | number
    reason?: StringWithAggregatesFilter<"reportedPosts"> | string
    createdDate?: DateTimeWithAggregatesFilter<"reportedPosts"> | Date | string
  }

  export type recommendCommentsWhereInput = {
    AND?: recommendCommentsWhereInput | recommendCommentsWhereInput[]
    OR?: recommendCommentsWhereInput[]
    NOT?: recommendCommentsWhereInput | recommendCommentsWhereInput[]
    id?: IntFilter<"recommendComments"> | number
    commentId?: IntFilter<"recommendComments"> | number
    userId?: IntFilter<"recommendComments"> | number
    createdDate?: DateTimeFilter<"recommendComments"> | Date | string
    comment?: XOR<CommentsRelationFilter, commentsWhereInput>
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type recommendCommentsOrderByWithRelationInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    createdDate?: SortOrder
    comment?: commentsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type recommendCommentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: recommendCommentsWhereInput | recommendCommentsWhereInput[]
    OR?: recommendCommentsWhereInput[]
    NOT?: recommendCommentsWhereInput | recommendCommentsWhereInput[]
    commentId?: IntFilter<"recommendComments"> | number
    userId?: IntFilter<"recommendComments"> | number
    createdDate?: DateTimeFilter<"recommendComments"> | Date | string
    comment?: XOR<CommentsRelationFilter, commentsWhereInput>
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id">

  export type recommendCommentsOrderByWithAggregationInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    createdDate?: SortOrder
    _count?: recommendCommentsCountOrderByAggregateInput
    _avg?: recommendCommentsAvgOrderByAggregateInput
    _max?: recommendCommentsMaxOrderByAggregateInput
    _min?: recommendCommentsMinOrderByAggregateInput
    _sum?: recommendCommentsSumOrderByAggregateInput
  }

  export type recommendCommentsScalarWhereWithAggregatesInput = {
    AND?: recommendCommentsScalarWhereWithAggregatesInput | recommendCommentsScalarWhereWithAggregatesInput[]
    OR?: recommendCommentsScalarWhereWithAggregatesInput[]
    NOT?: recommendCommentsScalarWhereWithAggregatesInput | recommendCommentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"recommendComments"> | number
    commentId?: IntWithAggregatesFilter<"recommendComments"> | number
    userId?: IntWithAggregatesFilter<"recommendComments"> | number
    createdDate?: DateTimeWithAggregatesFilter<"recommendComments"> | Date | string
  }

  export type reportedCommentsWhereInput = {
    AND?: reportedCommentsWhereInput | reportedCommentsWhereInput[]
    OR?: reportedCommentsWhereInput[]
    NOT?: reportedCommentsWhereInput | reportedCommentsWhereInput[]
    id?: IntFilter<"reportedComments"> | number
    commentId?: IntFilter<"reportedComments"> | number
    userId?: IntFilter<"reportedComments"> | number
    reason?: StringFilter<"reportedComments"> | string
    createdDate?: DateTimeFilter<"reportedComments"> | Date | string
    comment?: XOR<CommentsRelationFilter, commentsWhereInput>
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type reportedCommentsOrderByWithRelationInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdDate?: SortOrder
    comment?: commentsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type reportedCommentsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: reportedCommentsWhereInput | reportedCommentsWhereInput[]
    OR?: reportedCommentsWhereInput[]
    NOT?: reportedCommentsWhereInput | reportedCommentsWhereInput[]
    commentId?: IntFilter<"reportedComments"> | number
    userId?: IntFilter<"reportedComments"> | number
    reason?: StringFilter<"reportedComments"> | string
    createdDate?: DateTimeFilter<"reportedComments"> | Date | string
    comment?: XOR<CommentsRelationFilter, commentsWhereInput>
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id">

  export type reportedCommentsOrderByWithAggregationInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdDate?: SortOrder
    _count?: reportedCommentsCountOrderByAggregateInput
    _avg?: reportedCommentsAvgOrderByAggregateInput
    _max?: reportedCommentsMaxOrderByAggregateInput
    _min?: reportedCommentsMinOrderByAggregateInput
    _sum?: reportedCommentsSumOrderByAggregateInput
  }

  export type reportedCommentsScalarWhereWithAggregatesInput = {
    AND?: reportedCommentsScalarWhereWithAggregatesInput | reportedCommentsScalarWhereWithAggregatesInput[]
    OR?: reportedCommentsScalarWhereWithAggregatesInput[]
    NOT?: reportedCommentsScalarWhereWithAggregatesInput | reportedCommentsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"reportedComments"> | number
    commentId?: IntWithAggregatesFilter<"reportedComments"> | number
    userId?: IntWithAggregatesFilter<"reportedComments"> | number
    reason?: StringWithAggregatesFilter<"reportedComments"> | string
    createdDate?: DateTimeWithAggregatesFilter<"reportedComments"> | Date | string
  }

  export type reportedUsersWhereInput = {
    AND?: reportedUsersWhereInput | reportedUsersWhereInput[]
    OR?: reportedUsersWhereInput[]
    NOT?: reportedUsersWhereInput | reportedUsersWhereInput[]
    id?: IntFilter<"reportedUsers"> | number
    targetUserId?: IntFilter<"reportedUsers"> | number
    reportingUserId?: IntFilter<"reportedUsers"> | number
    reason?: StringFilter<"reportedUsers"> | string
    createdDate?: DateTimeFilter<"reportedUsers"> | Date | string
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }

  export type reportedUsersOrderByWithRelationInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    reportingUserId?: SortOrder
    reason?: SortOrder
    createdDate?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type reportedUsersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: reportedUsersWhereInput | reportedUsersWhereInput[]
    OR?: reportedUsersWhereInput[]
    NOT?: reportedUsersWhereInput | reportedUsersWhereInput[]
    targetUserId?: IntFilter<"reportedUsers"> | number
    reportingUserId?: IntFilter<"reportedUsers"> | number
    reason?: StringFilter<"reportedUsers"> | string
    createdDate?: DateTimeFilter<"reportedUsers"> | Date | string
    users?: XOR<UsersNullableRelationFilter, usersWhereInput> | null
  }, "id">

  export type reportedUsersOrderByWithAggregationInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    reportingUserId?: SortOrder
    reason?: SortOrder
    createdDate?: SortOrder
    _count?: reportedUsersCountOrderByAggregateInput
    _avg?: reportedUsersAvgOrderByAggregateInput
    _max?: reportedUsersMaxOrderByAggregateInput
    _min?: reportedUsersMinOrderByAggregateInput
    _sum?: reportedUsersSumOrderByAggregateInput
  }

  export type reportedUsersScalarWhereWithAggregatesInput = {
    AND?: reportedUsersScalarWhereWithAggregatesInput | reportedUsersScalarWhereWithAggregatesInput[]
    OR?: reportedUsersScalarWhereWithAggregatesInput[]
    NOT?: reportedUsersScalarWhereWithAggregatesInput | reportedUsersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"reportedUsers"> | number
    targetUserId?: IntWithAggregatesFilter<"reportedUsers"> | number
    reportingUserId?: IntWithAggregatesFilter<"reportedUsers"> | number
    reason?: StringWithAggregatesFilter<"reportedUsers"> | string
    createdDate?: DateTimeWithAggregatesFilter<"reportedUsers"> | Date | string
  }

  export type companyWhereInput = {
    AND?: companyWhereInput | companyWhereInput[]
    OR?: companyWhereInput[]
    NOT?: companyWhereInput | companyWhereInput[]
    id?: IntFilter<"company"> | number
    name?: StringFilter<"company"> | string
    address?: StringFilter<"company"> | string
    longitude?: FloatFilter<"company"> | number
    latitude?: FloatFilter<"company"> | number
    scale?: StringFilter<"company"> | string
    bigJobKindId?: IntFilter<"company"> | number
    midJobKindId?: IntFilter<"company"> | number
    smallJobKindId?: IntFilter<"company"> | number
    bigJobKind?: XOR<BigJobKindRelationFilter, bigJobKindWhereInput>
    midJobKind?: XOR<MidJobKindRelationFilter, midJobKindWhereInput>
    smallJobKind?: XOR<SmallJobKindRelationFilter, smallJobKindWhereInput>
    incumebent?: IncumbentsAdditionalListRelationFilter
    student?: StudentsAdditionalListRelationFilter
  }

  export type companyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    scale?: SortOrder
    bigJobKindId?: SortOrder
    midJobKindId?: SortOrder
    smallJobKindId?: SortOrder
    bigJobKind?: bigJobKindOrderByWithRelationInput
    midJobKind?: midJobKindOrderByWithRelationInput
    smallJobKind?: smallJobKindOrderByWithRelationInput
    incumebent?: incumbentsAdditionalOrderByRelationAggregateInput
    student?: studentsAdditionalOrderByRelationAggregateInput
  }

  export type companyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: companyWhereInput | companyWhereInput[]
    OR?: companyWhereInput[]
    NOT?: companyWhereInput | companyWhereInput[]
    name?: StringFilter<"company"> | string
    address?: StringFilter<"company"> | string
    longitude?: FloatFilter<"company"> | number
    latitude?: FloatFilter<"company"> | number
    scale?: StringFilter<"company"> | string
    bigJobKindId?: IntFilter<"company"> | number
    midJobKindId?: IntFilter<"company"> | number
    smallJobKindId?: IntFilter<"company"> | number
    bigJobKind?: XOR<BigJobKindRelationFilter, bigJobKindWhereInput>
    midJobKind?: XOR<MidJobKindRelationFilter, midJobKindWhereInput>
    smallJobKind?: XOR<SmallJobKindRelationFilter, smallJobKindWhereInput>
    incumebent?: IncumbentsAdditionalListRelationFilter
    student?: StudentsAdditionalListRelationFilter
  }, "id">

  export type companyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    scale?: SortOrder
    bigJobKindId?: SortOrder
    midJobKindId?: SortOrder
    smallJobKindId?: SortOrder
    _count?: companyCountOrderByAggregateInput
    _avg?: companyAvgOrderByAggregateInput
    _max?: companyMaxOrderByAggregateInput
    _min?: companyMinOrderByAggregateInput
    _sum?: companySumOrderByAggregateInput
  }

  export type companyScalarWhereWithAggregatesInput = {
    AND?: companyScalarWhereWithAggregatesInput | companyScalarWhereWithAggregatesInput[]
    OR?: companyScalarWhereWithAggregatesInput[]
    NOT?: companyScalarWhereWithAggregatesInput | companyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"company"> | number
    name?: StringWithAggregatesFilter<"company"> | string
    address?: StringWithAggregatesFilter<"company"> | string
    longitude?: FloatWithAggregatesFilter<"company"> | number
    latitude?: FloatWithAggregatesFilter<"company"> | number
    scale?: StringWithAggregatesFilter<"company"> | string
    bigJobKindId?: IntWithAggregatesFilter<"company"> | number
    midJobKindId?: IntWithAggregatesFilter<"company"> | number
    smallJobKindId?: IntWithAggregatesFilter<"company"> | number
  }

  export type schoolWhereInput = {
    AND?: schoolWhereInput | schoolWhereInput[]
    OR?: schoolWhereInput[]
    NOT?: schoolWhereInput | schoolWhereInput[]
    id?: IntFilter<"school"> | number
    name?: StringFilter<"school"> | string
    branch?: StringFilter<"school"> | string
    major?: MajorListRelationFilter
    incumebent?: IncumbentsAdditionalListRelationFilter
    student?: StudentsAdditionalListRelationFilter
  }

  export type schoolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    branch?: SortOrder
    major?: majorOrderByRelationAggregateInput
    incumebent?: incumbentsAdditionalOrderByRelationAggregateInput
    student?: studentsAdditionalOrderByRelationAggregateInput
  }

  export type schoolWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: schoolWhereInput | schoolWhereInput[]
    OR?: schoolWhereInput[]
    NOT?: schoolWhereInput | schoolWhereInput[]
    name?: StringFilter<"school"> | string
    branch?: StringFilter<"school"> | string
    major?: MajorListRelationFilter
    incumebent?: IncumbentsAdditionalListRelationFilter
    student?: StudentsAdditionalListRelationFilter
  }, "id">

  export type schoolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    branch?: SortOrder
    _count?: schoolCountOrderByAggregateInput
    _avg?: schoolAvgOrderByAggregateInput
    _max?: schoolMaxOrderByAggregateInput
    _min?: schoolMinOrderByAggregateInput
    _sum?: schoolSumOrderByAggregateInput
  }

  export type schoolScalarWhereWithAggregatesInput = {
    AND?: schoolScalarWhereWithAggregatesInput | schoolScalarWhereWithAggregatesInput[]
    OR?: schoolScalarWhereWithAggregatesInput[]
    NOT?: schoolScalarWhereWithAggregatesInput | schoolScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"school"> | number
    name?: StringWithAggregatesFilter<"school"> | string
    branch?: StringWithAggregatesFilter<"school"> | string
  }

  export type majorWhereInput = {
    AND?: majorWhereInput | majorWhereInput[]
    OR?: majorWhereInput[]
    NOT?: majorWhereInput | majorWhereInput[]
    id?: IntFilter<"major"> | number
    schoolId?: IntFilter<"major"> | number
    name?: StringFilter<"major"> | string
    dayAndNight?: StringFilter<"major"> | string
    school?: XOR<SchoolRelationFilter, schoolWhereInput>
    incumebent?: IncumbentsAdditionalListRelationFilter
    student?: StudentsAdditionalListRelationFilter
  }

  export type majorOrderByWithRelationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    dayAndNight?: SortOrder
    school?: schoolOrderByWithRelationInput
    incumebent?: incumbentsAdditionalOrderByRelationAggregateInput
    student?: studentsAdditionalOrderByRelationAggregateInput
  }

  export type majorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: majorWhereInput | majorWhereInput[]
    OR?: majorWhereInput[]
    NOT?: majorWhereInput | majorWhereInput[]
    schoolId?: IntFilter<"major"> | number
    name?: StringFilter<"major"> | string
    dayAndNight?: StringFilter<"major"> | string
    school?: XOR<SchoolRelationFilter, schoolWhereInput>
    incumebent?: IncumbentsAdditionalListRelationFilter
    student?: StudentsAdditionalListRelationFilter
  }, "id">

  export type majorOrderByWithAggregationInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    dayAndNight?: SortOrder
    _count?: majorCountOrderByAggregateInput
    _avg?: majorAvgOrderByAggregateInput
    _max?: majorMaxOrderByAggregateInput
    _min?: majorMinOrderByAggregateInput
    _sum?: majorSumOrderByAggregateInput
  }

  export type majorScalarWhereWithAggregatesInput = {
    AND?: majorScalarWhereWithAggregatesInput | majorScalarWhereWithAggregatesInput[]
    OR?: majorScalarWhereWithAggregatesInput[]
    NOT?: majorScalarWhereWithAggregatesInput | majorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"major"> | number
    schoolId?: IntWithAggregatesFilter<"major"> | number
    name?: StringWithAggregatesFilter<"major"> | string
    dayAndNight?: StringWithAggregatesFilter<"major"> | string
  }

  export type bigJobKindWhereInput = {
    AND?: bigJobKindWhereInput | bigJobKindWhereInput[]
    OR?: bigJobKindWhereInput[]
    NOT?: bigJobKindWhereInput | bigJobKindWhereInput[]
    id?: IntFilter<"bigJobKind"> | number
    name?: StringFilter<"bigJobKind"> | string
    company?: CompanyListRelationFilter
    midJobKind?: MidJobKindListRelationFilter
  }

  export type bigJobKindOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    company?: companyOrderByRelationAggregateInput
    midJobKind?: midJobKindOrderByRelationAggregateInput
  }

  export type bigJobKindWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: bigJobKindWhereInput | bigJobKindWhereInput[]
    OR?: bigJobKindWhereInput[]
    NOT?: bigJobKindWhereInput | bigJobKindWhereInput[]
    name?: StringFilter<"bigJobKind"> | string
    company?: CompanyListRelationFilter
    midJobKind?: MidJobKindListRelationFilter
  }, "id">

  export type bigJobKindOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: bigJobKindCountOrderByAggregateInput
    _avg?: bigJobKindAvgOrderByAggregateInput
    _max?: bigJobKindMaxOrderByAggregateInput
    _min?: bigJobKindMinOrderByAggregateInput
    _sum?: bigJobKindSumOrderByAggregateInput
  }

  export type bigJobKindScalarWhereWithAggregatesInput = {
    AND?: bigJobKindScalarWhereWithAggregatesInput | bigJobKindScalarWhereWithAggregatesInput[]
    OR?: bigJobKindScalarWhereWithAggregatesInput[]
    NOT?: bigJobKindScalarWhereWithAggregatesInput | bigJobKindScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bigJobKind"> | number
    name?: StringWithAggregatesFilter<"bigJobKind"> | string
  }

  export type midJobKindWhereInput = {
    AND?: midJobKindWhereInput | midJobKindWhereInput[]
    OR?: midJobKindWhereInput[]
    NOT?: midJobKindWhereInput | midJobKindWhereInput[]
    id?: IntFilter<"midJobKind"> | number
    bigJobKindId?: IntFilter<"midJobKind"> | number
    name?: StringFilter<"midJobKind"> | string
    company?: CompanyListRelationFilter
    bigJobKind?: XOR<BigJobKindRelationFilter, bigJobKindWhereInput>
    smallJobKind?: SmallJobKindListRelationFilter
  }

  export type midJobKindOrderByWithRelationInput = {
    id?: SortOrder
    bigJobKindId?: SortOrder
    name?: SortOrder
    company?: companyOrderByRelationAggregateInput
    bigJobKind?: bigJobKindOrderByWithRelationInput
    smallJobKind?: smallJobKindOrderByRelationAggregateInput
  }

  export type midJobKindWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: midJobKindWhereInput | midJobKindWhereInput[]
    OR?: midJobKindWhereInput[]
    NOT?: midJobKindWhereInput | midJobKindWhereInput[]
    bigJobKindId?: IntFilter<"midJobKind"> | number
    name?: StringFilter<"midJobKind"> | string
    company?: CompanyListRelationFilter
    bigJobKind?: XOR<BigJobKindRelationFilter, bigJobKindWhereInput>
    smallJobKind?: SmallJobKindListRelationFilter
  }, "id">

  export type midJobKindOrderByWithAggregationInput = {
    id?: SortOrder
    bigJobKindId?: SortOrder
    name?: SortOrder
    _count?: midJobKindCountOrderByAggregateInput
    _avg?: midJobKindAvgOrderByAggregateInput
    _max?: midJobKindMaxOrderByAggregateInput
    _min?: midJobKindMinOrderByAggregateInput
    _sum?: midJobKindSumOrderByAggregateInput
  }

  export type midJobKindScalarWhereWithAggregatesInput = {
    AND?: midJobKindScalarWhereWithAggregatesInput | midJobKindScalarWhereWithAggregatesInput[]
    OR?: midJobKindScalarWhereWithAggregatesInput[]
    NOT?: midJobKindScalarWhereWithAggregatesInput | midJobKindScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"midJobKind"> | number
    bigJobKindId?: IntWithAggregatesFilter<"midJobKind"> | number
    name?: StringWithAggregatesFilter<"midJobKind"> | string
  }

  export type smallJobKindWhereInput = {
    AND?: smallJobKindWhereInput | smallJobKindWhereInput[]
    OR?: smallJobKindWhereInput[]
    NOT?: smallJobKindWhereInput | smallJobKindWhereInput[]
    id?: IntFilter<"smallJobKind"> | number
    midJobKindId?: IntFilter<"smallJobKind"> | number
    name?: StringFilter<"smallJobKind"> | string
    company?: CompanyListRelationFilter
    midJobKind?: XOR<MidJobKindRelationFilter, midJobKindWhereInput>
  }

  export type smallJobKindOrderByWithRelationInput = {
    id?: SortOrder
    midJobKindId?: SortOrder
    name?: SortOrder
    company?: companyOrderByRelationAggregateInput
    midJobKind?: midJobKindOrderByWithRelationInput
  }

  export type smallJobKindWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: smallJobKindWhereInput | smallJobKindWhereInput[]
    OR?: smallJobKindWhereInput[]
    NOT?: smallJobKindWhereInput | smallJobKindWhereInput[]
    midJobKindId?: IntFilter<"smallJobKind"> | number
    name?: StringFilter<"smallJobKind"> | string
    company?: CompanyListRelationFilter
    midJobKind?: XOR<MidJobKindRelationFilter, midJobKindWhereInput>
  }, "id">

  export type smallJobKindOrderByWithAggregationInput = {
    id?: SortOrder
    midJobKindId?: SortOrder
    name?: SortOrder
    _count?: smallJobKindCountOrderByAggregateInput
    _avg?: smallJobKindAvgOrderByAggregateInput
    _max?: smallJobKindMaxOrderByAggregateInput
    _min?: smallJobKindMinOrderByAggregateInput
    _sum?: smallJobKindSumOrderByAggregateInput
  }

  export type smallJobKindScalarWhereWithAggregatesInput = {
    AND?: smallJobKindScalarWhereWithAggregatesInput | smallJobKindScalarWhereWithAggregatesInput[]
    OR?: smallJobKindScalarWhereWithAggregatesInput[]
    NOT?: smallJobKindScalarWhereWithAggregatesInput | smallJobKindScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"smallJobKind"> | number
    midJobKindId?: IntWithAggregatesFilter<"smallJobKind"> | number
    name?: StringWithAggregatesFilter<"smallJobKind"> | string
  }

  export type jobWhereInput = {
    AND?: jobWhereInput | jobWhereInput[]
    OR?: jobWhereInput[]
    NOT?: jobWhereInput | jobWhereInput[]
    id?: IntFilter<"job"> | number
    clusteringGroup?: IntFilter<"job"> | number
    name?: StringFilter<"job"> | string
    incumebent?: IncumbentsAdditionalListRelationFilter
    student?: StudentsAdditionalListRelationFilter
  }

  export type jobOrderByWithRelationInput = {
    id?: SortOrder
    clusteringGroup?: SortOrder
    name?: SortOrder
    incumebent?: incumbentsAdditionalOrderByRelationAggregateInput
    student?: studentsAdditionalOrderByRelationAggregateInput
  }

  export type jobWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: jobWhereInput | jobWhereInput[]
    OR?: jobWhereInput[]
    NOT?: jobWhereInput | jobWhereInput[]
    clusteringGroup?: IntFilter<"job"> | number
    name?: StringFilter<"job"> | string
    incumebent?: IncumbentsAdditionalListRelationFilter
    student?: StudentsAdditionalListRelationFilter
  }, "id">

  export type jobOrderByWithAggregationInput = {
    id?: SortOrder
    clusteringGroup?: SortOrder
    name?: SortOrder
    _count?: jobCountOrderByAggregateInput
    _avg?: jobAvgOrderByAggregateInput
    _max?: jobMaxOrderByAggregateInput
    _min?: jobMinOrderByAggregateInput
    _sum?: jobSumOrderByAggregateInput
  }

  export type jobScalarWhereWithAggregatesInput = {
    AND?: jobScalarWhereWithAggregatesInput | jobScalarWhereWithAggregatesInput[]
    OR?: jobScalarWhereWithAggregatesInput[]
    NOT?: jobScalarWhereWithAggregatesInput | jobScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"job"> | number
    clusteringGroup?: IntWithAggregatesFilter<"job"> | number
    name?: StringWithAggregatesFilter<"job"> | string
  }

  export type usersCreateInput = {
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalCreateNestedOneWithoutUsersInput
    posts?: postsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    posts?: postsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsUncheckedCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsUncheckedCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUpdateOneWithoutUsersNestedInput
    posts?: postsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    posts?: postsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUncheckedUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
  }

  export type usersUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type incumbentsAdditionalCreateInput = {
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
    users: usersCreateNestedOneWithoutIncumbent_additionalInput
    company?: companyCreateNestedOneWithoutIncumebentInput
    school?: schoolCreateNestedOneWithoutIncumebentInput
    major?: majorCreateNestedOneWithoutIncumebentInput
    job?: jobCreateNestedOneWithoutIncumebentInput
  }

  export type incumbentsAdditionalUncheckedCreateInput = {
    id?: number
    userId: number
    companyId?: number | null
    schoolId?: number | null
    majorId?: number | null
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    jobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type incumbentsAdditionalUpdateInput = {
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutIncumbent_additionalNestedInput
    company?: companyUpdateOneWithoutIncumebentNestedInput
    school?: schoolUpdateOneWithoutIncumebentNestedInput
    major?: majorUpdateOneWithoutIncumebentNestedInput
    job?: jobUpdateOneWithoutIncumebentNestedInput
  }

  export type incumbentsAdditionalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type incumbentsAdditionalCreateManyInput = {
    id?: number
    userId: number
    companyId?: number | null
    schoolId?: number | null
    majorId?: number | null
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    jobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type incumbentsAdditionalUpdateManyMutationInput = {
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type incumbentsAdditionalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsAdditionalCreateInput = {
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
    users: usersCreateNestedOneWithoutStudent_additionalInput
    wishCompany?: companyCreateNestedOneWithoutStudentInput
    school?: schoolCreateNestedOneWithoutStudentInput
    major?: majorCreateNestedOneWithoutStudentInput
    wishJob?: jobCreateNestedOneWithoutStudentInput
  }

  export type studentsAdditionalUncheckedCreateInput = {
    id?: number
    userId: number
    wishCompanyId?: number | null
    schoolId?: number | null
    majorId?: number | null
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    wishJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type studentsAdditionalUpdateInput = {
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutStudent_additionalNestedInput
    wishCompany?: companyUpdateOneWithoutStudentNestedInput
    school?: schoolUpdateOneWithoutStudentNestedInput
    major?: majorUpdateOneWithoutStudentNestedInput
    wishJob?: jobUpdateOneWithoutStudentNestedInput
  }

  export type studentsAdditionalUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    wishCompanyId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsAdditionalCreateManyInput = {
    id?: number
    userId: number
    wishCompanyId?: number | null
    schoolId?: number | null
    majorId?: number | null
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    wishJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type studentsAdditionalUpdateManyMutationInput = {
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsAdditionalUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    wishCompanyId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type categoryCreateInput = {
    name: string
    posts?: postsCreateNestedManyWithoutCategoriesInput
  }

  export type categoryUncheckedCreateInput = {
    id?: number
    name: string
    posts?: postsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    posts?: postsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    posts?: postsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoryCreateManyInput = {
    id?: number
    name: string
  }

  export type categoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type categoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type postsCreateInput = {
    title: string
    content: string
    view?: number
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    categories?: categoryCreateNestedOneWithoutPostsInput
    users?: usersCreateNestedOneWithoutPostsInput
    comments?: commentsCreateNestedManyWithoutPostInput
    recommend_posts?: recommendPostsCreateNestedManyWithoutPostInput
    reported_posts?: reportedPostsCreateNestedManyWithoutPostInput
  }

  export type postsUncheckedCreateInput = {
    id?: number
    userId?: number | null
    categoryId?: number | null
    title: string
    content: string
    view?: number
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    comments?: commentsUncheckedCreateNestedManyWithoutPostInput
    recommend_posts?: recommendPostsUncheckedCreateNestedManyWithoutPostInput
    reported_posts?: reportedPostsUncheckedCreateNestedManyWithoutPostInput
  }

  export type postsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: categoryUpdateOneWithoutPostsNestedInput
    users?: usersUpdateOneWithoutPostsNestedInput
    comments?: commentsUpdateManyWithoutPostNestedInput
    recommend_posts?: recommendPostsUpdateManyWithoutPostNestedInput
    reported_posts?: reportedPostsUpdateManyWithoutPostNestedInput
  }

  export type postsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: commentsUncheckedUpdateManyWithoutPostNestedInput
    recommend_posts?: recommendPostsUncheckedUpdateManyWithoutPostNestedInput
    reported_posts?: reportedPostsUncheckedUpdateManyWithoutPostNestedInput
  }

  export type postsCreateManyInput = {
    id?: number
    userId?: number | null
    categoryId?: number | null
    title: string
    content: string
    view?: number
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
  }

  export type postsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type postsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentsCreateInput = {
    content: string
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
    users?: usersCreateNestedOneWithoutCommentsInput
    post: postsCreateNestedOneWithoutCommentsInput
    parent?: commentsCreateNestedOneWithoutRepliesInput
    replies?: commentsCreateNestedManyWithoutParentInput
    recommend_comments?: recommendCommentsCreateNestedManyWithoutCommentInput
    reported_comments?: reportedCommentsCreateNestedManyWithoutCommentInput
  }

  export type commentsUncheckedCreateInput = {
    id?: number
    postId: number
    userId?: number | null
    content: string
    parentCommentId?: number | null
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
    replies?: commentsUncheckedCreateNestedManyWithoutParentInput
    recommend_comments?: recommendCommentsUncheckedCreateNestedManyWithoutCommentInput
    reported_comments?: reportedCommentsUncheckedCreateNestedManyWithoutCommentInput
  }

  export type commentsUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    users?: usersUpdateOneWithoutCommentsNestedInput
    post?: postsUpdateOneRequiredWithoutCommentsNestedInput
    parent?: commentsUpdateOneWithoutRepliesNestedInput
    replies?: commentsUpdateManyWithoutParentNestedInput
    recommend_comments?: recommendCommentsUpdateManyWithoutCommentNestedInput
    reported_comments?: reportedCommentsUpdateManyWithoutCommentNestedInput
  }

  export type commentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    replies?: commentsUncheckedUpdateManyWithoutParentNestedInput
    recommend_comments?: recommendCommentsUncheckedUpdateManyWithoutCommentNestedInput
    reported_comments?: reportedCommentsUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type commentsCreateManyInput = {
    id?: number
    postId: number
    userId?: number | null
    content: string
    parentCommentId?: number | null
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
  }

  export type commentsUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type commentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type recommendPostsCreateInput = {
    createdDate?: Date | string
    users?: usersCreateNestedOneWithoutRecommend_postsInput
    post: postsCreateNestedOneWithoutRecommend_postsInput
  }

  export type recommendPostsUncheckedCreateInput = {
    id?: number
    postId: number
    userId: number
    createdDate?: Date | string
  }

  export type recommendPostsUpdateInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutRecommend_postsNestedInput
    post?: postsUpdateOneRequiredWithoutRecommend_postsNestedInput
  }

  export type recommendPostsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recommendPostsCreateManyInput = {
    id?: number
    postId: number
    userId: number
    createdDate?: Date | string
  }

  export type recommendPostsUpdateManyMutationInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recommendPostsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedPostsCreateInput = {
    reason: string
    createdDate?: Date | string
    users?: usersCreateNestedOneWithoutReported_postsInput
    post: postsCreateNestedOneWithoutReported_postsInput
  }

  export type reportedPostsUncheckedCreateInput = {
    id?: number
    postId: number
    userId: number
    reason: string
    createdDate?: Date | string
  }

  export type reportedPostsUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutReported_postsNestedInput
    post?: postsUpdateOneRequiredWithoutReported_postsNestedInput
  }

  export type reportedPostsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedPostsCreateManyInput = {
    id?: number
    postId: number
    userId: number
    reason: string
    createdDate?: Date | string
  }

  export type reportedPostsUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedPostsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recommendCommentsCreateInput = {
    createdDate?: Date | string
    comment: commentsCreateNestedOneWithoutRecommend_commentsInput
    users?: usersCreateNestedOneWithoutRecommend_commentsInput
  }

  export type recommendCommentsUncheckedCreateInput = {
    id?: number
    commentId: number
    userId: number
    createdDate?: Date | string
  }

  export type recommendCommentsUpdateInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: commentsUpdateOneRequiredWithoutRecommend_commentsNestedInput
    users?: usersUpdateOneWithoutRecommend_commentsNestedInput
  }

  export type recommendCommentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recommendCommentsCreateManyInput = {
    id?: number
    commentId: number
    userId: number
    createdDate?: Date | string
  }

  export type recommendCommentsUpdateManyMutationInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recommendCommentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedCommentsCreateInput = {
    reason: string
    createdDate?: Date | string
    comment: commentsCreateNestedOneWithoutReported_commentsInput
    users?: usersCreateNestedOneWithoutReported_commentsInput
  }

  export type reportedCommentsUncheckedCreateInput = {
    id?: number
    commentId: number
    userId: number
    reason: string
    createdDate?: Date | string
  }

  export type reportedCommentsUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: commentsUpdateOneRequiredWithoutReported_commentsNestedInput
    users?: usersUpdateOneWithoutReported_commentsNestedInput
  }

  export type reportedCommentsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedCommentsCreateManyInput = {
    id?: number
    commentId: number
    userId: number
    reason: string
    createdDate?: Date | string
  }

  export type reportedCommentsUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedCommentsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedUsersCreateInput = {
    reportingUserId: number
    reason: string
    createdDate?: Date | string
    users?: usersCreateNestedOneWithoutReported_usersInput
  }

  export type reportedUsersUncheckedCreateInput = {
    id?: number
    targetUserId: number
    reportingUserId: number
    reason: string
    createdDate?: Date | string
  }

  export type reportedUsersUpdateInput = {
    reportingUserId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutReported_usersNestedInput
  }

  export type reportedUsersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetUserId?: IntFieldUpdateOperationsInput | number
    reportingUserId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedUsersCreateManyInput = {
    id?: number
    targetUserId: number
    reportingUserId: number
    reason: string
    createdDate?: Date | string
  }

  export type reportedUsersUpdateManyMutationInput = {
    reportingUserId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedUsersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    targetUserId?: IntFieldUpdateOperationsInput | number
    reportingUserId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyCreateInput = {
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    bigJobKind: bigJobKindCreateNestedOneWithoutCompanyInput
    midJobKind: midJobKindCreateNestedOneWithoutCompanyInput
    smallJobKind: smallJobKindCreateNestedOneWithoutCompanyInput
    incumebent?: incumbentsAdditionalCreateNestedManyWithoutCompanyInput
    student?: studentsAdditionalCreateNestedManyWithoutWishCompanyInput
  }

  export type companyUncheckedCreateInput = {
    id?: number
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    bigJobKindId: number
    midJobKindId: number
    smallJobKindId: number
    incumebent?: incumbentsAdditionalUncheckedCreateNestedManyWithoutCompanyInput
    student?: studentsAdditionalUncheckedCreateNestedManyWithoutWishCompanyInput
  }

  export type companyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    bigJobKind?: bigJobKindUpdateOneRequiredWithoutCompanyNestedInput
    midJobKind?: midJobKindUpdateOneRequiredWithoutCompanyNestedInput
    smallJobKind?: smallJobKindUpdateOneRequiredWithoutCompanyNestedInput
    incumebent?: incumbentsAdditionalUpdateManyWithoutCompanyNestedInput
    student?: studentsAdditionalUpdateManyWithoutWishCompanyNestedInput
  }

  export type companyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    bigJobKindId?: IntFieldUpdateOperationsInput | number
    midJobKindId?: IntFieldUpdateOperationsInput | number
    smallJobKindId?: IntFieldUpdateOperationsInput | number
    incumebent?: incumbentsAdditionalUncheckedUpdateManyWithoutCompanyNestedInput
    student?: studentsAdditionalUncheckedUpdateManyWithoutWishCompanyNestedInput
  }

  export type companyCreateManyInput = {
    id?: number
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    bigJobKindId: number
    midJobKindId: number
    smallJobKindId: number
  }

  export type companyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
  }

  export type companyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    bigJobKindId?: IntFieldUpdateOperationsInput | number
    midJobKindId?: IntFieldUpdateOperationsInput | number
    smallJobKindId?: IntFieldUpdateOperationsInput | number
  }

  export type schoolCreateInput = {
    name: string
    branch: string
    major?: majorCreateNestedManyWithoutSchoolInput
    incumebent?: incumbentsAdditionalCreateNestedManyWithoutSchoolInput
    student?: studentsAdditionalCreateNestedManyWithoutSchoolInput
  }

  export type schoolUncheckedCreateInput = {
    id?: number
    name: string
    branch: string
    major?: majorUncheckedCreateNestedManyWithoutSchoolInput
    incumebent?: incumbentsAdditionalUncheckedCreateNestedManyWithoutSchoolInput
    student?: studentsAdditionalUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type schoolUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    major?: majorUpdateManyWithoutSchoolNestedInput
    incumebent?: incumbentsAdditionalUpdateManyWithoutSchoolNestedInput
    student?: studentsAdditionalUpdateManyWithoutSchoolNestedInput
  }

  export type schoolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    major?: majorUncheckedUpdateManyWithoutSchoolNestedInput
    incumebent?: incumbentsAdditionalUncheckedUpdateManyWithoutSchoolNestedInput
    student?: studentsAdditionalUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type schoolCreateManyInput = {
    id?: number
    name: string
    branch: string
  }

  export type schoolUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
  }

  export type schoolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
  }

  export type majorCreateInput = {
    name: string
    dayAndNight: string
    school: schoolCreateNestedOneWithoutMajorInput
    incumebent?: incumbentsAdditionalCreateNestedManyWithoutMajorInput
    student?: studentsAdditionalCreateNestedManyWithoutMajorInput
  }

  export type majorUncheckedCreateInput = {
    id?: number
    schoolId: number
    name: string
    dayAndNight: string
    incumebent?: incumbentsAdditionalUncheckedCreateNestedManyWithoutMajorInput
    student?: studentsAdditionalUncheckedCreateNestedManyWithoutMajorInput
  }

  export type majorUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    dayAndNight?: StringFieldUpdateOperationsInput | string
    school?: schoolUpdateOneRequiredWithoutMajorNestedInput
    incumebent?: incumbentsAdditionalUpdateManyWithoutMajorNestedInput
    student?: studentsAdditionalUpdateManyWithoutMajorNestedInput
  }

  export type majorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dayAndNight?: StringFieldUpdateOperationsInput | string
    incumebent?: incumbentsAdditionalUncheckedUpdateManyWithoutMajorNestedInput
    student?: studentsAdditionalUncheckedUpdateManyWithoutMajorNestedInput
  }

  export type majorCreateManyInput = {
    id?: number
    schoolId: number
    name: string
    dayAndNight: string
  }

  export type majorUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    dayAndNight?: StringFieldUpdateOperationsInput | string
  }

  export type majorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dayAndNight?: StringFieldUpdateOperationsInput | string
  }

  export type bigJobKindCreateInput = {
    name: string
    company?: companyCreateNestedManyWithoutBigJobKindInput
    midJobKind?: midJobKindCreateNestedManyWithoutBigJobKindInput
  }

  export type bigJobKindUncheckedCreateInput = {
    id?: number
    name: string
    company?: companyUncheckedCreateNestedManyWithoutBigJobKindInput
    midJobKind?: midJobKindUncheckedCreateNestedManyWithoutBigJobKindInput
  }

  export type bigJobKindUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    company?: companyUpdateManyWithoutBigJobKindNestedInput
    midJobKind?: midJobKindUpdateManyWithoutBigJobKindNestedInput
  }

  export type bigJobKindUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    company?: companyUncheckedUpdateManyWithoutBigJobKindNestedInput
    midJobKind?: midJobKindUncheckedUpdateManyWithoutBigJobKindNestedInput
  }

  export type bigJobKindCreateManyInput = {
    id?: number
    name: string
  }

  export type bigJobKindUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type bigJobKindUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type midJobKindCreateInput = {
    name: string
    company?: companyCreateNestedManyWithoutMidJobKindInput
    bigJobKind: bigJobKindCreateNestedOneWithoutMidJobKindInput
    smallJobKind?: smallJobKindCreateNestedManyWithoutMidJobKindInput
  }

  export type midJobKindUncheckedCreateInput = {
    id?: number
    bigJobKindId: number
    name: string
    company?: companyUncheckedCreateNestedManyWithoutMidJobKindInput
    smallJobKind?: smallJobKindUncheckedCreateNestedManyWithoutMidJobKindInput
  }

  export type midJobKindUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    company?: companyUpdateManyWithoutMidJobKindNestedInput
    bigJobKind?: bigJobKindUpdateOneRequiredWithoutMidJobKindNestedInput
    smallJobKind?: smallJobKindUpdateManyWithoutMidJobKindNestedInput
  }

  export type midJobKindUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bigJobKindId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    company?: companyUncheckedUpdateManyWithoutMidJobKindNestedInput
    smallJobKind?: smallJobKindUncheckedUpdateManyWithoutMidJobKindNestedInput
  }

  export type midJobKindCreateManyInput = {
    id?: number
    bigJobKindId: number
    name: string
  }

  export type midJobKindUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type midJobKindUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bigJobKindId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type smallJobKindCreateInput = {
    name: string
    company?: companyCreateNestedManyWithoutSmallJobKindInput
    midJobKind: midJobKindCreateNestedOneWithoutSmallJobKindInput
  }

  export type smallJobKindUncheckedCreateInput = {
    id?: number
    midJobKindId: number
    name: string
    company?: companyUncheckedCreateNestedManyWithoutSmallJobKindInput
  }

  export type smallJobKindUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    company?: companyUpdateManyWithoutSmallJobKindNestedInput
    midJobKind?: midJobKindUpdateOneRequiredWithoutSmallJobKindNestedInput
  }

  export type smallJobKindUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    midJobKindId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    company?: companyUncheckedUpdateManyWithoutSmallJobKindNestedInput
  }

  export type smallJobKindCreateManyInput = {
    id?: number
    midJobKindId: number
    name: string
  }

  export type smallJobKindUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type smallJobKindUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    midJobKindId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type jobCreateInput = {
    clusteringGroup: number
    name: string
    incumebent?: incumbentsAdditionalCreateNestedManyWithoutJobInput
    student?: studentsAdditionalCreateNestedManyWithoutWishJobInput
  }

  export type jobUncheckedCreateInput = {
    id?: number
    clusteringGroup: number
    name: string
    incumebent?: incumbentsAdditionalUncheckedCreateNestedManyWithoutJobInput
    student?: studentsAdditionalUncheckedCreateNestedManyWithoutWishJobInput
  }

  export type jobUpdateInput = {
    clusteringGroup?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    incumebent?: incumbentsAdditionalUpdateManyWithoutJobNestedInput
    student?: studentsAdditionalUpdateManyWithoutWishJobNestedInput
  }

  export type jobUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    clusteringGroup?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    incumebent?: incumbentsAdditionalUncheckedUpdateManyWithoutJobNestedInput
    student?: studentsAdditionalUncheckedUpdateManyWithoutWishJobNestedInput
  }

  export type jobCreateManyInput = {
    id?: number
    clusteringGroup: number
    name: string
  }

  export type jobUpdateManyMutationInput = {
    clusteringGroup?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type jobUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    clusteringGroup?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[]
    notIn?: $Enums.Gender[]
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumuserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.userType | EnumuserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.userType[]
    notIn?: $Enums.userType[]
    not?: NestedEnumuserTypeFilter<$PrismaModel> | $Enums.userType
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type IncumbentsAdditionalNullableRelationFilter = {
    is?: incumbentsAdditionalWhereInput | null
    isNot?: incumbentsAdditionalWhereInput | null
  }

  export type StudentsAdditionalNullableRelationFilter = {
    is?: studentsAdditionalWhereInput | null
    isNot?: studentsAdditionalWhereInput | null
  }

  export type PostsListRelationFilter = {
    every?: postsWhereInput
    some?: postsWhereInput
    none?: postsWhereInput
  }

  export type CommentsListRelationFilter = {
    every?: commentsWhereInput
    some?: commentsWhereInput
    none?: commentsWhereInput
  }

  export type RecommendPostsListRelationFilter = {
    every?: recommendPostsWhereInput
    some?: recommendPostsWhereInput
    none?: recommendPostsWhereInput
  }

  export type RecommendCommentsListRelationFilter = {
    every?: recommendCommentsWhereInput
    some?: recommendCommentsWhereInput
    none?: recommendCommentsWhereInput
  }

  export type ReportedPostsListRelationFilter = {
    every?: reportedPostsWhereInput
    some?: reportedPostsWhereInput
    none?: reportedPostsWhereInput
  }

  export type ReportedCommentsListRelationFilter = {
    every?: reportedCommentsWhereInput
    some?: reportedCommentsWhereInput
    none?: reportedCommentsWhereInput
  }

  export type ReportedUsersListRelationFilter = {
    every?: reportedUsersWhereInput
    some?: reportedUsersWhereInput
    none?: reportedUsersWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type postsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type commentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type recommendPostsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type recommendCommentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reportedPostsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reportedCommentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reportedUsersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    image?: SortOrder
    type?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    image?: SortOrder
    type?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    image?: SortOrder
    type?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[]
    notIn?: $Enums.Gender[]
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumuserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.userType | EnumuserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.userType[]
    notIn?: $Enums.userType[]
    not?: NestedEnumuserTypeWithAggregatesFilter<$PrismaModel> | $Enums.userType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuserTypeFilter<$PrismaModel>
    _max?: NestedEnumuserTypeFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type CompanyNullableRelationFilter = {
    is?: companyWhereInput | null
    isNot?: companyWhereInput | null
  }

  export type SchoolNullableRelationFilter = {
    is?: schoolWhereInput | null
    isNot?: schoolWhereInput | null
  }

  export type MajorNullableRelationFilter = {
    is?: majorWhereInput | null
    isNot?: majorWhereInput | null
  }

  export type JobNullableRelationFilter = {
    is?: jobWhereInput | null
    isNot?: jobWhereInput | null
  }

  export type incumbentsAdditionalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    schoolId?: SortOrder
    majorId?: SortOrder
    bigJobId?: SortOrder
    midJobId?: SortOrder
    smallJobId?: SortOrder
    jobId?: SortOrder
    shortSpec?: SortOrder
    reportedNum?: SortOrder
    adviceCount?: SortOrder
    estimationCount?: SortOrder
    updatedDate?: SortOrder
  }

  export type incumbentsAdditionalAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    schoolId?: SortOrder
    majorId?: SortOrder
    bigJobId?: SortOrder
    midJobId?: SortOrder
    smallJobId?: SortOrder
    jobId?: SortOrder
    reportedNum?: SortOrder
    adviceCount?: SortOrder
    estimationCount?: SortOrder
  }

  export type incumbentsAdditionalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    schoolId?: SortOrder
    majorId?: SortOrder
    bigJobId?: SortOrder
    midJobId?: SortOrder
    smallJobId?: SortOrder
    jobId?: SortOrder
    shortSpec?: SortOrder
    reportedNum?: SortOrder
    adviceCount?: SortOrder
    estimationCount?: SortOrder
    updatedDate?: SortOrder
  }

  export type incumbentsAdditionalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    schoolId?: SortOrder
    majorId?: SortOrder
    bigJobId?: SortOrder
    midJobId?: SortOrder
    smallJobId?: SortOrder
    jobId?: SortOrder
    shortSpec?: SortOrder
    reportedNum?: SortOrder
    adviceCount?: SortOrder
    estimationCount?: SortOrder
    updatedDate?: SortOrder
  }

  export type incumbentsAdditionalSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    schoolId?: SortOrder
    majorId?: SortOrder
    bigJobId?: SortOrder
    midJobId?: SortOrder
    smallJobId?: SortOrder
    jobId?: SortOrder
    reportedNum?: SortOrder
    adviceCount?: SortOrder
    estimationCount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type studentsAdditionalCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    wishCompanyId?: SortOrder
    schoolId?: SortOrder
    majorId?: SortOrder
    wishBigJobId?: SortOrder
    wishMidJobId?: SortOrder
    wishSmallJobId?: SortOrder
    wishJobId?: SortOrder
    portfolio?: SortOrder
    reportedNum?: SortOrder
    totalGrade?: SortOrder
    adviceCount?: SortOrder
    estimationCount?: SortOrder
    updatedDate?: SortOrder
  }

  export type studentsAdditionalAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    wishCompanyId?: SortOrder
    schoolId?: SortOrder
    majorId?: SortOrder
    wishBigJobId?: SortOrder
    wishMidJobId?: SortOrder
    wishSmallJobId?: SortOrder
    wishJobId?: SortOrder
    reportedNum?: SortOrder
    totalGrade?: SortOrder
    adviceCount?: SortOrder
    estimationCount?: SortOrder
  }

  export type studentsAdditionalMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    wishCompanyId?: SortOrder
    schoolId?: SortOrder
    majorId?: SortOrder
    wishBigJobId?: SortOrder
    wishMidJobId?: SortOrder
    wishSmallJobId?: SortOrder
    wishJobId?: SortOrder
    portfolio?: SortOrder
    reportedNum?: SortOrder
    totalGrade?: SortOrder
    adviceCount?: SortOrder
    estimationCount?: SortOrder
    updatedDate?: SortOrder
  }

  export type studentsAdditionalMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    wishCompanyId?: SortOrder
    schoolId?: SortOrder
    majorId?: SortOrder
    wishBigJobId?: SortOrder
    wishMidJobId?: SortOrder
    wishSmallJobId?: SortOrder
    wishJobId?: SortOrder
    portfolio?: SortOrder
    reportedNum?: SortOrder
    totalGrade?: SortOrder
    adviceCount?: SortOrder
    estimationCount?: SortOrder
    updatedDate?: SortOrder
  }

  export type studentsAdditionalSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    wishCompanyId?: SortOrder
    schoolId?: SortOrder
    majorId?: SortOrder
    wishBigJobId?: SortOrder
    wishMidJobId?: SortOrder
    wishSmallJobId?: SortOrder
    wishJobId?: SortOrder
    reportedNum?: SortOrder
    totalGrade?: SortOrder
    adviceCount?: SortOrder
    estimationCount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type categoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type categoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type categoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type categorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryNullableRelationFilter = {
    is?: categoryWhereInput | null
    isNot?: categoryWhereInput | null
  }

  export type UsersNullableRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type postsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    view?: SortOrder
    recommend?: SortOrder
    reported?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
  }

  export type postsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    view?: SortOrder
    recommend?: SortOrder
    reported?: SortOrder
  }

  export type postsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    view?: SortOrder
    recommend?: SortOrder
    reported?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
  }

  export type postsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    view?: SortOrder
    recommend?: SortOrder
    reported?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
  }

  export type postsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    view?: SortOrder
    recommend?: SortOrder
    reported?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type PostsRelationFilter = {
    is?: postsWhereInput
    isNot?: postsWhereInput
  }

  export type CommentsNullableRelationFilter = {
    is?: commentsWhereInput | null
    isNot?: commentsWhereInput | null
  }

  export type commentsCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentCommentId?: SortOrder
    recommend?: SortOrder
    reported?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
    isDelete?: SortOrder
  }

  export type commentsAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentCommentId?: SortOrder
    recommend?: SortOrder
    reported?: SortOrder
  }

  export type commentsMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentCommentId?: SortOrder
    recommend?: SortOrder
    reported?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
    isDelete?: SortOrder
  }

  export type commentsMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    parentCommentId?: SortOrder
    recommend?: SortOrder
    reported?: SortOrder
    createdDate?: SortOrder
    updatedDate?: SortOrder
    isDelete?: SortOrder
  }

  export type commentsSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentCommentId?: SortOrder
    recommend?: SortOrder
    reported?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type recommendPostsCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdDate?: SortOrder
  }

  export type recommendPostsAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type recommendPostsMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdDate?: SortOrder
  }

  export type recommendPostsMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    createdDate?: SortOrder
  }

  export type recommendPostsSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type reportedPostsCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdDate?: SortOrder
  }

  export type reportedPostsAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type reportedPostsMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdDate?: SortOrder
  }

  export type reportedPostsMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdDate?: SortOrder
  }

  export type reportedPostsSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type CommentsRelationFilter = {
    is?: commentsWhereInput
    isNot?: commentsWhereInput
  }

  export type recommendCommentsCountOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    createdDate?: SortOrder
  }

  export type recommendCommentsAvgOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
  }

  export type recommendCommentsMaxOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    createdDate?: SortOrder
  }

  export type recommendCommentsMinOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    createdDate?: SortOrder
  }

  export type recommendCommentsSumOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
  }

  export type reportedCommentsCountOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdDate?: SortOrder
  }

  export type reportedCommentsAvgOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
  }

  export type reportedCommentsMaxOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdDate?: SortOrder
  }

  export type reportedCommentsMinOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    createdDate?: SortOrder
  }

  export type reportedCommentsSumOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
  }

  export type reportedUsersCountOrderByAggregateInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    reportingUserId?: SortOrder
    reason?: SortOrder
    createdDate?: SortOrder
  }

  export type reportedUsersAvgOrderByAggregateInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    reportingUserId?: SortOrder
  }

  export type reportedUsersMaxOrderByAggregateInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    reportingUserId?: SortOrder
    reason?: SortOrder
    createdDate?: SortOrder
  }

  export type reportedUsersMinOrderByAggregateInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    reportingUserId?: SortOrder
    reason?: SortOrder
    createdDate?: SortOrder
  }

  export type reportedUsersSumOrderByAggregateInput = {
    id?: SortOrder
    targetUserId?: SortOrder
    reportingUserId?: SortOrder
  }

  export type BigJobKindRelationFilter = {
    is?: bigJobKindWhereInput
    isNot?: bigJobKindWhereInput
  }

  export type MidJobKindRelationFilter = {
    is?: midJobKindWhereInput
    isNot?: midJobKindWhereInput
  }

  export type SmallJobKindRelationFilter = {
    is?: smallJobKindWhereInput
    isNot?: smallJobKindWhereInput
  }

  export type IncumbentsAdditionalListRelationFilter = {
    every?: incumbentsAdditionalWhereInput
    some?: incumbentsAdditionalWhereInput
    none?: incumbentsAdditionalWhereInput
  }

  export type StudentsAdditionalListRelationFilter = {
    every?: studentsAdditionalWhereInput
    some?: studentsAdditionalWhereInput
    none?: studentsAdditionalWhereInput
  }

  export type incumbentsAdditionalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type studentsAdditionalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    scale?: SortOrder
    bigJobKindId?: SortOrder
    midJobKindId?: SortOrder
    smallJobKindId?: SortOrder
  }

  export type companyAvgOrderByAggregateInput = {
    id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    bigJobKindId?: SortOrder
    midJobKindId?: SortOrder
    smallJobKindId?: SortOrder
  }

  export type companyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    scale?: SortOrder
    bigJobKindId?: SortOrder
    midJobKindId?: SortOrder
    smallJobKindId?: SortOrder
  }

  export type companyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    scale?: SortOrder
    bigJobKindId?: SortOrder
    midJobKindId?: SortOrder
    smallJobKindId?: SortOrder
  }

  export type companySumOrderByAggregateInput = {
    id?: SortOrder
    longitude?: SortOrder
    latitude?: SortOrder
    bigJobKindId?: SortOrder
    midJobKindId?: SortOrder
    smallJobKindId?: SortOrder
  }

  export type MajorListRelationFilter = {
    every?: majorWhereInput
    some?: majorWhereInput
    none?: majorWhereInput
  }

  export type majorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type schoolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    branch?: SortOrder
  }

  export type schoolAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type schoolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    branch?: SortOrder
  }

  export type schoolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    branch?: SortOrder
  }

  export type schoolSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SchoolRelationFilter = {
    is?: schoolWhereInput
    isNot?: schoolWhereInput
  }

  export type majorCountOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    dayAndNight?: SortOrder
  }

  export type majorAvgOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type majorMaxOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    dayAndNight?: SortOrder
  }

  export type majorMinOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
    name?: SortOrder
    dayAndNight?: SortOrder
  }

  export type majorSumOrderByAggregateInput = {
    id?: SortOrder
    schoolId?: SortOrder
  }

  export type CompanyListRelationFilter = {
    every?: companyWhereInput
    some?: companyWhereInput
    none?: companyWhereInput
  }

  export type MidJobKindListRelationFilter = {
    every?: midJobKindWhereInput
    some?: midJobKindWhereInput
    none?: midJobKindWhereInput
  }

  export type companyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type midJobKindOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bigJobKindCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type bigJobKindAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type bigJobKindMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type bigJobKindMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type bigJobKindSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SmallJobKindListRelationFilter = {
    every?: smallJobKindWhereInput
    some?: smallJobKindWhereInput
    none?: smallJobKindWhereInput
  }

  export type smallJobKindOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type midJobKindCountOrderByAggregateInput = {
    id?: SortOrder
    bigJobKindId?: SortOrder
    name?: SortOrder
  }

  export type midJobKindAvgOrderByAggregateInput = {
    id?: SortOrder
    bigJobKindId?: SortOrder
  }

  export type midJobKindMaxOrderByAggregateInput = {
    id?: SortOrder
    bigJobKindId?: SortOrder
    name?: SortOrder
  }

  export type midJobKindMinOrderByAggregateInput = {
    id?: SortOrder
    bigJobKindId?: SortOrder
    name?: SortOrder
  }

  export type midJobKindSumOrderByAggregateInput = {
    id?: SortOrder
    bigJobKindId?: SortOrder
  }

  export type smallJobKindCountOrderByAggregateInput = {
    id?: SortOrder
    midJobKindId?: SortOrder
    name?: SortOrder
  }

  export type smallJobKindAvgOrderByAggregateInput = {
    id?: SortOrder
    midJobKindId?: SortOrder
  }

  export type smallJobKindMaxOrderByAggregateInput = {
    id?: SortOrder
    midJobKindId?: SortOrder
    name?: SortOrder
  }

  export type smallJobKindMinOrderByAggregateInput = {
    id?: SortOrder
    midJobKindId?: SortOrder
    name?: SortOrder
  }

  export type smallJobKindSumOrderByAggregateInput = {
    id?: SortOrder
    midJobKindId?: SortOrder
  }

  export type jobCountOrderByAggregateInput = {
    id?: SortOrder
    clusteringGroup?: SortOrder
    name?: SortOrder
  }

  export type jobAvgOrderByAggregateInput = {
    id?: SortOrder
    clusteringGroup?: SortOrder
  }

  export type jobMaxOrderByAggregateInput = {
    id?: SortOrder
    clusteringGroup?: SortOrder
    name?: SortOrder
  }

  export type jobMinOrderByAggregateInput = {
    id?: SortOrder
    clusteringGroup?: SortOrder
    name?: SortOrder
  }

  export type jobSumOrderByAggregateInput = {
    id?: SortOrder
    clusteringGroup?: SortOrder
  }

  export type incumbentsAdditionalCreateNestedOneWithoutUsersInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutUsersInput, incumbentsAdditionalUncheckedCreateWithoutUsersInput>
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutUsersInput
    connect?: incumbentsAdditionalWhereUniqueInput
  }

  export type studentsAdditionalCreateNestedOneWithoutUsersInput = {
    create?: XOR<studentsAdditionalCreateWithoutUsersInput, studentsAdditionalUncheckedCreateWithoutUsersInput>
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutUsersInput
    connect?: studentsAdditionalWhereUniqueInput
  }

  export type postsCreateNestedManyWithoutUsersInput = {
    create?: XOR<postsCreateWithoutUsersInput, postsUncheckedCreateWithoutUsersInput> | postsCreateWithoutUsersInput[] | postsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: postsCreateOrConnectWithoutUsersInput | postsCreateOrConnectWithoutUsersInput[]
    createMany?: postsCreateManyUsersInputEnvelope
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
  }

  export type commentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type recommendPostsCreateNestedManyWithoutUsersInput = {
    create?: XOR<recommendPostsCreateWithoutUsersInput, recommendPostsUncheckedCreateWithoutUsersInput> | recommendPostsCreateWithoutUsersInput[] | recommendPostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: recommendPostsCreateOrConnectWithoutUsersInput | recommendPostsCreateOrConnectWithoutUsersInput[]
    createMany?: recommendPostsCreateManyUsersInputEnvelope
    connect?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
  }

  export type recommendCommentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<recommendCommentsCreateWithoutUsersInput, recommendCommentsUncheckedCreateWithoutUsersInput> | recommendCommentsCreateWithoutUsersInput[] | recommendCommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: recommendCommentsCreateOrConnectWithoutUsersInput | recommendCommentsCreateOrConnectWithoutUsersInput[]
    createMany?: recommendCommentsCreateManyUsersInputEnvelope
    connect?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
  }

  export type reportedPostsCreateNestedManyWithoutUsersInput = {
    create?: XOR<reportedPostsCreateWithoutUsersInput, reportedPostsUncheckedCreateWithoutUsersInput> | reportedPostsCreateWithoutUsersInput[] | reportedPostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportedPostsCreateOrConnectWithoutUsersInput | reportedPostsCreateOrConnectWithoutUsersInput[]
    createMany?: reportedPostsCreateManyUsersInputEnvelope
    connect?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
  }

  export type reportedCommentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<reportedCommentsCreateWithoutUsersInput, reportedCommentsUncheckedCreateWithoutUsersInput> | reportedCommentsCreateWithoutUsersInput[] | reportedCommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportedCommentsCreateOrConnectWithoutUsersInput | reportedCommentsCreateOrConnectWithoutUsersInput[]
    createMany?: reportedCommentsCreateManyUsersInputEnvelope
    connect?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
  }

  export type reportedUsersCreateNestedManyWithoutUsersInput = {
    create?: XOR<reportedUsersCreateWithoutUsersInput, reportedUsersUncheckedCreateWithoutUsersInput> | reportedUsersCreateWithoutUsersInput[] | reportedUsersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportedUsersCreateOrConnectWithoutUsersInput | reportedUsersCreateOrConnectWithoutUsersInput[]
    createMany?: reportedUsersCreateManyUsersInputEnvelope
    connect?: reportedUsersWhereUniqueInput | reportedUsersWhereUniqueInput[]
  }

  export type incumbentsAdditionalUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutUsersInput, incumbentsAdditionalUncheckedCreateWithoutUsersInput>
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutUsersInput
    connect?: incumbentsAdditionalWhereUniqueInput
  }

  export type studentsAdditionalUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<studentsAdditionalCreateWithoutUsersInput, studentsAdditionalUncheckedCreateWithoutUsersInput>
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutUsersInput
    connect?: studentsAdditionalWhereUniqueInput
  }

  export type postsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<postsCreateWithoutUsersInput, postsUncheckedCreateWithoutUsersInput> | postsCreateWithoutUsersInput[] | postsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: postsCreateOrConnectWithoutUsersInput | postsCreateOrConnectWithoutUsersInput[]
    createMany?: postsCreateManyUsersInputEnvelope
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
  }

  export type commentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type recommendPostsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<recommendPostsCreateWithoutUsersInput, recommendPostsUncheckedCreateWithoutUsersInput> | recommendPostsCreateWithoutUsersInput[] | recommendPostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: recommendPostsCreateOrConnectWithoutUsersInput | recommendPostsCreateOrConnectWithoutUsersInput[]
    createMany?: recommendPostsCreateManyUsersInputEnvelope
    connect?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
  }

  export type recommendCommentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<recommendCommentsCreateWithoutUsersInput, recommendCommentsUncheckedCreateWithoutUsersInput> | recommendCommentsCreateWithoutUsersInput[] | recommendCommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: recommendCommentsCreateOrConnectWithoutUsersInput | recommendCommentsCreateOrConnectWithoutUsersInput[]
    createMany?: recommendCommentsCreateManyUsersInputEnvelope
    connect?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
  }

  export type reportedPostsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<reportedPostsCreateWithoutUsersInput, reportedPostsUncheckedCreateWithoutUsersInput> | reportedPostsCreateWithoutUsersInput[] | reportedPostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportedPostsCreateOrConnectWithoutUsersInput | reportedPostsCreateOrConnectWithoutUsersInput[]
    createMany?: reportedPostsCreateManyUsersInputEnvelope
    connect?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
  }

  export type reportedCommentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<reportedCommentsCreateWithoutUsersInput, reportedCommentsUncheckedCreateWithoutUsersInput> | reportedCommentsCreateWithoutUsersInput[] | reportedCommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportedCommentsCreateOrConnectWithoutUsersInput | reportedCommentsCreateOrConnectWithoutUsersInput[]
    createMany?: reportedCommentsCreateManyUsersInputEnvelope
    connect?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
  }

  export type reportedUsersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<reportedUsersCreateWithoutUsersInput, reportedUsersUncheckedCreateWithoutUsersInput> | reportedUsersCreateWithoutUsersInput[] | reportedUsersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportedUsersCreateOrConnectWithoutUsersInput | reportedUsersCreateOrConnectWithoutUsersInput[]
    createMany?: reportedUsersCreateManyUsersInputEnvelope
    connect?: reportedUsersWhereUniqueInput | reportedUsersWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumuserTypeFieldUpdateOperationsInput = {
    set?: $Enums.userType
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type incumbentsAdditionalUpdateOneWithoutUsersNestedInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutUsersInput, incumbentsAdditionalUncheckedCreateWithoutUsersInput>
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutUsersInput
    upsert?: incumbentsAdditionalUpsertWithoutUsersInput
    disconnect?: incumbentsAdditionalWhereInput | boolean
    delete?: incumbentsAdditionalWhereInput | boolean
    connect?: incumbentsAdditionalWhereUniqueInput
    update?: XOR<XOR<incumbentsAdditionalUpdateToOneWithWhereWithoutUsersInput, incumbentsAdditionalUpdateWithoutUsersInput>, incumbentsAdditionalUncheckedUpdateWithoutUsersInput>
  }

  export type studentsAdditionalUpdateOneWithoutUsersNestedInput = {
    create?: XOR<studentsAdditionalCreateWithoutUsersInput, studentsAdditionalUncheckedCreateWithoutUsersInput>
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutUsersInput
    upsert?: studentsAdditionalUpsertWithoutUsersInput
    disconnect?: studentsAdditionalWhereInput | boolean
    delete?: studentsAdditionalWhereInput | boolean
    connect?: studentsAdditionalWhereUniqueInput
    update?: XOR<XOR<studentsAdditionalUpdateToOneWithWhereWithoutUsersInput, studentsAdditionalUpdateWithoutUsersInput>, studentsAdditionalUncheckedUpdateWithoutUsersInput>
  }

  export type postsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<postsCreateWithoutUsersInput, postsUncheckedCreateWithoutUsersInput> | postsCreateWithoutUsersInput[] | postsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: postsCreateOrConnectWithoutUsersInput | postsCreateOrConnectWithoutUsersInput[]
    upsert?: postsUpsertWithWhereUniqueWithoutUsersInput | postsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: postsCreateManyUsersInputEnvelope
    set?: postsWhereUniqueInput | postsWhereUniqueInput[]
    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    update?: postsUpdateWithWhereUniqueWithoutUsersInput | postsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: postsUpdateManyWithWhereWithoutUsersInput | postsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]
  }

  export type commentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutUsersInput | commentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutUsersInput | commentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutUsersInput | commentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type recommendPostsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<recommendPostsCreateWithoutUsersInput, recommendPostsUncheckedCreateWithoutUsersInput> | recommendPostsCreateWithoutUsersInput[] | recommendPostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: recommendPostsCreateOrConnectWithoutUsersInput | recommendPostsCreateOrConnectWithoutUsersInput[]
    upsert?: recommendPostsUpsertWithWhereUniqueWithoutUsersInput | recommendPostsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: recommendPostsCreateManyUsersInputEnvelope
    set?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    disconnect?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    delete?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    connect?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    update?: recommendPostsUpdateWithWhereUniqueWithoutUsersInput | recommendPostsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: recommendPostsUpdateManyWithWhereWithoutUsersInput | recommendPostsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: recommendPostsScalarWhereInput | recommendPostsScalarWhereInput[]
  }

  export type recommendCommentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<recommendCommentsCreateWithoutUsersInput, recommendCommentsUncheckedCreateWithoutUsersInput> | recommendCommentsCreateWithoutUsersInput[] | recommendCommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: recommendCommentsCreateOrConnectWithoutUsersInput | recommendCommentsCreateOrConnectWithoutUsersInput[]
    upsert?: recommendCommentsUpsertWithWhereUniqueWithoutUsersInput | recommendCommentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: recommendCommentsCreateManyUsersInputEnvelope
    set?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    disconnect?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    delete?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    connect?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    update?: recommendCommentsUpdateWithWhereUniqueWithoutUsersInput | recommendCommentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: recommendCommentsUpdateManyWithWhereWithoutUsersInput | recommendCommentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: recommendCommentsScalarWhereInput | recommendCommentsScalarWhereInput[]
  }

  export type reportedPostsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<reportedPostsCreateWithoutUsersInput, reportedPostsUncheckedCreateWithoutUsersInput> | reportedPostsCreateWithoutUsersInput[] | reportedPostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportedPostsCreateOrConnectWithoutUsersInput | reportedPostsCreateOrConnectWithoutUsersInput[]
    upsert?: reportedPostsUpsertWithWhereUniqueWithoutUsersInput | reportedPostsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: reportedPostsCreateManyUsersInputEnvelope
    set?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    disconnect?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    delete?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    connect?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    update?: reportedPostsUpdateWithWhereUniqueWithoutUsersInput | reportedPostsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: reportedPostsUpdateManyWithWhereWithoutUsersInput | reportedPostsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: reportedPostsScalarWhereInput | reportedPostsScalarWhereInput[]
  }

  export type reportedCommentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<reportedCommentsCreateWithoutUsersInput, reportedCommentsUncheckedCreateWithoutUsersInput> | reportedCommentsCreateWithoutUsersInput[] | reportedCommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportedCommentsCreateOrConnectWithoutUsersInput | reportedCommentsCreateOrConnectWithoutUsersInput[]
    upsert?: reportedCommentsUpsertWithWhereUniqueWithoutUsersInput | reportedCommentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: reportedCommentsCreateManyUsersInputEnvelope
    set?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    disconnect?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    delete?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    connect?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    update?: reportedCommentsUpdateWithWhereUniqueWithoutUsersInput | reportedCommentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: reportedCommentsUpdateManyWithWhereWithoutUsersInput | reportedCommentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: reportedCommentsScalarWhereInput | reportedCommentsScalarWhereInput[]
  }

  export type reportedUsersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<reportedUsersCreateWithoutUsersInput, reportedUsersUncheckedCreateWithoutUsersInput> | reportedUsersCreateWithoutUsersInput[] | reportedUsersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportedUsersCreateOrConnectWithoutUsersInput | reportedUsersCreateOrConnectWithoutUsersInput[]
    upsert?: reportedUsersUpsertWithWhereUniqueWithoutUsersInput | reportedUsersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: reportedUsersCreateManyUsersInputEnvelope
    set?: reportedUsersWhereUniqueInput | reportedUsersWhereUniqueInput[]
    disconnect?: reportedUsersWhereUniqueInput | reportedUsersWhereUniqueInput[]
    delete?: reportedUsersWhereUniqueInput | reportedUsersWhereUniqueInput[]
    connect?: reportedUsersWhereUniqueInput | reportedUsersWhereUniqueInput[]
    update?: reportedUsersUpdateWithWhereUniqueWithoutUsersInput | reportedUsersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: reportedUsersUpdateManyWithWhereWithoutUsersInput | reportedUsersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: reportedUsersScalarWhereInput | reportedUsersScalarWhereInput[]
  }

  export type incumbentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutUsersInput, incumbentsAdditionalUncheckedCreateWithoutUsersInput>
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutUsersInput
    upsert?: incumbentsAdditionalUpsertWithoutUsersInput
    disconnect?: incumbentsAdditionalWhereInput | boolean
    delete?: incumbentsAdditionalWhereInput | boolean
    connect?: incumbentsAdditionalWhereUniqueInput
    update?: XOR<XOR<incumbentsAdditionalUpdateToOneWithWhereWithoutUsersInput, incumbentsAdditionalUpdateWithoutUsersInput>, incumbentsAdditionalUncheckedUpdateWithoutUsersInput>
  }

  export type studentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<studentsAdditionalCreateWithoutUsersInput, studentsAdditionalUncheckedCreateWithoutUsersInput>
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutUsersInput
    upsert?: studentsAdditionalUpsertWithoutUsersInput
    disconnect?: studentsAdditionalWhereInput | boolean
    delete?: studentsAdditionalWhereInput | boolean
    connect?: studentsAdditionalWhereUniqueInput
    update?: XOR<XOR<studentsAdditionalUpdateToOneWithWhereWithoutUsersInput, studentsAdditionalUpdateWithoutUsersInput>, studentsAdditionalUncheckedUpdateWithoutUsersInput>
  }

  export type postsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<postsCreateWithoutUsersInput, postsUncheckedCreateWithoutUsersInput> | postsCreateWithoutUsersInput[] | postsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: postsCreateOrConnectWithoutUsersInput | postsCreateOrConnectWithoutUsersInput[]
    upsert?: postsUpsertWithWhereUniqueWithoutUsersInput | postsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: postsCreateManyUsersInputEnvelope
    set?: postsWhereUniqueInput | postsWhereUniqueInput[]
    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    update?: postsUpdateWithWhereUniqueWithoutUsersInput | postsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: postsUpdateManyWithWhereWithoutUsersInput | postsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]
  }

  export type commentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutUsersInput | commentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutUsersInput | commentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutUsersInput | commentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type recommendPostsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<recommendPostsCreateWithoutUsersInput, recommendPostsUncheckedCreateWithoutUsersInput> | recommendPostsCreateWithoutUsersInput[] | recommendPostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: recommendPostsCreateOrConnectWithoutUsersInput | recommendPostsCreateOrConnectWithoutUsersInput[]
    upsert?: recommendPostsUpsertWithWhereUniqueWithoutUsersInput | recommendPostsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: recommendPostsCreateManyUsersInputEnvelope
    set?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    disconnect?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    delete?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    connect?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    update?: recommendPostsUpdateWithWhereUniqueWithoutUsersInput | recommendPostsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: recommendPostsUpdateManyWithWhereWithoutUsersInput | recommendPostsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: recommendPostsScalarWhereInput | recommendPostsScalarWhereInput[]
  }

  export type recommendCommentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<recommendCommentsCreateWithoutUsersInput, recommendCommentsUncheckedCreateWithoutUsersInput> | recommendCommentsCreateWithoutUsersInput[] | recommendCommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: recommendCommentsCreateOrConnectWithoutUsersInput | recommendCommentsCreateOrConnectWithoutUsersInput[]
    upsert?: recommendCommentsUpsertWithWhereUniqueWithoutUsersInput | recommendCommentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: recommendCommentsCreateManyUsersInputEnvelope
    set?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    disconnect?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    delete?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    connect?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    update?: recommendCommentsUpdateWithWhereUniqueWithoutUsersInput | recommendCommentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: recommendCommentsUpdateManyWithWhereWithoutUsersInput | recommendCommentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: recommendCommentsScalarWhereInput | recommendCommentsScalarWhereInput[]
  }

  export type reportedPostsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<reportedPostsCreateWithoutUsersInput, reportedPostsUncheckedCreateWithoutUsersInput> | reportedPostsCreateWithoutUsersInput[] | reportedPostsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportedPostsCreateOrConnectWithoutUsersInput | reportedPostsCreateOrConnectWithoutUsersInput[]
    upsert?: reportedPostsUpsertWithWhereUniqueWithoutUsersInput | reportedPostsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: reportedPostsCreateManyUsersInputEnvelope
    set?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    disconnect?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    delete?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    connect?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    update?: reportedPostsUpdateWithWhereUniqueWithoutUsersInput | reportedPostsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: reportedPostsUpdateManyWithWhereWithoutUsersInput | reportedPostsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: reportedPostsScalarWhereInput | reportedPostsScalarWhereInput[]
  }

  export type reportedCommentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<reportedCommentsCreateWithoutUsersInput, reportedCommentsUncheckedCreateWithoutUsersInput> | reportedCommentsCreateWithoutUsersInput[] | reportedCommentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportedCommentsCreateOrConnectWithoutUsersInput | reportedCommentsCreateOrConnectWithoutUsersInput[]
    upsert?: reportedCommentsUpsertWithWhereUniqueWithoutUsersInput | reportedCommentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: reportedCommentsCreateManyUsersInputEnvelope
    set?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    disconnect?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    delete?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    connect?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    update?: reportedCommentsUpdateWithWhereUniqueWithoutUsersInput | reportedCommentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: reportedCommentsUpdateManyWithWhereWithoutUsersInput | reportedCommentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: reportedCommentsScalarWhereInput | reportedCommentsScalarWhereInput[]
  }

  export type reportedUsersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<reportedUsersCreateWithoutUsersInput, reportedUsersUncheckedCreateWithoutUsersInput> | reportedUsersCreateWithoutUsersInput[] | reportedUsersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: reportedUsersCreateOrConnectWithoutUsersInput | reportedUsersCreateOrConnectWithoutUsersInput[]
    upsert?: reportedUsersUpsertWithWhereUniqueWithoutUsersInput | reportedUsersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: reportedUsersCreateManyUsersInputEnvelope
    set?: reportedUsersWhereUniqueInput | reportedUsersWhereUniqueInput[]
    disconnect?: reportedUsersWhereUniqueInput | reportedUsersWhereUniqueInput[]
    delete?: reportedUsersWhereUniqueInput | reportedUsersWhereUniqueInput[]
    connect?: reportedUsersWhereUniqueInput | reportedUsersWhereUniqueInput[]
    update?: reportedUsersUpdateWithWhereUniqueWithoutUsersInput | reportedUsersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: reportedUsersUpdateManyWithWhereWithoutUsersInput | reportedUsersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: reportedUsersScalarWhereInput | reportedUsersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutIncumbent_additionalInput = {
    create?: XOR<usersCreateWithoutIncumbent_additionalInput, usersUncheckedCreateWithoutIncumbent_additionalInput>
    connectOrCreate?: usersCreateOrConnectWithoutIncumbent_additionalInput
    connect?: usersWhereUniqueInput
  }

  export type companyCreateNestedOneWithoutIncumebentInput = {
    create?: XOR<companyCreateWithoutIncumebentInput, companyUncheckedCreateWithoutIncumebentInput>
    connectOrCreate?: companyCreateOrConnectWithoutIncumebentInput
    connect?: companyWhereUniqueInput
  }

  export type schoolCreateNestedOneWithoutIncumebentInput = {
    create?: XOR<schoolCreateWithoutIncumebentInput, schoolUncheckedCreateWithoutIncumebentInput>
    connectOrCreate?: schoolCreateOrConnectWithoutIncumebentInput
    connect?: schoolWhereUniqueInput
  }

  export type majorCreateNestedOneWithoutIncumebentInput = {
    create?: XOR<majorCreateWithoutIncumebentInput, majorUncheckedCreateWithoutIncumebentInput>
    connectOrCreate?: majorCreateOrConnectWithoutIncumebentInput
    connect?: majorWhereUniqueInput
  }

  export type jobCreateNestedOneWithoutIncumebentInput = {
    create?: XOR<jobCreateWithoutIncumebentInput, jobUncheckedCreateWithoutIncumebentInput>
    connectOrCreate?: jobCreateOrConnectWithoutIncumebentInput
    connect?: jobWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usersUpdateOneRequiredWithoutIncumbent_additionalNestedInput = {
    create?: XOR<usersCreateWithoutIncumbent_additionalInput, usersUncheckedCreateWithoutIncumbent_additionalInput>
    connectOrCreate?: usersCreateOrConnectWithoutIncumbent_additionalInput
    upsert?: usersUpsertWithoutIncumbent_additionalInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutIncumbent_additionalInput, usersUpdateWithoutIncumbent_additionalInput>, usersUncheckedUpdateWithoutIncumbent_additionalInput>
  }

  export type companyUpdateOneWithoutIncumebentNestedInput = {
    create?: XOR<companyCreateWithoutIncumebentInput, companyUncheckedCreateWithoutIncumebentInput>
    connectOrCreate?: companyCreateOrConnectWithoutIncumebentInput
    upsert?: companyUpsertWithoutIncumebentInput
    disconnect?: companyWhereInput | boolean
    delete?: companyWhereInput | boolean
    connect?: companyWhereUniqueInput
    update?: XOR<XOR<companyUpdateToOneWithWhereWithoutIncumebentInput, companyUpdateWithoutIncumebentInput>, companyUncheckedUpdateWithoutIncumebentInput>
  }

  export type schoolUpdateOneWithoutIncumebentNestedInput = {
    create?: XOR<schoolCreateWithoutIncumebentInput, schoolUncheckedCreateWithoutIncumebentInput>
    connectOrCreate?: schoolCreateOrConnectWithoutIncumebentInput
    upsert?: schoolUpsertWithoutIncumebentInput
    disconnect?: schoolWhereInput | boolean
    delete?: schoolWhereInput | boolean
    connect?: schoolWhereUniqueInput
    update?: XOR<XOR<schoolUpdateToOneWithWhereWithoutIncumebentInput, schoolUpdateWithoutIncumebentInput>, schoolUncheckedUpdateWithoutIncumebentInput>
  }

  export type majorUpdateOneWithoutIncumebentNestedInput = {
    create?: XOR<majorCreateWithoutIncumebentInput, majorUncheckedCreateWithoutIncumebentInput>
    connectOrCreate?: majorCreateOrConnectWithoutIncumebentInput
    upsert?: majorUpsertWithoutIncumebentInput
    disconnect?: majorWhereInput | boolean
    delete?: majorWhereInput | boolean
    connect?: majorWhereUniqueInput
    update?: XOR<XOR<majorUpdateToOneWithWhereWithoutIncumebentInput, majorUpdateWithoutIncumebentInput>, majorUncheckedUpdateWithoutIncumebentInput>
  }

  export type jobUpdateOneWithoutIncumebentNestedInput = {
    create?: XOR<jobCreateWithoutIncumebentInput, jobUncheckedCreateWithoutIncumebentInput>
    connectOrCreate?: jobCreateOrConnectWithoutIncumebentInput
    upsert?: jobUpsertWithoutIncumebentInput
    disconnect?: jobWhereInput | boolean
    delete?: jobWhereInput | boolean
    connect?: jobWhereUniqueInput
    update?: XOR<XOR<jobUpdateToOneWithWhereWithoutIncumebentInput, jobUpdateWithoutIncumebentInput>, jobUncheckedUpdateWithoutIncumebentInput>
  }

  export type usersCreateNestedOneWithoutStudent_additionalInput = {
    create?: XOR<usersCreateWithoutStudent_additionalInput, usersUncheckedCreateWithoutStudent_additionalInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudent_additionalInput
    connect?: usersWhereUniqueInput
  }

  export type companyCreateNestedOneWithoutStudentInput = {
    create?: XOR<companyCreateWithoutStudentInput, companyUncheckedCreateWithoutStudentInput>
    connectOrCreate?: companyCreateOrConnectWithoutStudentInput
    connect?: companyWhereUniqueInput
  }

  export type schoolCreateNestedOneWithoutStudentInput = {
    create?: XOR<schoolCreateWithoutStudentInput, schoolUncheckedCreateWithoutStudentInput>
    connectOrCreate?: schoolCreateOrConnectWithoutStudentInput
    connect?: schoolWhereUniqueInput
  }

  export type majorCreateNestedOneWithoutStudentInput = {
    create?: XOR<majorCreateWithoutStudentInput, majorUncheckedCreateWithoutStudentInput>
    connectOrCreate?: majorCreateOrConnectWithoutStudentInput
    connect?: majorWhereUniqueInput
  }

  export type jobCreateNestedOneWithoutStudentInput = {
    create?: XOR<jobCreateWithoutStudentInput, jobUncheckedCreateWithoutStudentInput>
    connectOrCreate?: jobCreateOrConnectWithoutStudentInput
    connect?: jobWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type usersUpdateOneRequiredWithoutStudent_additionalNestedInput = {
    create?: XOR<usersCreateWithoutStudent_additionalInput, usersUncheckedCreateWithoutStudent_additionalInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudent_additionalInput
    upsert?: usersUpsertWithoutStudent_additionalInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutStudent_additionalInput, usersUpdateWithoutStudent_additionalInput>, usersUncheckedUpdateWithoutStudent_additionalInput>
  }

  export type companyUpdateOneWithoutStudentNestedInput = {
    create?: XOR<companyCreateWithoutStudentInput, companyUncheckedCreateWithoutStudentInput>
    connectOrCreate?: companyCreateOrConnectWithoutStudentInput
    upsert?: companyUpsertWithoutStudentInput
    disconnect?: companyWhereInput | boolean
    delete?: companyWhereInput | boolean
    connect?: companyWhereUniqueInput
    update?: XOR<XOR<companyUpdateToOneWithWhereWithoutStudentInput, companyUpdateWithoutStudentInput>, companyUncheckedUpdateWithoutStudentInput>
  }

  export type schoolUpdateOneWithoutStudentNestedInput = {
    create?: XOR<schoolCreateWithoutStudentInput, schoolUncheckedCreateWithoutStudentInput>
    connectOrCreate?: schoolCreateOrConnectWithoutStudentInput
    upsert?: schoolUpsertWithoutStudentInput
    disconnect?: schoolWhereInput | boolean
    delete?: schoolWhereInput | boolean
    connect?: schoolWhereUniqueInput
    update?: XOR<XOR<schoolUpdateToOneWithWhereWithoutStudentInput, schoolUpdateWithoutStudentInput>, schoolUncheckedUpdateWithoutStudentInput>
  }

  export type majorUpdateOneWithoutStudentNestedInput = {
    create?: XOR<majorCreateWithoutStudentInput, majorUncheckedCreateWithoutStudentInput>
    connectOrCreate?: majorCreateOrConnectWithoutStudentInput
    upsert?: majorUpsertWithoutStudentInput
    disconnect?: majorWhereInput | boolean
    delete?: majorWhereInput | boolean
    connect?: majorWhereUniqueInput
    update?: XOR<XOR<majorUpdateToOneWithWhereWithoutStudentInput, majorUpdateWithoutStudentInput>, majorUncheckedUpdateWithoutStudentInput>
  }

  export type jobUpdateOneWithoutStudentNestedInput = {
    create?: XOR<jobCreateWithoutStudentInput, jobUncheckedCreateWithoutStudentInput>
    connectOrCreate?: jobCreateOrConnectWithoutStudentInput
    upsert?: jobUpsertWithoutStudentInput
    disconnect?: jobWhereInput | boolean
    delete?: jobWhereInput | boolean
    connect?: jobWhereUniqueInput
    update?: XOR<XOR<jobUpdateToOneWithWhereWithoutStudentInput, jobUpdateWithoutStudentInput>, jobUncheckedUpdateWithoutStudentInput>
  }

  export type postsCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<postsCreateWithoutCategoriesInput, postsUncheckedCreateWithoutCategoriesInput> | postsCreateWithoutCategoriesInput[] | postsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutCategoriesInput | postsCreateOrConnectWithoutCategoriesInput[]
    createMany?: postsCreateManyCategoriesInputEnvelope
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
  }

  export type postsUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<postsCreateWithoutCategoriesInput, postsUncheckedCreateWithoutCategoriesInput> | postsCreateWithoutCategoriesInput[] | postsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutCategoriesInput | postsCreateOrConnectWithoutCategoriesInput[]
    createMany?: postsCreateManyCategoriesInputEnvelope
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
  }

  export type postsUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<postsCreateWithoutCategoriesInput, postsUncheckedCreateWithoutCategoriesInput> | postsCreateWithoutCategoriesInput[] | postsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutCategoriesInput | postsCreateOrConnectWithoutCategoriesInput[]
    upsert?: postsUpsertWithWhereUniqueWithoutCategoriesInput | postsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: postsCreateManyCategoriesInputEnvelope
    set?: postsWhereUniqueInput | postsWhereUniqueInput[]
    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    update?: postsUpdateWithWhereUniqueWithoutCategoriesInput | postsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: postsUpdateManyWithWhereWithoutCategoriesInput | postsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]
  }

  export type postsUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<postsCreateWithoutCategoriesInput, postsUncheckedCreateWithoutCategoriesInput> | postsCreateWithoutCategoriesInput[] | postsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutCategoriesInput | postsCreateOrConnectWithoutCategoriesInput[]
    upsert?: postsUpsertWithWhereUniqueWithoutCategoriesInput | postsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: postsCreateManyCategoriesInputEnvelope
    set?: postsWhereUniqueInput | postsWhereUniqueInput[]
    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    update?: postsUpdateWithWhereUniqueWithoutCategoriesInput | postsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: postsUpdateManyWithWhereWithoutCategoriesInput | postsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]
  }

  export type categoryCreateNestedOneWithoutPostsInput = {
    create?: XOR<categoryCreateWithoutPostsInput, categoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: categoryCreateOrConnectWithoutPostsInput
    connect?: categoryWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutPostsInput = {
    create?: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPostsInput
    connect?: usersWhereUniqueInput
  }

  export type commentsCreateNestedManyWithoutPostInput = {
    create?: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput> | commentsCreateWithoutPostInput[] | commentsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutPostInput | commentsCreateOrConnectWithoutPostInput[]
    createMany?: commentsCreateManyPostInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type recommendPostsCreateNestedManyWithoutPostInput = {
    create?: XOR<recommendPostsCreateWithoutPostInput, recommendPostsUncheckedCreateWithoutPostInput> | recommendPostsCreateWithoutPostInput[] | recommendPostsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: recommendPostsCreateOrConnectWithoutPostInput | recommendPostsCreateOrConnectWithoutPostInput[]
    createMany?: recommendPostsCreateManyPostInputEnvelope
    connect?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
  }

  export type reportedPostsCreateNestedManyWithoutPostInput = {
    create?: XOR<reportedPostsCreateWithoutPostInput, reportedPostsUncheckedCreateWithoutPostInput> | reportedPostsCreateWithoutPostInput[] | reportedPostsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: reportedPostsCreateOrConnectWithoutPostInput | reportedPostsCreateOrConnectWithoutPostInput[]
    createMany?: reportedPostsCreateManyPostInputEnvelope
    connect?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
  }

  export type commentsUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput> | commentsCreateWithoutPostInput[] | commentsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutPostInput | commentsCreateOrConnectWithoutPostInput[]
    createMany?: commentsCreateManyPostInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type recommendPostsUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<recommendPostsCreateWithoutPostInput, recommendPostsUncheckedCreateWithoutPostInput> | recommendPostsCreateWithoutPostInput[] | recommendPostsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: recommendPostsCreateOrConnectWithoutPostInput | recommendPostsCreateOrConnectWithoutPostInput[]
    createMany?: recommendPostsCreateManyPostInputEnvelope
    connect?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
  }

  export type reportedPostsUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<reportedPostsCreateWithoutPostInput, reportedPostsUncheckedCreateWithoutPostInput> | reportedPostsCreateWithoutPostInput[] | reportedPostsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: reportedPostsCreateOrConnectWithoutPostInput | reportedPostsCreateOrConnectWithoutPostInput[]
    createMany?: reportedPostsCreateManyPostInputEnvelope
    connect?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
  }

  export type categoryUpdateOneWithoutPostsNestedInput = {
    create?: XOR<categoryCreateWithoutPostsInput, categoryUncheckedCreateWithoutPostsInput>
    connectOrCreate?: categoryCreateOrConnectWithoutPostsInput
    upsert?: categoryUpsertWithoutPostsInput
    disconnect?: categoryWhereInput | boolean
    delete?: categoryWhereInput | boolean
    connect?: categoryWhereUniqueInput
    update?: XOR<XOR<categoryUpdateToOneWithWhereWithoutPostsInput, categoryUpdateWithoutPostsInput>, categoryUncheckedUpdateWithoutPostsInput>
  }

  export type usersUpdateOneWithoutPostsNestedInput = {
    create?: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPostsInput
    upsert?: usersUpsertWithoutPostsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPostsInput, usersUpdateWithoutPostsInput>, usersUncheckedUpdateWithoutPostsInput>
  }

  export type commentsUpdateManyWithoutPostNestedInput = {
    create?: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput> | commentsCreateWithoutPostInput[] | commentsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutPostInput | commentsCreateOrConnectWithoutPostInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutPostInput | commentsUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: commentsCreateManyPostInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutPostInput | commentsUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutPostInput | commentsUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type recommendPostsUpdateManyWithoutPostNestedInput = {
    create?: XOR<recommendPostsCreateWithoutPostInput, recommendPostsUncheckedCreateWithoutPostInput> | recommendPostsCreateWithoutPostInput[] | recommendPostsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: recommendPostsCreateOrConnectWithoutPostInput | recommendPostsCreateOrConnectWithoutPostInput[]
    upsert?: recommendPostsUpsertWithWhereUniqueWithoutPostInput | recommendPostsUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: recommendPostsCreateManyPostInputEnvelope
    set?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    disconnect?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    delete?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    connect?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    update?: recommendPostsUpdateWithWhereUniqueWithoutPostInput | recommendPostsUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: recommendPostsUpdateManyWithWhereWithoutPostInput | recommendPostsUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: recommendPostsScalarWhereInput | recommendPostsScalarWhereInput[]
  }

  export type reportedPostsUpdateManyWithoutPostNestedInput = {
    create?: XOR<reportedPostsCreateWithoutPostInput, reportedPostsUncheckedCreateWithoutPostInput> | reportedPostsCreateWithoutPostInput[] | reportedPostsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: reportedPostsCreateOrConnectWithoutPostInput | reportedPostsCreateOrConnectWithoutPostInput[]
    upsert?: reportedPostsUpsertWithWhereUniqueWithoutPostInput | reportedPostsUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: reportedPostsCreateManyPostInputEnvelope
    set?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    disconnect?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    delete?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    connect?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    update?: reportedPostsUpdateWithWhereUniqueWithoutPostInput | reportedPostsUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: reportedPostsUpdateManyWithWhereWithoutPostInput | reportedPostsUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: reportedPostsScalarWhereInput | reportedPostsScalarWhereInput[]
  }

  export type commentsUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput> | commentsCreateWithoutPostInput[] | commentsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutPostInput | commentsCreateOrConnectWithoutPostInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutPostInput | commentsUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: commentsCreateManyPostInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutPostInput | commentsUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutPostInput | commentsUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type recommendPostsUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<recommendPostsCreateWithoutPostInput, recommendPostsUncheckedCreateWithoutPostInput> | recommendPostsCreateWithoutPostInput[] | recommendPostsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: recommendPostsCreateOrConnectWithoutPostInput | recommendPostsCreateOrConnectWithoutPostInput[]
    upsert?: recommendPostsUpsertWithWhereUniqueWithoutPostInput | recommendPostsUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: recommendPostsCreateManyPostInputEnvelope
    set?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    disconnect?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    delete?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    connect?: recommendPostsWhereUniqueInput | recommendPostsWhereUniqueInput[]
    update?: recommendPostsUpdateWithWhereUniqueWithoutPostInput | recommendPostsUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: recommendPostsUpdateManyWithWhereWithoutPostInput | recommendPostsUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: recommendPostsScalarWhereInput | recommendPostsScalarWhereInput[]
  }

  export type reportedPostsUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<reportedPostsCreateWithoutPostInput, reportedPostsUncheckedCreateWithoutPostInput> | reportedPostsCreateWithoutPostInput[] | reportedPostsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: reportedPostsCreateOrConnectWithoutPostInput | reportedPostsCreateOrConnectWithoutPostInput[]
    upsert?: reportedPostsUpsertWithWhereUniqueWithoutPostInput | reportedPostsUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: reportedPostsCreateManyPostInputEnvelope
    set?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    disconnect?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    delete?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    connect?: reportedPostsWhereUniqueInput | reportedPostsWhereUniqueInput[]
    update?: reportedPostsUpdateWithWhereUniqueWithoutPostInput | reportedPostsUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: reportedPostsUpdateManyWithWhereWithoutPostInput | reportedPostsUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: reportedPostsScalarWhereInput | reportedPostsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutCommentsInput = {
    create?: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCommentsInput
    connect?: usersWhereUniqueInput
  }

  export type postsCreateNestedOneWithoutCommentsInput = {
    create?: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: postsCreateOrConnectWithoutCommentsInput
    connect?: postsWhereUniqueInput
  }

  export type commentsCreateNestedOneWithoutRepliesInput = {
    create?: XOR<commentsCreateWithoutRepliesInput, commentsUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: commentsCreateOrConnectWithoutRepliesInput
    connect?: commentsWhereUniqueInput
  }

  export type commentsCreateNestedManyWithoutParentInput = {
    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]
    createMany?: commentsCreateManyParentInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type recommendCommentsCreateNestedManyWithoutCommentInput = {
    create?: XOR<recommendCommentsCreateWithoutCommentInput, recommendCommentsUncheckedCreateWithoutCommentInput> | recommendCommentsCreateWithoutCommentInput[] | recommendCommentsUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: recommendCommentsCreateOrConnectWithoutCommentInput | recommendCommentsCreateOrConnectWithoutCommentInput[]
    createMany?: recommendCommentsCreateManyCommentInputEnvelope
    connect?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
  }

  export type reportedCommentsCreateNestedManyWithoutCommentInput = {
    create?: XOR<reportedCommentsCreateWithoutCommentInput, reportedCommentsUncheckedCreateWithoutCommentInput> | reportedCommentsCreateWithoutCommentInput[] | reportedCommentsUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: reportedCommentsCreateOrConnectWithoutCommentInput | reportedCommentsCreateOrConnectWithoutCommentInput[]
    createMany?: reportedCommentsCreateManyCommentInputEnvelope
    connect?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
  }

  export type commentsUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]
    createMany?: commentsCreateManyParentInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type recommendCommentsUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<recommendCommentsCreateWithoutCommentInput, recommendCommentsUncheckedCreateWithoutCommentInput> | recommendCommentsCreateWithoutCommentInput[] | recommendCommentsUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: recommendCommentsCreateOrConnectWithoutCommentInput | recommendCommentsCreateOrConnectWithoutCommentInput[]
    createMany?: recommendCommentsCreateManyCommentInputEnvelope
    connect?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
  }

  export type reportedCommentsUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<reportedCommentsCreateWithoutCommentInput, reportedCommentsUncheckedCreateWithoutCommentInput> | reportedCommentsCreateWithoutCommentInput[] | reportedCommentsUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: reportedCommentsCreateOrConnectWithoutCommentInput | reportedCommentsCreateOrConnectWithoutCommentInput[]
    createMany?: reportedCommentsCreateManyCommentInputEnvelope
    connect?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type usersUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCommentsInput
    upsert?: usersUpsertWithoutCommentsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCommentsInput, usersUpdateWithoutCommentsInput>, usersUncheckedUpdateWithoutCommentsInput>
  }

  export type postsUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: postsCreateOrConnectWithoutCommentsInput
    upsert?: postsUpsertWithoutCommentsInput
    connect?: postsWhereUniqueInput
    update?: XOR<XOR<postsUpdateToOneWithWhereWithoutCommentsInput, postsUpdateWithoutCommentsInput>, postsUncheckedUpdateWithoutCommentsInput>
  }

  export type commentsUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<commentsCreateWithoutRepliesInput, commentsUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: commentsCreateOrConnectWithoutRepliesInput
    upsert?: commentsUpsertWithoutRepliesInput
    disconnect?: commentsWhereInput | boolean
    delete?: commentsWhereInput | boolean
    connect?: commentsWhereUniqueInput
    update?: XOR<XOR<commentsUpdateToOneWithWhereWithoutRepliesInput, commentsUpdateWithoutRepliesInput>, commentsUncheckedUpdateWithoutRepliesInput>
  }

  export type commentsUpdateManyWithoutParentNestedInput = {
    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutParentInput | commentsUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: commentsCreateManyParentInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutParentInput | commentsUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutParentInput | commentsUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type recommendCommentsUpdateManyWithoutCommentNestedInput = {
    create?: XOR<recommendCommentsCreateWithoutCommentInput, recommendCommentsUncheckedCreateWithoutCommentInput> | recommendCommentsCreateWithoutCommentInput[] | recommendCommentsUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: recommendCommentsCreateOrConnectWithoutCommentInput | recommendCommentsCreateOrConnectWithoutCommentInput[]
    upsert?: recommendCommentsUpsertWithWhereUniqueWithoutCommentInput | recommendCommentsUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: recommendCommentsCreateManyCommentInputEnvelope
    set?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    disconnect?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    delete?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    connect?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    update?: recommendCommentsUpdateWithWhereUniqueWithoutCommentInput | recommendCommentsUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: recommendCommentsUpdateManyWithWhereWithoutCommentInput | recommendCommentsUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: recommendCommentsScalarWhereInput | recommendCommentsScalarWhereInput[]
  }

  export type reportedCommentsUpdateManyWithoutCommentNestedInput = {
    create?: XOR<reportedCommentsCreateWithoutCommentInput, reportedCommentsUncheckedCreateWithoutCommentInput> | reportedCommentsCreateWithoutCommentInput[] | reportedCommentsUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: reportedCommentsCreateOrConnectWithoutCommentInput | reportedCommentsCreateOrConnectWithoutCommentInput[]
    upsert?: reportedCommentsUpsertWithWhereUniqueWithoutCommentInput | reportedCommentsUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: reportedCommentsCreateManyCommentInputEnvelope
    set?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    disconnect?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    delete?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    connect?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    update?: reportedCommentsUpdateWithWhereUniqueWithoutCommentInput | reportedCommentsUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: reportedCommentsUpdateManyWithWhereWithoutCommentInput | reportedCommentsUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: reportedCommentsScalarWhereInput | reportedCommentsScalarWhereInput[]
  }

  export type commentsUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput> | commentsCreateWithoutParentInput[] | commentsUncheckedCreateWithoutParentInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutParentInput | commentsCreateOrConnectWithoutParentInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutParentInput | commentsUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: commentsCreateManyParentInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutParentInput | commentsUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutParentInput | commentsUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type recommendCommentsUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<recommendCommentsCreateWithoutCommentInput, recommendCommentsUncheckedCreateWithoutCommentInput> | recommendCommentsCreateWithoutCommentInput[] | recommendCommentsUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: recommendCommentsCreateOrConnectWithoutCommentInput | recommendCommentsCreateOrConnectWithoutCommentInput[]
    upsert?: recommendCommentsUpsertWithWhereUniqueWithoutCommentInput | recommendCommentsUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: recommendCommentsCreateManyCommentInputEnvelope
    set?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    disconnect?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    delete?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    connect?: recommendCommentsWhereUniqueInput | recommendCommentsWhereUniqueInput[]
    update?: recommendCommentsUpdateWithWhereUniqueWithoutCommentInput | recommendCommentsUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: recommendCommentsUpdateManyWithWhereWithoutCommentInput | recommendCommentsUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: recommendCommentsScalarWhereInput | recommendCommentsScalarWhereInput[]
  }

  export type reportedCommentsUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<reportedCommentsCreateWithoutCommentInput, reportedCommentsUncheckedCreateWithoutCommentInput> | reportedCommentsCreateWithoutCommentInput[] | reportedCommentsUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: reportedCommentsCreateOrConnectWithoutCommentInput | reportedCommentsCreateOrConnectWithoutCommentInput[]
    upsert?: reportedCommentsUpsertWithWhereUniqueWithoutCommentInput | reportedCommentsUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: reportedCommentsCreateManyCommentInputEnvelope
    set?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    disconnect?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    delete?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    connect?: reportedCommentsWhereUniqueInput | reportedCommentsWhereUniqueInput[]
    update?: reportedCommentsUpdateWithWhereUniqueWithoutCommentInput | reportedCommentsUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: reportedCommentsUpdateManyWithWhereWithoutCommentInput | reportedCommentsUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: reportedCommentsScalarWhereInput | reportedCommentsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutRecommend_postsInput = {
    create?: XOR<usersCreateWithoutRecommend_postsInput, usersUncheckedCreateWithoutRecommend_postsInput>
    connectOrCreate?: usersCreateOrConnectWithoutRecommend_postsInput
    connect?: usersWhereUniqueInput
  }

  export type postsCreateNestedOneWithoutRecommend_postsInput = {
    create?: XOR<postsCreateWithoutRecommend_postsInput, postsUncheckedCreateWithoutRecommend_postsInput>
    connectOrCreate?: postsCreateOrConnectWithoutRecommend_postsInput
    connect?: postsWhereUniqueInput
  }

  export type usersUpdateOneWithoutRecommend_postsNestedInput = {
    create?: XOR<usersCreateWithoutRecommend_postsInput, usersUncheckedCreateWithoutRecommend_postsInput>
    connectOrCreate?: usersCreateOrConnectWithoutRecommend_postsInput
    upsert?: usersUpsertWithoutRecommend_postsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRecommend_postsInput, usersUpdateWithoutRecommend_postsInput>, usersUncheckedUpdateWithoutRecommend_postsInput>
  }

  export type postsUpdateOneRequiredWithoutRecommend_postsNestedInput = {
    create?: XOR<postsCreateWithoutRecommend_postsInput, postsUncheckedCreateWithoutRecommend_postsInput>
    connectOrCreate?: postsCreateOrConnectWithoutRecommend_postsInput
    upsert?: postsUpsertWithoutRecommend_postsInput
    connect?: postsWhereUniqueInput
    update?: XOR<XOR<postsUpdateToOneWithWhereWithoutRecommend_postsInput, postsUpdateWithoutRecommend_postsInput>, postsUncheckedUpdateWithoutRecommend_postsInput>
  }

  export type usersCreateNestedOneWithoutReported_postsInput = {
    create?: XOR<usersCreateWithoutReported_postsInput, usersUncheckedCreateWithoutReported_postsInput>
    connectOrCreate?: usersCreateOrConnectWithoutReported_postsInput
    connect?: usersWhereUniqueInput
  }

  export type postsCreateNestedOneWithoutReported_postsInput = {
    create?: XOR<postsCreateWithoutReported_postsInput, postsUncheckedCreateWithoutReported_postsInput>
    connectOrCreate?: postsCreateOrConnectWithoutReported_postsInput
    connect?: postsWhereUniqueInput
  }

  export type usersUpdateOneWithoutReported_postsNestedInput = {
    create?: XOR<usersCreateWithoutReported_postsInput, usersUncheckedCreateWithoutReported_postsInput>
    connectOrCreate?: usersCreateOrConnectWithoutReported_postsInput
    upsert?: usersUpsertWithoutReported_postsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutReported_postsInput, usersUpdateWithoutReported_postsInput>, usersUncheckedUpdateWithoutReported_postsInput>
  }

  export type postsUpdateOneRequiredWithoutReported_postsNestedInput = {
    create?: XOR<postsCreateWithoutReported_postsInput, postsUncheckedCreateWithoutReported_postsInput>
    connectOrCreate?: postsCreateOrConnectWithoutReported_postsInput
    upsert?: postsUpsertWithoutReported_postsInput
    connect?: postsWhereUniqueInput
    update?: XOR<XOR<postsUpdateToOneWithWhereWithoutReported_postsInput, postsUpdateWithoutReported_postsInput>, postsUncheckedUpdateWithoutReported_postsInput>
  }

  export type commentsCreateNestedOneWithoutRecommend_commentsInput = {
    create?: XOR<commentsCreateWithoutRecommend_commentsInput, commentsUncheckedCreateWithoutRecommend_commentsInput>
    connectOrCreate?: commentsCreateOrConnectWithoutRecommend_commentsInput
    connect?: commentsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutRecommend_commentsInput = {
    create?: XOR<usersCreateWithoutRecommend_commentsInput, usersUncheckedCreateWithoutRecommend_commentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutRecommend_commentsInput
    connect?: usersWhereUniqueInput
  }

  export type commentsUpdateOneRequiredWithoutRecommend_commentsNestedInput = {
    create?: XOR<commentsCreateWithoutRecommend_commentsInput, commentsUncheckedCreateWithoutRecommend_commentsInput>
    connectOrCreate?: commentsCreateOrConnectWithoutRecommend_commentsInput
    upsert?: commentsUpsertWithoutRecommend_commentsInput
    connect?: commentsWhereUniqueInput
    update?: XOR<XOR<commentsUpdateToOneWithWhereWithoutRecommend_commentsInput, commentsUpdateWithoutRecommend_commentsInput>, commentsUncheckedUpdateWithoutRecommend_commentsInput>
  }

  export type usersUpdateOneWithoutRecommend_commentsNestedInput = {
    create?: XOR<usersCreateWithoutRecommend_commentsInput, usersUncheckedCreateWithoutRecommend_commentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutRecommend_commentsInput
    upsert?: usersUpsertWithoutRecommend_commentsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutRecommend_commentsInput, usersUpdateWithoutRecommend_commentsInput>, usersUncheckedUpdateWithoutRecommend_commentsInput>
  }

  export type commentsCreateNestedOneWithoutReported_commentsInput = {
    create?: XOR<commentsCreateWithoutReported_commentsInput, commentsUncheckedCreateWithoutReported_commentsInput>
    connectOrCreate?: commentsCreateOrConnectWithoutReported_commentsInput
    connect?: commentsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutReported_commentsInput = {
    create?: XOR<usersCreateWithoutReported_commentsInput, usersUncheckedCreateWithoutReported_commentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutReported_commentsInput
    connect?: usersWhereUniqueInput
  }

  export type commentsUpdateOneRequiredWithoutReported_commentsNestedInput = {
    create?: XOR<commentsCreateWithoutReported_commentsInput, commentsUncheckedCreateWithoutReported_commentsInput>
    connectOrCreate?: commentsCreateOrConnectWithoutReported_commentsInput
    upsert?: commentsUpsertWithoutReported_commentsInput
    connect?: commentsWhereUniqueInput
    update?: XOR<XOR<commentsUpdateToOneWithWhereWithoutReported_commentsInput, commentsUpdateWithoutReported_commentsInput>, commentsUncheckedUpdateWithoutReported_commentsInput>
  }

  export type usersUpdateOneWithoutReported_commentsNestedInput = {
    create?: XOR<usersCreateWithoutReported_commentsInput, usersUncheckedCreateWithoutReported_commentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutReported_commentsInput
    upsert?: usersUpsertWithoutReported_commentsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutReported_commentsInput, usersUpdateWithoutReported_commentsInput>, usersUncheckedUpdateWithoutReported_commentsInput>
  }

  export type usersCreateNestedOneWithoutReported_usersInput = {
    create?: XOR<usersCreateWithoutReported_usersInput, usersUncheckedCreateWithoutReported_usersInput>
    connectOrCreate?: usersCreateOrConnectWithoutReported_usersInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutReported_usersNestedInput = {
    create?: XOR<usersCreateWithoutReported_usersInput, usersUncheckedCreateWithoutReported_usersInput>
    connectOrCreate?: usersCreateOrConnectWithoutReported_usersInput
    upsert?: usersUpsertWithoutReported_usersInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutReported_usersInput, usersUpdateWithoutReported_usersInput>, usersUncheckedUpdateWithoutReported_usersInput>
  }

  export type bigJobKindCreateNestedOneWithoutCompanyInput = {
    create?: XOR<bigJobKindCreateWithoutCompanyInput, bigJobKindUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: bigJobKindCreateOrConnectWithoutCompanyInput
    connect?: bigJobKindWhereUniqueInput
  }

  export type midJobKindCreateNestedOneWithoutCompanyInput = {
    create?: XOR<midJobKindCreateWithoutCompanyInput, midJobKindUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: midJobKindCreateOrConnectWithoutCompanyInput
    connect?: midJobKindWhereUniqueInput
  }

  export type smallJobKindCreateNestedOneWithoutCompanyInput = {
    create?: XOR<smallJobKindCreateWithoutCompanyInput, smallJobKindUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: smallJobKindCreateOrConnectWithoutCompanyInput
    connect?: smallJobKindWhereUniqueInput
  }

  export type incumbentsAdditionalCreateNestedManyWithoutCompanyInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutCompanyInput, incumbentsAdditionalUncheckedCreateWithoutCompanyInput> | incumbentsAdditionalCreateWithoutCompanyInput[] | incumbentsAdditionalUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutCompanyInput | incumbentsAdditionalCreateOrConnectWithoutCompanyInput[]
    createMany?: incumbentsAdditionalCreateManyCompanyInputEnvelope
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
  }

  export type studentsAdditionalCreateNestedManyWithoutWishCompanyInput = {
    create?: XOR<studentsAdditionalCreateWithoutWishCompanyInput, studentsAdditionalUncheckedCreateWithoutWishCompanyInput> | studentsAdditionalCreateWithoutWishCompanyInput[] | studentsAdditionalUncheckedCreateWithoutWishCompanyInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutWishCompanyInput | studentsAdditionalCreateOrConnectWithoutWishCompanyInput[]
    createMany?: studentsAdditionalCreateManyWishCompanyInputEnvelope
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
  }

  export type incumbentsAdditionalUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutCompanyInput, incumbentsAdditionalUncheckedCreateWithoutCompanyInput> | incumbentsAdditionalCreateWithoutCompanyInput[] | incumbentsAdditionalUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutCompanyInput | incumbentsAdditionalCreateOrConnectWithoutCompanyInput[]
    createMany?: incumbentsAdditionalCreateManyCompanyInputEnvelope
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
  }

  export type studentsAdditionalUncheckedCreateNestedManyWithoutWishCompanyInput = {
    create?: XOR<studentsAdditionalCreateWithoutWishCompanyInput, studentsAdditionalUncheckedCreateWithoutWishCompanyInput> | studentsAdditionalCreateWithoutWishCompanyInput[] | studentsAdditionalUncheckedCreateWithoutWishCompanyInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutWishCompanyInput | studentsAdditionalCreateOrConnectWithoutWishCompanyInput[]
    createMany?: studentsAdditionalCreateManyWishCompanyInputEnvelope
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
  }

  export type bigJobKindUpdateOneRequiredWithoutCompanyNestedInput = {
    create?: XOR<bigJobKindCreateWithoutCompanyInput, bigJobKindUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: bigJobKindCreateOrConnectWithoutCompanyInput
    upsert?: bigJobKindUpsertWithoutCompanyInput
    connect?: bigJobKindWhereUniqueInput
    update?: XOR<XOR<bigJobKindUpdateToOneWithWhereWithoutCompanyInput, bigJobKindUpdateWithoutCompanyInput>, bigJobKindUncheckedUpdateWithoutCompanyInput>
  }

  export type midJobKindUpdateOneRequiredWithoutCompanyNestedInput = {
    create?: XOR<midJobKindCreateWithoutCompanyInput, midJobKindUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: midJobKindCreateOrConnectWithoutCompanyInput
    upsert?: midJobKindUpsertWithoutCompanyInput
    connect?: midJobKindWhereUniqueInput
    update?: XOR<XOR<midJobKindUpdateToOneWithWhereWithoutCompanyInput, midJobKindUpdateWithoutCompanyInput>, midJobKindUncheckedUpdateWithoutCompanyInput>
  }

  export type smallJobKindUpdateOneRequiredWithoutCompanyNestedInput = {
    create?: XOR<smallJobKindCreateWithoutCompanyInput, smallJobKindUncheckedCreateWithoutCompanyInput>
    connectOrCreate?: smallJobKindCreateOrConnectWithoutCompanyInput
    upsert?: smallJobKindUpsertWithoutCompanyInput
    connect?: smallJobKindWhereUniqueInput
    update?: XOR<XOR<smallJobKindUpdateToOneWithWhereWithoutCompanyInput, smallJobKindUpdateWithoutCompanyInput>, smallJobKindUncheckedUpdateWithoutCompanyInput>
  }

  export type incumbentsAdditionalUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutCompanyInput, incumbentsAdditionalUncheckedCreateWithoutCompanyInput> | incumbentsAdditionalCreateWithoutCompanyInput[] | incumbentsAdditionalUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutCompanyInput | incumbentsAdditionalCreateOrConnectWithoutCompanyInput[]
    upsert?: incumbentsAdditionalUpsertWithWhereUniqueWithoutCompanyInput | incumbentsAdditionalUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: incumbentsAdditionalCreateManyCompanyInputEnvelope
    set?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    disconnect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    delete?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    update?: incumbentsAdditionalUpdateWithWhereUniqueWithoutCompanyInput | incumbentsAdditionalUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: incumbentsAdditionalUpdateManyWithWhereWithoutCompanyInput | incumbentsAdditionalUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: incumbentsAdditionalScalarWhereInput | incumbentsAdditionalScalarWhereInput[]
  }

  export type studentsAdditionalUpdateManyWithoutWishCompanyNestedInput = {
    create?: XOR<studentsAdditionalCreateWithoutWishCompanyInput, studentsAdditionalUncheckedCreateWithoutWishCompanyInput> | studentsAdditionalCreateWithoutWishCompanyInput[] | studentsAdditionalUncheckedCreateWithoutWishCompanyInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutWishCompanyInput | studentsAdditionalCreateOrConnectWithoutWishCompanyInput[]
    upsert?: studentsAdditionalUpsertWithWhereUniqueWithoutWishCompanyInput | studentsAdditionalUpsertWithWhereUniqueWithoutWishCompanyInput[]
    createMany?: studentsAdditionalCreateManyWishCompanyInputEnvelope
    set?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    disconnect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    delete?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    update?: studentsAdditionalUpdateWithWhereUniqueWithoutWishCompanyInput | studentsAdditionalUpdateWithWhereUniqueWithoutWishCompanyInput[]
    updateMany?: studentsAdditionalUpdateManyWithWhereWithoutWishCompanyInput | studentsAdditionalUpdateManyWithWhereWithoutWishCompanyInput[]
    deleteMany?: studentsAdditionalScalarWhereInput | studentsAdditionalScalarWhereInput[]
  }

  export type incumbentsAdditionalUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutCompanyInput, incumbentsAdditionalUncheckedCreateWithoutCompanyInput> | incumbentsAdditionalCreateWithoutCompanyInput[] | incumbentsAdditionalUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutCompanyInput | incumbentsAdditionalCreateOrConnectWithoutCompanyInput[]
    upsert?: incumbentsAdditionalUpsertWithWhereUniqueWithoutCompanyInput | incumbentsAdditionalUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: incumbentsAdditionalCreateManyCompanyInputEnvelope
    set?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    disconnect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    delete?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    update?: incumbentsAdditionalUpdateWithWhereUniqueWithoutCompanyInput | incumbentsAdditionalUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: incumbentsAdditionalUpdateManyWithWhereWithoutCompanyInput | incumbentsAdditionalUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: incumbentsAdditionalScalarWhereInput | incumbentsAdditionalScalarWhereInput[]
  }

  export type studentsAdditionalUncheckedUpdateManyWithoutWishCompanyNestedInput = {
    create?: XOR<studentsAdditionalCreateWithoutWishCompanyInput, studentsAdditionalUncheckedCreateWithoutWishCompanyInput> | studentsAdditionalCreateWithoutWishCompanyInput[] | studentsAdditionalUncheckedCreateWithoutWishCompanyInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutWishCompanyInput | studentsAdditionalCreateOrConnectWithoutWishCompanyInput[]
    upsert?: studentsAdditionalUpsertWithWhereUniqueWithoutWishCompanyInput | studentsAdditionalUpsertWithWhereUniqueWithoutWishCompanyInput[]
    createMany?: studentsAdditionalCreateManyWishCompanyInputEnvelope
    set?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    disconnect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    delete?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    update?: studentsAdditionalUpdateWithWhereUniqueWithoutWishCompanyInput | studentsAdditionalUpdateWithWhereUniqueWithoutWishCompanyInput[]
    updateMany?: studentsAdditionalUpdateManyWithWhereWithoutWishCompanyInput | studentsAdditionalUpdateManyWithWhereWithoutWishCompanyInput[]
    deleteMany?: studentsAdditionalScalarWhereInput | studentsAdditionalScalarWhereInput[]
  }

  export type majorCreateNestedManyWithoutSchoolInput = {
    create?: XOR<majorCreateWithoutSchoolInput, majorUncheckedCreateWithoutSchoolInput> | majorCreateWithoutSchoolInput[] | majorUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: majorCreateOrConnectWithoutSchoolInput | majorCreateOrConnectWithoutSchoolInput[]
    createMany?: majorCreateManySchoolInputEnvelope
    connect?: majorWhereUniqueInput | majorWhereUniqueInput[]
  }

  export type incumbentsAdditionalCreateNestedManyWithoutSchoolInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutSchoolInput, incumbentsAdditionalUncheckedCreateWithoutSchoolInput> | incumbentsAdditionalCreateWithoutSchoolInput[] | incumbentsAdditionalUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutSchoolInput | incumbentsAdditionalCreateOrConnectWithoutSchoolInput[]
    createMany?: incumbentsAdditionalCreateManySchoolInputEnvelope
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
  }

  export type studentsAdditionalCreateNestedManyWithoutSchoolInput = {
    create?: XOR<studentsAdditionalCreateWithoutSchoolInput, studentsAdditionalUncheckedCreateWithoutSchoolInput> | studentsAdditionalCreateWithoutSchoolInput[] | studentsAdditionalUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutSchoolInput | studentsAdditionalCreateOrConnectWithoutSchoolInput[]
    createMany?: studentsAdditionalCreateManySchoolInputEnvelope
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
  }

  export type majorUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<majorCreateWithoutSchoolInput, majorUncheckedCreateWithoutSchoolInput> | majorCreateWithoutSchoolInput[] | majorUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: majorCreateOrConnectWithoutSchoolInput | majorCreateOrConnectWithoutSchoolInput[]
    createMany?: majorCreateManySchoolInputEnvelope
    connect?: majorWhereUniqueInput | majorWhereUniqueInput[]
  }

  export type incumbentsAdditionalUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutSchoolInput, incumbentsAdditionalUncheckedCreateWithoutSchoolInput> | incumbentsAdditionalCreateWithoutSchoolInput[] | incumbentsAdditionalUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutSchoolInput | incumbentsAdditionalCreateOrConnectWithoutSchoolInput[]
    createMany?: incumbentsAdditionalCreateManySchoolInputEnvelope
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
  }

  export type studentsAdditionalUncheckedCreateNestedManyWithoutSchoolInput = {
    create?: XOR<studentsAdditionalCreateWithoutSchoolInput, studentsAdditionalUncheckedCreateWithoutSchoolInput> | studentsAdditionalCreateWithoutSchoolInput[] | studentsAdditionalUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutSchoolInput | studentsAdditionalCreateOrConnectWithoutSchoolInput[]
    createMany?: studentsAdditionalCreateManySchoolInputEnvelope
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
  }

  export type majorUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<majorCreateWithoutSchoolInput, majorUncheckedCreateWithoutSchoolInput> | majorCreateWithoutSchoolInput[] | majorUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: majorCreateOrConnectWithoutSchoolInput | majorCreateOrConnectWithoutSchoolInput[]
    upsert?: majorUpsertWithWhereUniqueWithoutSchoolInput | majorUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: majorCreateManySchoolInputEnvelope
    set?: majorWhereUniqueInput | majorWhereUniqueInput[]
    disconnect?: majorWhereUniqueInput | majorWhereUniqueInput[]
    delete?: majorWhereUniqueInput | majorWhereUniqueInput[]
    connect?: majorWhereUniqueInput | majorWhereUniqueInput[]
    update?: majorUpdateWithWhereUniqueWithoutSchoolInput | majorUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: majorUpdateManyWithWhereWithoutSchoolInput | majorUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: majorScalarWhereInput | majorScalarWhereInput[]
  }

  export type incumbentsAdditionalUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutSchoolInput, incumbentsAdditionalUncheckedCreateWithoutSchoolInput> | incumbentsAdditionalCreateWithoutSchoolInput[] | incumbentsAdditionalUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutSchoolInput | incumbentsAdditionalCreateOrConnectWithoutSchoolInput[]
    upsert?: incumbentsAdditionalUpsertWithWhereUniqueWithoutSchoolInput | incumbentsAdditionalUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: incumbentsAdditionalCreateManySchoolInputEnvelope
    set?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    disconnect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    delete?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    update?: incumbentsAdditionalUpdateWithWhereUniqueWithoutSchoolInput | incumbentsAdditionalUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: incumbentsAdditionalUpdateManyWithWhereWithoutSchoolInput | incumbentsAdditionalUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: incumbentsAdditionalScalarWhereInput | incumbentsAdditionalScalarWhereInput[]
  }

  export type studentsAdditionalUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<studentsAdditionalCreateWithoutSchoolInput, studentsAdditionalUncheckedCreateWithoutSchoolInput> | studentsAdditionalCreateWithoutSchoolInput[] | studentsAdditionalUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutSchoolInput | studentsAdditionalCreateOrConnectWithoutSchoolInput[]
    upsert?: studentsAdditionalUpsertWithWhereUniqueWithoutSchoolInput | studentsAdditionalUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: studentsAdditionalCreateManySchoolInputEnvelope
    set?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    disconnect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    delete?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    update?: studentsAdditionalUpdateWithWhereUniqueWithoutSchoolInput | studentsAdditionalUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: studentsAdditionalUpdateManyWithWhereWithoutSchoolInput | studentsAdditionalUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: studentsAdditionalScalarWhereInput | studentsAdditionalScalarWhereInput[]
  }

  export type majorUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<majorCreateWithoutSchoolInput, majorUncheckedCreateWithoutSchoolInput> | majorCreateWithoutSchoolInput[] | majorUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: majorCreateOrConnectWithoutSchoolInput | majorCreateOrConnectWithoutSchoolInput[]
    upsert?: majorUpsertWithWhereUniqueWithoutSchoolInput | majorUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: majorCreateManySchoolInputEnvelope
    set?: majorWhereUniqueInput | majorWhereUniqueInput[]
    disconnect?: majorWhereUniqueInput | majorWhereUniqueInput[]
    delete?: majorWhereUniqueInput | majorWhereUniqueInput[]
    connect?: majorWhereUniqueInput | majorWhereUniqueInput[]
    update?: majorUpdateWithWhereUniqueWithoutSchoolInput | majorUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: majorUpdateManyWithWhereWithoutSchoolInput | majorUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: majorScalarWhereInput | majorScalarWhereInput[]
  }

  export type incumbentsAdditionalUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutSchoolInput, incumbentsAdditionalUncheckedCreateWithoutSchoolInput> | incumbentsAdditionalCreateWithoutSchoolInput[] | incumbentsAdditionalUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutSchoolInput | incumbentsAdditionalCreateOrConnectWithoutSchoolInput[]
    upsert?: incumbentsAdditionalUpsertWithWhereUniqueWithoutSchoolInput | incumbentsAdditionalUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: incumbentsAdditionalCreateManySchoolInputEnvelope
    set?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    disconnect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    delete?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    update?: incumbentsAdditionalUpdateWithWhereUniqueWithoutSchoolInput | incumbentsAdditionalUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: incumbentsAdditionalUpdateManyWithWhereWithoutSchoolInput | incumbentsAdditionalUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: incumbentsAdditionalScalarWhereInput | incumbentsAdditionalScalarWhereInput[]
  }

  export type studentsAdditionalUncheckedUpdateManyWithoutSchoolNestedInput = {
    create?: XOR<studentsAdditionalCreateWithoutSchoolInput, studentsAdditionalUncheckedCreateWithoutSchoolInput> | studentsAdditionalCreateWithoutSchoolInput[] | studentsAdditionalUncheckedCreateWithoutSchoolInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutSchoolInput | studentsAdditionalCreateOrConnectWithoutSchoolInput[]
    upsert?: studentsAdditionalUpsertWithWhereUniqueWithoutSchoolInput | studentsAdditionalUpsertWithWhereUniqueWithoutSchoolInput[]
    createMany?: studentsAdditionalCreateManySchoolInputEnvelope
    set?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    disconnect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    delete?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    update?: studentsAdditionalUpdateWithWhereUniqueWithoutSchoolInput | studentsAdditionalUpdateWithWhereUniqueWithoutSchoolInput[]
    updateMany?: studentsAdditionalUpdateManyWithWhereWithoutSchoolInput | studentsAdditionalUpdateManyWithWhereWithoutSchoolInput[]
    deleteMany?: studentsAdditionalScalarWhereInput | studentsAdditionalScalarWhereInput[]
  }

  export type schoolCreateNestedOneWithoutMajorInput = {
    create?: XOR<schoolCreateWithoutMajorInput, schoolUncheckedCreateWithoutMajorInput>
    connectOrCreate?: schoolCreateOrConnectWithoutMajorInput
    connect?: schoolWhereUniqueInput
  }

  export type incumbentsAdditionalCreateNestedManyWithoutMajorInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutMajorInput, incumbentsAdditionalUncheckedCreateWithoutMajorInput> | incumbentsAdditionalCreateWithoutMajorInput[] | incumbentsAdditionalUncheckedCreateWithoutMajorInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutMajorInput | incumbentsAdditionalCreateOrConnectWithoutMajorInput[]
    createMany?: incumbentsAdditionalCreateManyMajorInputEnvelope
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
  }

  export type studentsAdditionalCreateNestedManyWithoutMajorInput = {
    create?: XOR<studentsAdditionalCreateWithoutMajorInput, studentsAdditionalUncheckedCreateWithoutMajorInput> | studentsAdditionalCreateWithoutMajorInput[] | studentsAdditionalUncheckedCreateWithoutMajorInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutMajorInput | studentsAdditionalCreateOrConnectWithoutMajorInput[]
    createMany?: studentsAdditionalCreateManyMajorInputEnvelope
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
  }

  export type incumbentsAdditionalUncheckedCreateNestedManyWithoutMajorInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutMajorInput, incumbentsAdditionalUncheckedCreateWithoutMajorInput> | incumbentsAdditionalCreateWithoutMajorInput[] | incumbentsAdditionalUncheckedCreateWithoutMajorInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutMajorInput | incumbentsAdditionalCreateOrConnectWithoutMajorInput[]
    createMany?: incumbentsAdditionalCreateManyMajorInputEnvelope
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
  }

  export type studentsAdditionalUncheckedCreateNestedManyWithoutMajorInput = {
    create?: XOR<studentsAdditionalCreateWithoutMajorInput, studentsAdditionalUncheckedCreateWithoutMajorInput> | studentsAdditionalCreateWithoutMajorInput[] | studentsAdditionalUncheckedCreateWithoutMajorInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutMajorInput | studentsAdditionalCreateOrConnectWithoutMajorInput[]
    createMany?: studentsAdditionalCreateManyMajorInputEnvelope
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
  }

  export type schoolUpdateOneRequiredWithoutMajorNestedInput = {
    create?: XOR<schoolCreateWithoutMajorInput, schoolUncheckedCreateWithoutMajorInput>
    connectOrCreate?: schoolCreateOrConnectWithoutMajorInput
    upsert?: schoolUpsertWithoutMajorInput
    connect?: schoolWhereUniqueInput
    update?: XOR<XOR<schoolUpdateToOneWithWhereWithoutMajorInput, schoolUpdateWithoutMajorInput>, schoolUncheckedUpdateWithoutMajorInput>
  }

  export type incumbentsAdditionalUpdateManyWithoutMajorNestedInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutMajorInput, incumbentsAdditionalUncheckedCreateWithoutMajorInput> | incumbentsAdditionalCreateWithoutMajorInput[] | incumbentsAdditionalUncheckedCreateWithoutMajorInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutMajorInput | incumbentsAdditionalCreateOrConnectWithoutMajorInput[]
    upsert?: incumbentsAdditionalUpsertWithWhereUniqueWithoutMajorInput | incumbentsAdditionalUpsertWithWhereUniqueWithoutMajorInput[]
    createMany?: incumbentsAdditionalCreateManyMajorInputEnvelope
    set?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    disconnect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    delete?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    update?: incumbentsAdditionalUpdateWithWhereUniqueWithoutMajorInput | incumbentsAdditionalUpdateWithWhereUniqueWithoutMajorInput[]
    updateMany?: incumbentsAdditionalUpdateManyWithWhereWithoutMajorInput | incumbentsAdditionalUpdateManyWithWhereWithoutMajorInput[]
    deleteMany?: incumbentsAdditionalScalarWhereInput | incumbentsAdditionalScalarWhereInput[]
  }

  export type studentsAdditionalUpdateManyWithoutMajorNestedInput = {
    create?: XOR<studentsAdditionalCreateWithoutMajorInput, studentsAdditionalUncheckedCreateWithoutMajorInput> | studentsAdditionalCreateWithoutMajorInput[] | studentsAdditionalUncheckedCreateWithoutMajorInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutMajorInput | studentsAdditionalCreateOrConnectWithoutMajorInput[]
    upsert?: studentsAdditionalUpsertWithWhereUniqueWithoutMajorInput | studentsAdditionalUpsertWithWhereUniqueWithoutMajorInput[]
    createMany?: studentsAdditionalCreateManyMajorInputEnvelope
    set?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    disconnect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    delete?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    update?: studentsAdditionalUpdateWithWhereUniqueWithoutMajorInput | studentsAdditionalUpdateWithWhereUniqueWithoutMajorInput[]
    updateMany?: studentsAdditionalUpdateManyWithWhereWithoutMajorInput | studentsAdditionalUpdateManyWithWhereWithoutMajorInput[]
    deleteMany?: studentsAdditionalScalarWhereInput | studentsAdditionalScalarWhereInput[]
  }

  export type incumbentsAdditionalUncheckedUpdateManyWithoutMajorNestedInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutMajorInput, incumbentsAdditionalUncheckedCreateWithoutMajorInput> | incumbentsAdditionalCreateWithoutMajorInput[] | incumbentsAdditionalUncheckedCreateWithoutMajorInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutMajorInput | incumbentsAdditionalCreateOrConnectWithoutMajorInput[]
    upsert?: incumbentsAdditionalUpsertWithWhereUniqueWithoutMajorInput | incumbentsAdditionalUpsertWithWhereUniqueWithoutMajorInput[]
    createMany?: incumbentsAdditionalCreateManyMajorInputEnvelope
    set?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    disconnect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    delete?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    update?: incumbentsAdditionalUpdateWithWhereUniqueWithoutMajorInput | incumbentsAdditionalUpdateWithWhereUniqueWithoutMajorInput[]
    updateMany?: incumbentsAdditionalUpdateManyWithWhereWithoutMajorInput | incumbentsAdditionalUpdateManyWithWhereWithoutMajorInput[]
    deleteMany?: incumbentsAdditionalScalarWhereInput | incumbentsAdditionalScalarWhereInput[]
  }

  export type studentsAdditionalUncheckedUpdateManyWithoutMajorNestedInput = {
    create?: XOR<studentsAdditionalCreateWithoutMajorInput, studentsAdditionalUncheckedCreateWithoutMajorInput> | studentsAdditionalCreateWithoutMajorInput[] | studentsAdditionalUncheckedCreateWithoutMajorInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutMajorInput | studentsAdditionalCreateOrConnectWithoutMajorInput[]
    upsert?: studentsAdditionalUpsertWithWhereUniqueWithoutMajorInput | studentsAdditionalUpsertWithWhereUniqueWithoutMajorInput[]
    createMany?: studentsAdditionalCreateManyMajorInputEnvelope
    set?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    disconnect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    delete?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    update?: studentsAdditionalUpdateWithWhereUniqueWithoutMajorInput | studentsAdditionalUpdateWithWhereUniqueWithoutMajorInput[]
    updateMany?: studentsAdditionalUpdateManyWithWhereWithoutMajorInput | studentsAdditionalUpdateManyWithWhereWithoutMajorInput[]
    deleteMany?: studentsAdditionalScalarWhereInput | studentsAdditionalScalarWhereInput[]
  }

  export type companyCreateNestedManyWithoutBigJobKindInput = {
    create?: XOR<companyCreateWithoutBigJobKindInput, companyUncheckedCreateWithoutBigJobKindInput> | companyCreateWithoutBigJobKindInput[] | companyUncheckedCreateWithoutBigJobKindInput[]
    connectOrCreate?: companyCreateOrConnectWithoutBigJobKindInput | companyCreateOrConnectWithoutBigJobKindInput[]
    createMany?: companyCreateManyBigJobKindInputEnvelope
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
  }

  export type midJobKindCreateNestedManyWithoutBigJobKindInput = {
    create?: XOR<midJobKindCreateWithoutBigJobKindInput, midJobKindUncheckedCreateWithoutBigJobKindInput> | midJobKindCreateWithoutBigJobKindInput[] | midJobKindUncheckedCreateWithoutBigJobKindInput[]
    connectOrCreate?: midJobKindCreateOrConnectWithoutBigJobKindInput | midJobKindCreateOrConnectWithoutBigJobKindInput[]
    createMany?: midJobKindCreateManyBigJobKindInputEnvelope
    connect?: midJobKindWhereUniqueInput | midJobKindWhereUniqueInput[]
  }

  export type companyUncheckedCreateNestedManyWithoutBigJobKindInput = {
    create?: XOR<companyCreateWithoutBigJobKindInput, companyUncheckedCreateWithoutBigJobKindInput> | companyCreateWithoutBigJobKindInput[] | companyUncheckedCreateWithoutBigJobKindInput[]
    connectOrCreate?: companyCreateOrConnectWithoutBigJobKindInput | companyCreateOrConnectWithoutBigJobKindInput[]
    createMany?: companyCreateManyBigJobKindInputEnvelope
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
  }

  export type midJobKindUncheckedCreateNestedManyWithoutBigJobKindInput = {
    create?: XOR<midJobKindCreateWithoutBigJobKindInput, midJobKindUncheckedCreateWithoutBigJobKindInput> | midJobKindCreateWithoutBigJobKindInput[] | midJobKindUncheckedCreateWithoutBigJobKindInput[]
    connectOrCreate?: midJobKindCreateOrConnectWithoutBigJobKindInput | midJobKindCreateOrConnectWithoutBigJobKindInput[]
    createMany?: midJobKindCreateManyBigJobKindInputEnvelope
    connect?: midJobKindWhereUniqueInput | midJobKindWhereUniqueInput[]
  }

  export type companyUpdateManyWithoutBigJobKindNestedInput = {
    create?: XOR<companyCreateWithoutBigJobKindInput, companyUncheckedCreateWithoutBigJobKindInput> | companyCreateWithoutBigJobKindInput[] | companyUncheckedCreateWithoutBigJobKindInput[]
    connectOrCreate?: companyCreateOrConnectWithoutBigJobKindInput | companyCreateOrConnectWithoutBigJobKindInput[]
    upsert?: companyUpsertWithWhereUniqueWithoutBigJobKindInput | companyUpsertWithWhereUniqueWithoutBigJobKindInput[]
    createMany?: companyCreateManyBigJobKindInputEnvelope
    set?: companyWhereUniqueInput | companyWhereUniqueInput[]
    disconnect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    delete?: companyWhereUniqueInput | companyWhereUniqueInput[]
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    update?: companyUpdateWithWhereUniqueWithoutBigJobKindInput | companyUpdateWithWhereUniqueWithoutBigJobKindInput[]
    updateMany?: companyUpdateManyWithWhereWithoutBigJobKindInput | companyUpdateManyWithWhereWithoutBigJobKindInput[]
    deleteMany?: companyScalarWhereInput | companyScalarWhereInput[]
  }

  export type midJobKindUpdateManyWithoutBigJobKindNestedInput = {
    create?: XOR<midJobKindCreateWithoutBigJobKindInput, midJobKindUncheckedCreateWithoutBigJobKindInput> | midJobKindCreateWithoutBigJobKindInput[] | midJobKindUncheckedCreateWithoutBigJobKindInput[]
    connectOrCreate?: midJobKindCreateOrConnectWithoutBigJobKindInput | midJobKindCreateOrConnectWithoutBigJobKindInput[]
    upsert?: midJobKindUpsertWithWhereUniqueWithoutBigJobKindInput | midJobKindUpsertWithWhereUniqueWithoutBigJobKindInput[]
    createMany?: midJobKindCreateManyBigJobKindInputEnvelope
    set?: midJobKindWhereUniqueInput | midJobKindWhereUniqueInput[]
    disconnect?: midJobKindWhereUniqueInput | midJobKindWhereUniqueInput[]
    delete?: midJobKindWhereUniqueInput | midJobKindWhereUniqueInput[]
    connect?: midJobKindWhereUniqueInput | midJobKindWhereUniqueInput[]
    update?: midJobKindUpdateWithWhereUniqueWithoutBigJobKindInput | midJobKindUpdateWithWhereUniqueWithoutBigJobKindInput[]
    updateMany?: midJobKindUpdateManyWithWhereWithoutBigJobKindInput | midJobKindUpdateManyWithWhereWithoutBigJobKindInput[]
    deleteMany?: midJobKindScalarWhereInput | midJobKindScalarWhereInput[]
  }

  export type companyUncheckedUpdateManyWithoutBigJobKindNestedInput = {
    create?: XOR<companyCreateWithoutBigJobKindInput, companyUncheckedCreateWithoutBigJobKindInput> | companyCreateWithoutBigJobKindInput[] | companyUncheckedCreateWithoutBigJobKindInput[]
    connectOrCreate?: companyCreateOrConnectWithoutBigJobKindInput | companyCreateOrConnectWithoutBigJobKindInput[]
    upsert?: companyUpsertWithWhereUniqueWithoutBigJobKindInput | companyUpsertWithWhereUniqueWithoutBigJobKindInput[]
    createMany?: companyCreateManyBigJobKindInputEnvelope
    set?: companyWhereUniqueInput | companyWhereUniqueInput[]
    disconnect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    delete?: companyWhereUniqueInput | companyWhereUniqueInput[]
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    update?: companyUpdateWithWhereUniqueWithoutBigJobKindInput | companyUpdateWithWhereUniqueWithoutBigJobKindInput[]
    updateMany?: companyUpdateManyWithWhereWithoutBigJobKindInput | companyUpdateManyWithWhereWithoutBigJobKindInput[]
    deleteMany?: companyScalarWhereInput | companyScalarWhereInput[]
  }

  export type midJobKindUncheckedUpdateManyWithoutBigJobKindNestedInput = {
    create?: XOR<midJobKindCreateWithoutBigJobKindInput, midJobKindUncheckedCreateWithoutBigJobKindInput> | midJobKindCreateWithoutBigJobKindInput[] | midJobKindUncheckedCreateWithoutBigJobKindInput[]
    connectOrCreate?: midJobKindCreateOrConnectWithoutBigJobKindInput | midJobKindCreateOrConnectWithoutBigJobKindInput[]
    upsert?: midJobKindUpsertWithWhereUniqueWithoutBigJobKindInput | midJobKindUpsertWithWhereUniqueWithoutBigJobKindInput[]
    createMany?: midJobKindCreateManyBigJobKindInputEnvelope
    set?: midJobKindWhereUniqueInput | midJobKindWhereUniqueInput[]
    disconnect?: midJobKindWhereUniqueInput | midJobKindWhereUniqueInput[]
    delete?: midJobKindWhereUniqueInput | midJobKindWhereUniqueInput[]
    connect?: midJobKindWhereUniqueInput | midJobKindWhereUniqueInput[]
    update?: midJobKindUpdateWithWhereUniqueWithoutBigJobKindInput | midJobKindUpdateWithWhereUniqueWithoutBigJobKindInput[]
    updateMany?: midJobKindUpdateManyWithWhereWithoutBigJobKindInput | midJobKindUpdateManyWithWhereWithoutBigJobKindInput[]
    deleteMany?: midJobKindScalarWhereInput | midJobKindScalarWhereInput[]
  }

  export type companyCreateNestedManyWithoutMidJobKindInput = {
    create?: XOR<companyCreateWithoutMidJobKindInput, companyUncheckedCreateWithoutMidJobKindInput> | companyCreateWithoutMidJobKindInput[] | companyUncheckedCreateWithoutMidJobKindInput[]
    connectOrCreate?: companyCreateOrConnectWithoutMidJobKindInput | companyCreateOrConnectWithoutMidJobKindInput[]
    createMany?: companyCreateManyMidJobKindInputEnvelope
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
  }

  export type bigJobKindCreateNestedOneWithoutMidJobKindInput = {
    create?: XOR<bigJobKindCreateWithoutMidJobKindInput, bigJobKindUncheckedCreateWithoutMidJobKindInput>
    connectOrCreate?: bigJobKindCreateOrConnectWithoutMidJobKindInput
    connect?: bigJobKindWhereUniqueInput
  }

  export type smallJobKindCreateNestedManyWithoutMidJobKindInput = {
    create?: XOR<smallJobKindCreateWithoutMidJobKindInput, smallJobKindUncheckedCreateWithoutMidJobKindInput> | smallJobKindCreateWithoutMidJobKindInput[] | smallJobKindUncheckedCreateWithoutMidJobKindInput[]
    connectOrCreate?: smallJobKindCreateOrConnectWithoutMidJobKindInput | smallJobKindCreateOrConnectWithoutMidJobKindInput[]
    createMany?: smallJobKindCreateManyMidJobKindInputEnvelope
    connect?: smallJobKindWhereUniqueInput | smallJobKindWhereUniqueInput[]
  }

  export type companyUncheckedCreateNestedManyWithoutMidJobKindInput = {
    create?: XOR<companyCreateWithoutMidJobKindInput, companyUncheckedCreateWithoutMidJobKindInput> | companyCreateWithoutMidJobKindInput[] | companyUncheckedCreateWithoutMidJobKindInput[]
    connectOrCreate?: companyCreateOrConnectWithoutMidJobKindInput | companyCreateOrConnectWithoutMidJobKindInput[]
    createMany?: companyCreateManyMidJobKindInputEnvelope
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
  }

  export type smallJobKindUncheckedCreateNestedManyWithoutMidJobKindInput = {
    create?: XOR<smallJobKindCreateWithoutMidJobKindInput, smallJobKindUncheckedCreateWithoutMidJobKindInput> | smallJobKindCreateWithoutMidJobKindInput[] | smallJobKindUncheckedCreateWithoutMidJobKindInput[]
    connectOrCreate?: smallJobKindCreateOrConnectWithoutMidJobKindInput | smallJobKindCreateOrConnectWithoutMidJobKindInput[]
    createMany?: smallJobKindCreateManyMidJobKindInputEnvelope
    connect?: smallJobKindWhereUniqueInput | smallJobKindWhereUniqueInput[]
  }

  export type companyUpdateManyWithoutMidJobKindNestedInput = {
    create?: XOR<companyCreateWithoutMidJobKindInput, companyUncheckedCreateWithoutMidJobKindInput> | companyCreateWithoutMidJobKindInput[] | companyUncheckedCreateWithoutMidJobKindInput[]
    connectOrCreate?: companyCreateOrConnectWithoutMidJobKindInput | companyCreateOrConnectWithoutMidJobKindInput[]
    upsert?: companyUpsertWithWhereUniqueWithoutMidJobKindInput | companyUpsertWithWhereUniqueWithoutMidJobKindInput[]
    createMany?: companyCreateManyMidJobKindInputEnvelope
    set?: companyWhereUniqueInput | companyWhereUniqueInput[]
    disconnect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    delete?: companyWhereUniqueInput | companyWhereUniqueInput[]
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    update?: companyUpdateWithWhereUniqueWithoutMidJobKindInput | companyUpdateWithWhereUniqueWithoutMidJobKindInput[]
    updateMany?: companyUpdateManyWithWhereWithoutMidJobKindInput | companyUpdateManyWithWhereWithoutMidJobKindInput[]
    deleteMany?: companyScalarWhereInput | companyScalarWhereInput[]
  }

  export type bigJobKindUpdateOneRequiredWithoutMidJobKindNestedInput = {
    create?: XOR<bigJobKindCreateWithoutMidJobKindInput, bigJobKindUncheckedCreateWithoutMidJobKindInput>
    connectOrCreate?: bigJobKindCreateOrConnectWithoutMidJobKindInput
    upsert?: bigJobKindUpsertWithoutMidJobKindInput
    connect?: bigJobKindWhereUniqueInput
    update?: XOR<XOR<bigJobKindUpdateToOneWithWhereWithoutMidJobKindInput, bigJobKindUpdateWithoutMidJobKindInput>, bigJobKindUncheckedUpdateWithoutMidJobKindInput>
  }

  export type smallJobKindUpdateManyWithoutMidJobKindNestedInput = {
    create?: XOR<smallJobKindCreateWithoutMidJobKindInput, smallJobKindUncheckedCreateWithoutMidJobKindInput> | smallJobKindCreateWithoutMidJobKindInput[] | smallJobKindUncheckedCreateWithoutMidJobKindInput[]
    connectOrCreate?: smallJobKindCreateOrConnectWithoutMidJobKindInput | smallJobKindCreateOrConnectWithoutMidJobKindInput[]
    upsert?: smallJobKindUpsertWithWhereUniqueWithoutMidJobKindInput | smallJobKindUpsertWithWhereUniqueWithoutMidJobKindInput[]
    createMany?: smallJobKindCreateManyMidJobKindInputEnvelope
    set?: smallJobKindWhereUniqueInput | smallJobKindWhereUniqueInput[]
    disconnect?: smallJobKindWhereUniqueInput | smallJobKindWhereUniqueInput[]
    delete?: smallJobKindWhereUniqueInput | smallJobKindWhereUniqueInput[]
    connect?: smallJobKindWhereUniqueInput | smallJobKindWhereUniqueInput[]
    update?: smallJobKindUpdateWithWhereUniqueWithoutMidJobKindInput | smallJobKindUpdateWithWhereUniqueWithoutMidJobKindInput[]
    updateMany?: smallJobKindUpdateManyWithWhereWithoutMidJobKindInput | smallJobKindUpdateManyWithWhereWithoutMidJobKindInput[]
    deleteMany?: smallJobKindScalarWhereInput | smallJobKindScalarWhereInput[]
  }

  export type companyUncheckedUpdateManyWithoutMidJobKindNestedInput = {
    create?: XOR<companyCreateWithoutMidJobKindInput, companyUncheckedCreateWithoutMidJobKindInput> | companyCreateWithoutMidJobKindInput[] | companyUncheckedCreateWithoutMidJobKindInput[]
    connectOrCreate?: companyCreateOrConnectWithoutMidJobKindInput | companyCreateOrConnectWithoutMidJobKindInput[]
    upsert?: companyUpsertWithWhereUniqueWithoutMidJobKindInput | companyUpsertWithWhereUniqueWithoutMidJobKindInput[]
    createMany?: companyCreateManyMidJobKindInputEnvelope
    set?: companyWhereUniqueInput | companyWhereUniqueInput[]
    disconnect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    delete?: companyWhereUniqueInput | companyWhereUniqueInput[]
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    update?: companyUpdateWithWhereUniqueWithoutMidJobKindInput | companyUpdateWithWhereUniqueWithoutMidJobKindInput[]
    updateMany?: companyUpdateManyWithWhereWithoutMidJobKindInput | companyUpdateManyWithWhereWithoutMidJobKindInput[]
    deleteMany?: companyScalarWhereInput | companyScalarWhereInput[]
  }

  export type smallJobKindUncheckedUpdateManyWithoutMidJobKindNestedInput = {
    create?: XOR<smallJobKindCreateWithoutMidJobKindInput, smallJobKindUncheckedCreateWithoutMidJobKindInput> | smallJobKindCreateWithoutMidJobKindInput[] | smallJobKindUncheckedCreateWithoutMidJobKindInput[]
    connectOrCreate?: smallJobKindCreateOrConnectWithoutMidJobKindInput | smallJobKindCreateOrConnectWithoutMidJobKindInput[]
    upsert?: smallJobKindUpsertWithWhereUniqueWithoutMidJobKindInput | smallJobKindUpsertWithWhereUniqueWithoutMidJobKindInput[]
    createMany?: smallJobKindCreateManyMidJobKindInputEnvelope
    set?: smallJobKindWhereUniqueInput | smallJobKindWhereUniqueInput[]
    disconnect?: smallJobKindWhereUniqueInput | smallJobKindWhereUniqueInput[]
    delete?: smallJobKindWhereUniqueInput | smallJobKindWhereUniqueInput[]
    connect?: smallJobKindWhereUniqueInput | smallJobKindWhereUniqueInput[]
    update?: smallJobKindUpdateWithWhereUniqueWithoutMidJobKindInput | smallJobKindUpdateWithWhereUniqueWithoutMidJobKindInput[]
    updateMany?: smallJobKindUpdateManyWithWhereWithoutMidJobKindInput | smallJobKindUpdateManyWithWhereWithoutMidJobKindInput[]
    deleteMany?: smallJobKindScalarWhereInput | smallJobKindScalarWhereInput[]
  }

  export type companyCreateNestedManyWithoutSmallJobKindInput = {
    create?: XOR<companyCreateWithoutSmallJobKindInput, companyUncheckedCreateWithoutSmallJobKindInput> | companyCreateWithoutSmallJobKindInput[] | companyUncheckedCreateWithoutSmallJobKindInput[]
    connectOrCreate?: companyCreateOrConnectWithoutSmallJobKindInput | companyCreateOrConnectWithoutSmallJobKindInput[]
    createMany?: companyCreateManySmallJobKindInputEnvelope
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
  }

  export type midJobKindCreateNestedOneWithoutSmallJobKindInput = {
    create?: XOR<midJobKindCreateWithoutSmallJobKindInput, midJobKindUncheckedCreateWithoutSmallJobKindInput>
    connectOrCreate?: midJobKindCreateOrConnectWithoutSmallJobKindInput
    connect?: midJobKindWhereUniqueInput
  }

  export type companyUncheckedCreateNestedManyWithoutSmallJobKindInput = {
    create?: XOR<companyCreateWithoutSmallJobKindInput, companyUncheckedCreateWithoutSmallJobKindInput> | companyCreateWithoutSmallJobKindInput[] | companyUncheckedCreateWithoutSmallJobKindInput[]
    connectOrCreate?: companyCreateOrConnectWithoutSmallJobKindInput | companyCreateOrConnectWithoutSmallJobKindInput[]
    createMany?: companyCreateManySmallJobKindInputEnvelope
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
  }

  export type companyUpdateManyWithoutSmallJobKindNestedInput = {
    create?: XOR<companyCreateWithoutSmallJobKindInput, companyUncheckedCreateWithoutSmallJobKindInput> | companyCreateWithoutSmallJobKindInput[] | companyUncheckedCreateWithoutSmallJobKindInput[]
    connectOrCreate?: companyCreateOrConnectWithoutSmallJobKindInput | companyCreateOrConnectWithoutSmallJobKindInput[]
    upsert?: companyUpsertWithWhereUniqueWithoutSmallJobKindInput | companyUpsertWithWhereUniqueWithoutSmallJobKindInput[]
    createMany?: companyCreateManySmallJobKindInputEnvelope
    set?: companyWhereUniqueInput | companyWhereUniqueInput[]
    disconnect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    delete?: companyWhereUniqueInput | companyWhereUniqueInput[]
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    update?: companyUpdateWithWhereUniqueWithoutSmallJobKindInput | companyUpdateWithWhereUniqueWithoutSmallJobKindInput[]
    updateMany?: companyUpdateManyWithWhereWithoutSmallJobKindInput | companyUpdateManyWithWhereWithoutSmallJobKindInput[]
    deleteMany?: companyScalarWhereInput | companyScalarWhereInput[]
  }

  export type midJobKindUpdateOneRequiredWithoutSmallJobKindNestedInput = {
    create?: XOR<midJobKindCreateWithoutSmallJobKindInput, midJobKindUncheckedCreateWithoutSmallJobKindInput>
    connectOrCreate?: midJobKindCreateOrConnectWithoutSmallJobKindInput
    upsert?: midJobKindUpsertWithoutSmallJobKindInput
    connect?: midJobKindWhereUniqueInput
    update?: XOR<XOR<midJobKindUpdateToOneWithWhereWithoutSmallJobKindInput, midJobKindUpdateWithoutSmallJobKindInput>, midJobKindUncheckedUpdateWithoutSmallJobKindInput>
  }

  export type companyUncheckedUpdateManyWithoutSmallJobKindNestedInput = {
    create?: XOR<companyCreateWithoutSmallJobKindInput, companyUncheckedCreateWithoutSmallJobKindInput> | companyCreateWithoutSmallJobKindInput[] | companyUncheckedCreateWithoutSmallJobKindInput[]
    connectOrCreate?: companyCreateOrConnectWithoutSmallJobKindInput | companyCreateOrConnectWithoutSmallJobKindInput[]
    upsert?: companyUpsertWithWhereUniqueWithoutSmallJobKindInput | companyUpsertWithWhereUniqueWithoutSmallJobKindInput[]
    createMany?: companyCreateManySmallJobKindInputEnvelope
    set?: companyWhereUniqueInput | companyWhereUniqueInput[]
    disconnect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    delete?: companyWhereUniqueInput | companyWhereUniqueInput[]
    connect?: companyWhereUniqueInput | companyWhereUniqueInput[]
    update?: companyUpdateWithWhereUniqueWithoutSmallJobKindInput | companyUpdateWithWhereUniqueWithoutSmallJobKindInput[]
    updateMany?: companyUpdateManyWithWhereWithoutSmallJobKindInput | companyUpdateManyWithWhereWithoutSmallJobKindInput[]
    deleteMany?: companyScalarWhereInput | companyScalarWhereInput[]
  }

  export type incumbentsAdditionalCreateNestedManyWithoutJobInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutJobInput, incumbentsAdditionalUncheckedCreateWithoutJobInput> | incumbentsAdditionalCreateWithoutJobInput[] | incumbentsAdditionalUncheckedCreateWithoutJobInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutJobInput | incumbentsAdditionalCreateOrConnectWithoutJobInput[]
    createMany?: incumbentsAdditionalCreateManyJobInputEnvelope
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
  }

  export type studentsAdditionalCreateNestedManyWithoutWishJobInput = {
    create?: XOR<studentsAdditionalCreateWithoutWishJobInput, studentsAdditionalUncheckedCreateWithoutWishJobInput> | studentsAdditionalCreateWithoutWishJobInput[] | studentsAdditionalUncheckedCreateWithoutWishJobInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutWishJobInput | studentsAdditionalCreateOrConnectWithoutWishJobInput[]
    createMany?: studentsAdditionalCreateManyWishJobInputEnvelope
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
  }

  export type incumbentsAdditionalUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutJobInput, incumbentsAdditionalUncheckedCreateWithoutJobInput> | incumbentsAdditionalCreateWithoutJobInput[] | incumbentsAdditionalUncheckedCreateWithoutJobInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutJobInput | incumbentsAdditionalCreateOrConnectWithoutJobInput[]
    createMany?: incumbentsAdditionalCreateManyJobInputEnvelope
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
  }

  export type studentsAdditionalUncheckedCreateNestedManyWithoutWishJobInput = {
    create?: XOR<studentsAdditionalCreateWithoutWishJobInput, studentsAdditionalUncheckedCreateWithoutWishJobInput> | studentsAdditionalCreateWithoutWishJobInput[] | studentsAdditionalUncheckedCreateWithoutWishJobInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutWishJobInput | studentsAdditionalCreateOrConnectWithoutWishJobInput[]
    createMany?: studentsAdditionalCreateManyWishJobInputEnvelope
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
  }

  export type incumbentsAdditionalUpdateManyWithoutJobNestedInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutJobInput, incumbentsAdditionalUncheckedCreateWithoutJobInput> | incumbentsAdditionalCreateWithoutJobInput[] | incumbentsAdditionalUncheckedCreateWithoutJobInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutJobInput | incumbentsAdditionalCreateOrConnectWithoutJobInput[]
    upsert?: incumbentsAdditionalUpsertWithWhereUniqueWithoutJobInput | incumbentsAdditionalUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: incumbentsAdditionalCreateManyJobInputEnvelope
    set?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    disconnect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    delete?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    update?: incumbentsAdditionalUpdateWithWhereUniqueWithoutJobInput | incumbentsAdditionalUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: incumbentsAdditionalUpdateManyWithWhereWithoutJobInput | incumbentsAdditionalUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: incumbentsAdditionalScalarWhereInput | incumbentsAdditionalScalarWhereInput[]
  }

  export type studentsAdditionalUpdateManyWithoutWishJobNestedInput = {
    create?: XOR<studentsAdditionalCreateWithoutWishJobInput, studentsAdditionalUncheckedCreateWithoutWishJobInput> | studentsAdditionalCreateWithoutWishJobInput[] | studentsAdditionalUncheckedCreateWithoutWishJobInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutWishJobInput | studentsAdditionalCreateOrConnectWithoutWishJobInput[]
    upsert?: studentsAdditionalUpsertWithWhereUniqueWithoutWishJobInput | studentsAdditionalUpsertWithWhereUniqueWithoutWishJobInput[]
    createMany?: studentsAdditionalCreateManyWishJobInputEnvelope
    set?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    disconnect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    delete?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    update?: studentsAdditionalUpdateWithWhereUniqueWithoutWishJobInput | studentsAdditionalUpdateWithWhereUniqueWithoutWishJobInput[]
    updateMany?: studentsAdditionalUpdateManyWithWhereWithoutWishJobInput | studentsAdditionalUpdateManyWithWhereWithoutWishJobInput[]
    deleteMany?: studentsAdditionalScalarWhereInput | studentsAdditionalScalarWhereInput[]
  }

  export type incumbentsAdditionalUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<incumbentsAdditionalCreateWithoutJobInput, incumbentsAdditionalUncheckedCreateWithoutJobInput> | incumbentsAdditionalCreateWithoutJobInput[] | incumbentsAdditionalUncheckedCreateWithoutJobInput[]
    connectOrCreate?: incumbentsAdditionalCreateOrConnectWithoutJobInput | incumbentsAdditionalCreateOrConnectWithoutJobInput[]
    upsert?: incumbentsAdditionalUpsertWithWhereUniqueWithoutJobInput | incumbentsAdditionalUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: incumbentsAdditionalCreateManyJobInputEnvelope
    set?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    disconnect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    delete?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    connect?: incumbentsAdditionalWhereUniqueInput | incumbentsAdditionalWhereUniqueInput[]
    update?: incumbentsAdditionalUpdateWithWhereUniqueWithoutJobInput | incumbentsAdditionalUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: incumbentsAdditionalUpdateManyWithWhereWithoutJobInput | incumbentsAdditionalUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: incumbentsAdditionalScalarWhereInput | incumbentsAdditionalScalarWhereInput[]
  }

  export type studentsAdditionalUncheckedUpdateManyWithoutWishJobNestedInput = {
    create?: XOR<studentsAdditionalCreateWithoutWishJobInput, studentsAdditionalUncheckedCreateWithoutWishJobInput> | studentsAdditionalCreateWithoutWishJobInput[] | studentsAdditionalUncheckedCreateWithoutWishJobInput[]
    connectOrCreate?: studentsAdditionalCreateOrConnectWithoutWishJobInput | studentsAdditionalCreateOrConnectWithoutWishJobInput[]
    upsert?: studentsAdditionalUpsertWithWhereUniqueWithoutWishJobInput | studentsAdditionalUpsertWithWhereUniqueWithoutWishJobInput[]
    createMany?: studentsAdditionalCreateManyWishJobInputEnvelope
    set?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    disconnect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    delete?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    connect?: studentsAdditionalWhereUniqueInput | studentsAdditionalWhereUniqueInput[]
    update?: studentsAdditionalUpdateWithWhereUniqueWithoutWishJobInput | studentsAdditionalUpdateWithWhereUniqueWithoutWishJobInput[]
    updateMany?: studentsAdditionalUpdateManyWithWhereWithoutWishJobInput | studentsAdditionalUpdateManyWithWhereWithoutWishJobInput[]
    deleteMany?: studentsAdditionalScalarWhereInput | studentsAdditionalScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[]
    notIn?: $Enums.Gender[]
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumuserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.userType | EnumuserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.userType[]
    notIn?: $Enums.userType[]
    not?: NestedEnumuserTypeFilter<$PrismaModel> | $Enums.userType
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[]
    notIn?: $Enums.Gender[]
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumuserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.userType | EnumuserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.userType[]
    notIn?: $Enums.userType[]
    not?: NestedEnumuserTypeWithAggregatesFilter<$PrismaModel> | $Enums.userType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumuserTypeFilter<$PrismaModel>
    _max?: NestedEnumuserTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type incumbentsAdditionalCreateWithoutUsersInput = {
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
    company?: companyCreateNestedOneWithoutIncumebentInput
    school?: schoolCreateNestedOneWithoutIncumebentInput
    major?: majorCreateNestedOneWithoutIncumebentInput
    job?: jobCreateNestedOneWithoutIncumebentInput
  }

  export type incumbentsAdditionalUncheckedCreateWithoutUsersInput = {
    id?: number
    companyId?: number | null
    schoolId?: number | null
    majorId?: number | null
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    jobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type incumbentsAdditionalCreateOrConnectWithoutUsersInput = {
    where: incumbentsAdditionalWhereUniqueInput
    create: XOR<incumbentsAdditionalCreateWithoutUsersInput, incumbentsAdditionalUncheckedCreateWithoutUsersInput>
  }

  export type studentsAdditionalCreateWithoutUsersInput = {
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
    wishCompany?: companyCreateNestedOneWithoutStudentInput
    school?: schoolCreateNestedOneWithoutStudentInput
    major?: majorCreateNestedOneWithoutStudentInput
    wishJob?: jobCreateNestedOneWithoutStudentInput
  }

  export type studentsAdditionalUncheckedCreateWithoutUsersInput = {
    id?: number
    wishCompanyId?: number | null
    schoolId?: number | null
    majorId?: number | null
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    wishJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type studentsAdditionalCreateOrConnectWithoutUsersInput = {
    where: studentsAdditionalWhereUniqueInput
    create: XOR<studentsAdditionalCreateWithoutUsersInput, studentsAdditionalUncheckedCreateWithoutUsersInput>
  }

  export type postsCreateWithoutUsersInput = {
    title: string
    content: string
    view?: number
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    categories?: categoryCreateNestedOneWithoutPostsInput
    comments?: commentsCreateNestedManyWithoutPostInput
    recommend_posts?: recommendPostsCreateNestedManyWithoutPostInput
    reported_posts?: reportedPostsCreateNestedManyWithoutPostInput
  }

  export type postsUncheckedCreateWithoutUsersInput = {
    id?: number
    categoryId?: number | null
    title: string
    content: string
    view?: number
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    comments?: commentsUncheckedCreateNestedManyWithoutPostInput
    recommend_posts?: recommendPostsUncheckedCreateNestedManyWithoutPostInput
    reported_posts?: reportedPostsUncheckedCreateNestedManyWithoutPostInput
  }

  export type postsCreateOrConnectWithoutUsersInput = {
    where: postsWhereUniqueInput
    create: XOR<postsCreateWithoutUsersInput, postsUncheckedCreateWithoutUsersInput>
  }

  export type postsCreateManyUsersInputEnvelope = {
    data: postsCreateManyUsersInput | postsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type commentsCreateWithoutUsersInput = {
    content: string
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
    post: postsCreateNestedOneWithoutCommentsInput
    parent?: commentsCreateNestedOneWithoutRepliesInput
    replies?: commentsCreateNestedManyWithoutParentInput
    recommend_comments?: recommendCommentsCreateNestedManyWithoutCommentInput
    reported_comments?: reportedCommentsCreateNestedManyWithoutCommentInput
  }

  export type commentsUncheckedCreateWithoutUsersInput = {
    id?: number
    postId: number
    content: string
    parentCommentId?: number | null
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
    replies?: commentsUncheckedCreateNestedManyWithoutParentInput
    recommend_comments?: recommendCommentsUncheckedCreateNestedManyWithoutCommentInput
    reported_comments?: reportedCommentsUncheckedCreateNestedManyWithoutCommentInput
  }

  export type commentsCreateOrConnectWithoutUsersInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput>
  }

  export type commentsCreateManyUsersInputEnvelope = {
    data: commentsCreateManyUsersInput | commentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type recommendPostsCreateWithoutUsersInput = {
    createdDate?: Date | string
    post: postsCreateNestedOneWithoutRecommend_postsInput
  }

  export type recommendPostsUncheckedCreateWithoutUsersInput = {
    id?: number
    postId: number
    createdDate?: Date | string
  }

  export type recommendPostsCreateOrConnectWithoutUsersInput = {
    where: recommendPostsWhereUniqueInput
    create: XOR<recommendPostsCreateWithoutUsersInput, recommendPostsUncheckedCreateWithoutUsersInput>
  }

  export type recommendPostsCreateManyUsersInputEnvelope = {
    data: recommendPostsCreateManyUsersInput | recommendPostsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type recommendCommentsCreateWithoutUsersInput = {
    createdDate?: Date | string
    comment: commentsCreateNestedOneWithoutRecommend_commentsInput
  }

  export type recommendCommentsUncheckedCreateWithoutUsersInput = {
    id?: number
    commentId: number
    createdDate?: Date | string
  }

  export type recommendCommentsCreateOrConnectWithoutUsersInput = {
    where: recommendCommentsWhereUniqueInput
    create: XOR<recommendCommentsCreateWithoutUsersInput, recommendCommentsUncheckedCreateWithoutUsersInput>
  }

  export type recommendCommentsCreateManyUsersInputEnvelope = {
    data: recommendCommentsCreateManyUsersInput | recommendCommentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type reportedPostsCreateWithoutUsersInput = {
    reason: string
    createdDate?: Date | string
    post: postsCreateNestedOneWithoutReported_postsInput
  }

  export type reportedPostsUncheckedCreateWithoutUsersInput = {
    id?: number
    postId: number
    reason: string
    createdDate?: Date | string
  }

  export type reportedPostsCreateOrConnectWithoutUsersInput = {
    where: reportedPostsWhereUniqueInput
    create: XOR<reportedPostsCreateWithoutUsersInput, reportedPostsUncheckedCreateWithoutUsersInput>
  }

  export type reportedPostsCreateManyUsersInputEnvelope = {
    data: reportedPostsCreateManyUsersInput | reportedPostsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type reportedCommentsCreateWithoutUsersInput = {
    reason: string
    createdDate?: Date | string
    comment: commentsCreateNestedOneWithoutReported_commentsInput
  }

  export type reportedCommentsUncheckedCreateWithoutUsersInput = {
    id?: number
    commentId: number
    reason: string
    createdDate?: Date | string
  }

  export type reportedCommentsCreateOrConnectWithoutUsersInput = {
    where: reportedCommentsWhereUniqueInput
    create: XOR<reportedCommentsCreateWithoutUsersInput, reportedCommentsUncheckedCreateWithoutUsersInput>
  }

  export type reportedCommentsCreateManyUsersInputEnvelope = {
    data: reportedCommentsCreateManyUsersInput | reportedCommentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type reportedUsersCreateWithoutUsersInput = {
    reportingUserId: number
    reason: string
    createdDate?: Date | string
  }

  export type reportedUsersUncheckedCreateWithoutUsersInput = {
    id?: number
    reportingUserId: number
    reason: string
    createdDate?: Date | string
  }

  export type reportedUsersCreateOrConnectWithoutUsersInput = {
    where: reportedUsersWhereUniqueInput
    create: XOR<reportedUsersCreateWithoutUsersInput, reportedUsersUncheckedCreateWithoutUsersInput>
  }

  export type reportedUsersCreateManyUsersInputEnvelope = {
    data: reportedUsersCreateManyUsersInput | reportedUsersCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type incumbentsAdditionalUpsertWithoutUsersInput = {
    update: XOR<incumbentsAdditionalUpdateWithoutUsersInput, incumbentsAdditionalUncheckedUpdateWithoutUsersInput>
    create: XOR<incumbentsAdditionalCreateWithoutUsersInput, incumbentsAdditionalUncheckedCreateWithoutUsersInput>
    where?: incumbentsAdditionalWhereInput
  }

  export type incumbentsAdditionalUpdateToOneWithWhereWithoutUsersInput = {
    where?: incumbentsAdditionalWhereInput
    data: XOR<incumbentsAdditionalUpdateWithoutUsersInput, incumbentsAdditionalUncheckedUpdateWithoutUsersInput>
  }

  export type incumbentsAdditionalUpdateWithoutUsersInput = {
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: companyUpdateOneWithoutIncumebentNestedInput
    school?: schoolUpdateOneWithoutIncumebentNestedInput
    major?: majorUpdateOneWithoutIncumebentNestedInput
    job?: jobUpdateOneWithoutIncumebentNestedInput
  }

  export type incumbentsAdditionalUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsAdditionalUpsertWithoutUsersInput = {
    update: XOR<studentsAdditionalUpdateWithoutUsersInput, studentsAdditionalUncheckedUpdateWithoutUsersInput>
    create: XOR<studentsAdditionalCreateWithoutUsersInput, studentsAdditionalUncheckedCreateWithoutUsersInput>
    where?: studentsAdditionalWhereInput
  }

  export type studentsAdditionalUpdateToOneWithWhereWithoutUsersInput = {
    where?: studentsAdditionalWhereInput
    data: XOR<studentsAdditionalUpdateWithoutUsersInput, studentsAdditionalUncheckedUpdateWithoutUsersInput>
  }

  export type studentsAdditionalUpdateWithoutUsersInput = {
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    wishCompany?: companyUpdateOneWithoutStudentNestedInput
    school?: schoolUpdateOneWithoutStudentNestedInput
    major?: majorUpdateOneWithoutStudentNestedInput
    wishJob?: jobUpdateOneWithoutStudentNestedInput
  }

  export type studentsAdditionalUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    wishCompanyId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type postsUpsertWithWhereUniqueWithoutUsersInput = {
    where: postsWhereUniqueInput
    update: XOR<postsUpdateWithoutUsersInput, postsUncheckedUpdateWithoutUsersInput>
    create: XOR<postsCreateWithoutUsersInput, postsUncheckedCreateWithoutUsersInput>
  }

  export type postsUpdateWithWhereUniqueWithoutUsersInput = {
    where: postsWhereUniqueInput
    data: XOR<postsUpdateWithoutUsersInput, postsUncheckedUpdateWithoutUsersInput>
  }

  export type postsUpdateManyWithWhereWithoutUsersInput = {
    where: postsScalarWhereInput
    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyWithoutUsersInput>
  }

  export type postsScalarWhereInput = {
    AND?: postsScalarWhereInput | postsScalarWhereInput[]
    OR?: postsScalarWhereInput[]
    NOT?: postsScalarWhereInput | postsScalarWhereInput[]
    id?: IntFilter<"posts"> | number
    userId?: IntNullableFilter<"posts"> | number | null
    categoryId?: IntNullableFilter<"posts"> | number | null
    title?: StringFilter<"posts"> | string
    content?: StringFilter<"posts"> | string
    view?: IntFilter<"posts"> | number
    recommend?: IntFilter<"posts"> | number
    reported?: IntFilter<"posts"> | number
    createdDate?: DateTimeFilter<"posts"> | Date | string
    updatedDate?: DateTimeFilter<"posts"> | Date | string
  }

  export type commentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: commentsWhereUniqueInput
    update: XOR<commentsUpdateWithoutUsersInput, commentsUncheckedUpdateWithoutUsersInput>
    create: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput>
  }

  export type commentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: commentsWhereUniqueInput
    data: XOR<commentsUpdateWithoutUsersInput, commentsUncheckedUpdateWithoutUsersInput>
  }

  export type commentsUpdateManyWithWhereWithoutUsersInput = {
    where: commentsScalarWhereInput
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type commentsScalarWhereInput = {
    AND?: commentsScalarWhereInput | commentsScalarWhereInput[]
    OR?: commentsScalarWhereInput[]
    NOT?: commentsScalarWhereInput | commentsScalarWhereInput[]
    id?: IntFilter<"comments"> | number
    postId?: IntFilter<"comments"> | number
    userId?: IntNullableFilter<"comments"> | number | null
    content?: StringFilter<"comments"> | string
    parentCommentId?: IntNullableFilter<"comments"> | number | null
    recommend?: IntFilter<"comments"> | number
    reported?: IntFilter<"comments"> | number
    createdDate?: DateTimeFilter<"comments"> | Date | string
    updatedDate?: DateTimeFilter<"comments"> | Date | string
    isDelete?: BoolFilter<"comments"> | boolean
  }

  export type recommendPostsUpsertWithWhereUniqueWithoutUsersInput = {
    where: recommendPostsWhereUniqueInput
    update: XOR<recommendPostsUpdateWithoutUsersInput, recommendPostsUncheckedUpdateWithoutUsersInput>
    create: XOR<recommendPostsCreateWithoutUsersInput, recommendPostsUncheckedCreateWithoutUsersInput>
  }

  export type recommendPostsUpdateWithWhereUniqueWithoutUsersInput = {
    where: recommendPostsWhereUniqueInput
    data: XOR<recommendPostsUpdateWithoutUsersInput, recommendPostsUncheckedUpdateWithoutUsersInput>
  }

  export type recommendPostsUpdateManyWithWhereWithoutUsersInput = {
    where: recommendPostsScalarWhereInput
    data: XOR<recommendPostsUpdateManyMutationInput, recommendPostsUncheckedUpdateManyWithoutUsersInput>
  }

  export type recommendPostsScalarWhereInput = {
    AND?: recommendPostsScalarWhereInput | recommendPostsScalarWhereInput[]
    OR?: recommendPostsScalarWhereInput[]
    NOT?: recommendPostsScalarWhereInput | recommendPostsScalarWhereInput[]
    id?: IntFilter<"recommendPosts"> | number
    postId?: IntFilter<"recommendPosts"> | number
    userId?: IntFilter<"recommendPosts"> | number
    createdDate?: DateTimeFilter<"recommendPosts"> | Date | string
  }

  export type recommendCommentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: recommendCommentsWhereUniqueInput
    update: XOR<recommendCommentsUpdateWithoutUsersInput, recommendCommentsUncheckedUpdateWithoutUsersInput>
    create: XOR<recommendCommentsCreateWithoutUsersInput, recommendCommentsUncheckedCreateWithoutUsersInput>
  }

  export type recommendCommentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: recommendCommentsWhereUniqueInput
    data: XOR<recommendCommentsUpdateWithoutUsersInput, recommendCommentsUncheckedUpdateWithoutUsersInput>
  }

  export type recommendCommentsUpdateManyWithWhereWithoutUsersInput = {
    where: recommendCommentsScalarWhereInput
    data: XOR<recommendCommentsUpdateManyMutationInput, recommendCommentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type recommendCommentsScalarWhereInput = {
    AND?: recommendCommentsScalarWhereInput | recommendCommentsScalarWhereInput[]
    OR?: recommendCommentsScalarWhereInput[]
    NOT?: recommendCommentsScalarWhereInput | recommendCommentsScalarWhereInput[]
    id?: IntFilter<"recommendComments"> | number
    commentId?: IntFilter<"recommendComments"> | number
    userId?: IntFilter<"recommendComments"> | number
    createdDate?: DateTimeFilter<"recommendComments"> | Date | string
  }

  export type reportedPostsUpsertWithWhereUniqueWithoutUsersInput = {
    where: reportedPostsWhereUniqueInput
    update: XOR<reportedPostsUpdateWithoutUsersInput, reportedPostsUncheckedUpdateWithoutUsersInput>
    create: XOR<reportedPostsCreateWithoutUsersInput, reportedPostsUncheckedCreateWithoutUsersInput>
  }

  export type reportedPostsUpdateWithWhereUniqueWithoutUsersInput = {
    where: reportedPostsWhereUniqueInput
    data: XOR<reportedPostsUpdateWithoutUsersInput, reportedPostsUncheckedUpdateWithoutUsersInput>
  }

  export type reportedPostsUpdateManyWithWhereWithoutUsersInput = {
    where: reportedPostsScalarWhereInput
    data: XOR<reportedPostsUpdateManyMutationInput, reportedPostsUncheckedUpdateManyWithoutUsersInput>
  }

  export type reportedPostsScalarWhereInput = {
    AND?: reportedPostsScalarWhereInput | reportedPostsScalarWhereInput[]
    OR?: reportedPostsScalarWhereInput[]
    NOT?: reportedPostsScalarWhereInput | reportedPostsScalarWhereInput[]
    id?: IntFilter<"reportedPosts"> | number
    postId?: IntFilter<"reportedPosts"> | number
    userId?: IntFilter<"reportedPosts"> | number
    reason?: StringFilter<"reportedPosts"> | string
    createdDate?: DateTimeFilter<"reportedPosts"> | Date | string
  }

  export type reportedCommentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: reportedCommentsWhereUniqueInput
    update: XOR<reportedCommentsUpdateWithoutUsersInput, reportedCommentsUncheckedUpdateWithoutUsersInput>
    create: XOR<reportedCommentsCreateWithoutUsersInput, reportedCommentsUncheckedCreateWithoutUsersInput>
  }

  export type reportedCommentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: reportedCommentsWhereUniqueInput
    data: XOR<reportedCommentsUpdateWithoutUsersInput, reportedCommentsUncheckedUpdateWithoutUsersInput>
  }

  export type reportedCommentsUpdateManyWithWhereWithoutUsersInput = {
    where: reportedCommentsScalarWhereInput
    data: XOR<reportedCommentsUpdateManyMutationInput, reportedCommentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type reportedCommentsScalarWhereInput = {
    AND?: reportedCommentsScalarWhereInput | reportedCommentsScalarWhereInput[]
    OR?: reportedCommentsScalarWhereInput[]
    NOT?: reportedCommentsScalarWhereInput | reportedCommentsScalarWhereInput[]
    id?: IntFilter<"reportedComments"> | number
    commentId?: IntFilter<"reportedComments"> | number
    userId?: IntFilter<"reportedComments"> | number
    reason?: StringFilter<"reportedComments"> | string
    createdDate?: DateTimeFilter<"reportedComments"> | Date | string
  }

  export type reportedUsersUpsertWithWhereUniqueWithoutUsersInput = {
    where: reportedUsersWhereUniqueInput
    update: XOR<reportedUsersUpdateWithoutUsersInput, reportedUsersUncheckedUpdateWithoutUsersInput>
    create: XOR<reportedUsersCreateWithoutUsersInput, reportedUsersUncheckedCreateWithoutUsersInput>
  }

  export type reportedUsersUpdateWithWhereUniqueWithoutUsersInput = {
    where: reportedUsersWhereUniqueInput
    data: XOR<reportedUsersUpdateWithoutUsersInput, reportedUsersUncheckedUpdateWithoutUsersInput>
  }

  export type reportedUsersUpdateManyWithWhereWithoutUsersInput = {
    where: reportedUsersScalarWhereInput
    data: XOR<reportedUsersUpdateManyMutationInput, reportedUsersUncheckedUpdateManyWithoutUsersInput>
  }

  export type reportedUsersScalarWhereInput = {
    AND?: reportedUsersScalarWhereInput | reportedUsersScalarWhereInput[]
    OR?: reportedUsersScalarWhereInput[]
    NOT?: reportedUsersScalarWhereInput | reportedUsersScalarWhereInput[]
    id?: IntFilter<"reportedUsers"> | number
    targetUserId?: IntFilter<"reportedUsers"> | number
    reportingUserId?: IntFilter<"reportedUsers"> | number
    reason?: StringFilter<"reportedUsers"> | string
    createdDate?: DateTimeFilter<"reportedUsers"> | Date | string
  }

  export type usersCreateWithoutIncumbent_additionalInput = {
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    student_additional?: studentsAdditionalCreateNestedOneWithoutUsersInput
    posts?: postsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutIncumbent_additionalInput = {
    id?: number
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    student_additional?: studentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    posts?: postsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsUncheckedCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsUncheckedCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutIncumbent_additionalInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutIncumbent_additionalInput, usersUncheckedCreateWithoutIncumbent_additionalInput>
  }

  export type companyCreateWithoutIncumebentInput = {
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    bigJobKind: bigJobKindCreateNestedOneWithoutCompanyInput
    midJobKind: midJobKindCreateNestedOneWithoutCompanyInput
    smallJobKind: smallJobKindCreateNestedOneWithoutCompanyInput
    student?: studentsAdditionalCreateNestedManyWithoutWishCompanyInput
  }

  export type companyUncheckedCreateWithoutIncumebentInput = {
    id?: number
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    bigJobKindId: number
    midJobKindId: number
    smallJobKindId: number
    student?: studentsAdditionalUncheckedCreateNestedManyWithoutWishCompanyInput
  }

  export type companyCreateOrConnectWithoutIncumebentInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutIncumebentInput, companyUncheckedCreateWithoutIncumebentInput>
  }

  export type schoolCreateWithoutIncumebentInput = {
    name: string
    branch: string
    major?: majorCreateNestedManyWithoutSchoolInput
    student?: studentsAdditionalCreateNestedManyWithoutSchoolInput
  }

  export type schoolUncheckedCreateWithoutIncumebentInput = {
    id?: number
    name: string
    branch: string
    major?: majorUncheckedCreateNestedManyWithoutSchoolInput
    student?: studentsAdditionalUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type schoolCreateOrConnectWithoutIncumebentInput = {
    where: schoolWhereUniqueInput
    create: XOR<schoolCreateWithoutIncumebentInput, schoolUncheckedCreateWithoutIncumebentInput>
  }

  export type majorCreateWithoutIncumebentInput = {
    name: string
    dayAndNight: string
    school: schoolCreateNestedOneWithoutMajorInput
    student?: studentsAdditionalCreateNestedManyWithoutMajorInput
  }

  export type majorUncheckedCreateWithoutIncumebentInput = {
    id?: number
    schoolId: number
    name: string
    dayAndNight: string
    student?: studentsAdditionalUncheckedCreateNestedManyWithoutMajorInput
  }

  export type majorCreateOrConnectWithoutIncumebentInput = {
    where: majorWhereUniqueInput
    create: XOR<majorCreateWithoutIncumebentInput, majorUncheckedCreateWithoutIncumebentInput>
  }

  export type jobCreateWithoutIncumebentInput = {
    clusteringGroup: number
    name: string
    student?: studentsAdditionalCreateNestedManyWithoutWishJobInput
  }

  export type jobUncheckedCreateWithoutIncumebentInput = {
    id?: number
    clusteringGroup: number
    name: string
    student?: studentsAdditionalUncheckedCreateNestedManyWithoutWishJobInput
  }

  export type jobCreateOrConnectWithoutIncumebentInput = {
    where: jobWhereUniqueInput
    create: XOR<jobCreateWithoutIncumebentInput, jobUncheckedCreateWithoutIncumebentInput>
  }

  export type usersUpsertWithoutIncumbent_additionalInput = {
    update: XOR<usersUpdateWithoutIncumbent_additionalInput, usersUncheckedUpdateWithoutIncumbent_additionalInput>
    create: XOR<usersCreateWithoutIncumbent_additionalInput, usersUncheckedCreateWithoutIncumbent_additionalInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutIncumbent_additionalInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutIncumbent_additionalInput, usersUncheckedUpdateWithoutIncumbent_additionalInput>
  }

  export type usersUpdateWithoutIncumbent_additionalInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    student_additional?: studentsAdditionalUpdateOneWithoutUsersNestedInput
    posts?: postsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutIncumbent_additionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    student_additional?: studentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    posts?: postsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUncheckedUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type companyUpsertWithoutIncumebentInput = {
    update: XOR<companyUpdateWithoutIncumebentInput, companyUncheckedUpdateWithoutIncumebentInput>
    create: XOR<companyCreateWithoutIncumebentInput, companyUncheckedCreateWithoutIncumebentInput>
    where?: companyWhereInput
  }

  export type companyUpdateToOneWithWhereWithoutIncumebentInput = {
    where?: companyWhereInput
    data: XOR<companyUpdateWithoutIncumebentInput, companyUncheckedUpdateWithoutIncumebentInput>
  }

  export type companyUpdateWithoutIncumebentInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    bigJobKind?: bigJobKindUpdateOneRequiredWithoutCompanyNestedInput
    midJobKind?: midJobKindUpdateOneRequiredWithoutCompanyNestedInput
    smallJobKind?: smallJobKindUpdateOneRequiredWithoutCompanyNestedInput
    student?: studentsAdditionalUpdateManyWithoutWishCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutIncumebentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    bigJobKindId?: IntFieldUpdateOperationsInput | number
    midJobKindId?: IntFieldUpdateOperationsInput | number
    smallJobKindId?: IntFieldUpdateOperationsInput | number
    student?: studentsAdditionalUncheckedUpdateManyWithoutWishCompanyNestedInput
  }

  export type schoolUpsertWithoutIncumebentInput = {
    update: XOR<schoolUpdateWithoutIncumebentInput, schoolUncheckedUpdateWithoutIncumebentInput>
    create: XOR<schoolCreateWithoutIncumebentInput, schoolUncheckedCreateWithoutIncumebentInput>
    where?: schoolWhereInput
  }

  export type schoolUpdateToOneWithWhereWithoutIncumebentInput = {
    where?: schoolWhereInput
    data: XOR<schoolUpdateWithoutIncumebentInput, schoolUncheckedUpdateWithoutIncumebentInput>
  }

  export type schoolUpdateWithoutIncumebentInput = {
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    major?: majorUpdateManyWithoutSchoolNestedInput
    student?: studentsAdditionalUpdateManyWithoutSchoolNestedInput
  }

  export type schoolUncheckedUpdateWithoutIncumebentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    major?: majorUncheckedUpdateManyWithoutSchoolNestedInput
    student?: studentsAdditionalUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type majorUpsertWithoutIncumebentInput = {
    update: XOR<majorUpdateWithoutIncumebentInput, majorUncheckedUpdateWithoutIncumebentInput>
    create: XOR<majorCreateWithoutIncumebentInput, majorUncheckedCreateWithoutIncumebentInput>
    where?: majorWhereInput
  }

  export type majorUpdateToOneWithWhereWithoutIncumebentInput = {
    where?: majorWhereInput
    data: XOR<majorUpdateWithoutIncumebentInput, majorUncheckedUpdateWithoutIncumebentInput>
  }

  export type majorUpdateWithoutIncumebentInput = {
    name?: StringFieldUpdateOperationsInput | string
    dayAndNight?: StringFieldUpdateOperationsInput | string
    school?: schoolUpdateOneRequiredWithoutMajorNestedInput
    student?: studentsAdditionalUpdateManyWithoutMajorNestedInput
  }

  export type majorUncheckedUpdateWithoutIncumebentInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dayAndNight?: StringFieldUpdateOperationsInput | string
    student?: studentsAdditionalUncheckedUpdateManyWithoutMajorNestedInput
  }

  export type jobUpsertWithoutIncumebentInput = {
    update: XOR<jobUpdateWithoutIncumebentInput, jobUncheckedUpdateWithoutIncumebentInput>
    create: XOR<jobCreateWithoutIncumebentInput, jobUncheckedCreateWithoutIncumebentInput>
    where?: jobWhereInput
  }

  export type jobUpdateToOneWithWhereWithoutIncumebentInput = {
    where?: jobWhereInput
    data: XOR<jobUpdateWithoutIncumebentInput, jobUncheckedUpdateWithoutIncumebentInput>
  }

  export type jobUpdateWithoutIncumebentInput = {
    clusteringGroup?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    student?: studentsAdditionalUpdateManyWithoutWishJobNestedInput
  }

  export type jobUncheckedUpdateWithoutIncumebentInput = {
    id?: IntFieldUpdateOperationsInput | number
    clusteringGroup?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    student?: studentsAdditionalUncheckedUpdateManyWithoutWishJobNestedInput
  }

  export type usersCreateWithoutStudent_additionalInput = {
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalCreateNestedOneWithoutUsersInput
    posts?: postsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutStudent_additionalInput = {
    id?: number
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    posts?: postsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsUncheckedCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsUncheckedCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutStudent_additionalInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutStudent_additionalInput, usersUncheckedCreateWithoutStudent_additionalInput>
  }

  export type companyCreateWithoutStudentInput = {
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    bigJobKind: bigJobKindCreateNestedOneWithoutCompanyInput
    midJobKind: midJobKindCreateNestedOneWithoutCompanyInput
    smallJobKind: smallJobKindCreateNestedOneWithoutCompanyInput
    incumebent?: incumbentsAdditionalCreateNestedManyWithoutCompanyInput
  }

  export type companyUncheckedCreateWithoutStudentInput = {
    id?: number
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    bigJobKindId: number
    midJobKindId: number
    smallJobKindId: number
    incumebent?: incumbentsAdditionalUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type companyCreateOrConnectWithoutStudentInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutStudentInput, companyUncheckedCreateWithoutStudentInput>
  }

  export type schoolCreateWithoutStudentInput = {
    name: string
    branch: string
    major?: majorCreateNestedManyWithoutSchoolInput
    incumebent?: incumbentsAdditionalCreateNestedManyWithoutSchoolInput
  }

  export type schoolUncheckedCreateWithoutStudentInput = {
    id?: number
    name: string
    branch: string
    major?: majorUncheckedCreateNestedManyWithoutSchoolInput
    incumebent?: incumbentsAdditionalUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type schoolCreateOrConnectWithoutStudentInput = {
    where: schoolWhereUniqueInput
    create: XOR<schoolCreateWithoutStudentInput, schoolUncheckedCreateWithoutStudentInput>
  }

  export type majorCreateWithoutStudentInput = {
    name: string
    dayAndNight: string
    school: schoolCreateNestedOneWithoutMajorInput
    incumebent?: incumbentsAdditionalCreateNestedManyWithoutMajorInput
  }

  export type majorUncheckedCreateWithoutStudentInput = {
    id?: number
    schoolId: number
    name: string
    dayAndNight: string
    incumebent?: incumbentsAdditionalUncheckedCreateNestedManyWithoutMajorInput
  }

  export type majorCreateOrConnectWithoutStudentInput = {
    where: majorWhereUniqueInput
    create: XOR<majorCreateWithoutStudentInput, majorUncheckedCreateWithoutStudentInput>
  }

  export type jobCreateWithoutStudentInput = {
    clusteringGroup: number
    name: string
    incumebent?: incumbentsAdditionalCreateNestedManyWithoutJobInput
  }

  export type jobUncheckedCreateWithoutStudentInput = {
    id?: number
    clusteringGroup: number
    name: string
    incumebent?: incumbentsAdditionalUncheckedCreateNestedManyWithoutJobInput
  }

  export type jobCreateOrConnectWithoutStudentInput = {
    where: jobWhereUniqueInput
    create: XOR<jobCreateWithoutStudentInput, jobUncheckedCreateWithoutStudentInput>
  }

  export type usersUpsertWithoutStudent_additionalInput = {
    update: XOR<usersUpdateWithoutStudent_additionalInput, usersUncheckedUpdateWithoutStudent_additionalInput>
    create: XOR<usersCreateWithoutStudent_additionalInput, usersUncheckedCreateWithoutStudent_additionalInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutStudent_additionalInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutStudent_additionalInput, usersUncheckedUpdateWithoutStudent_additionalInput>
  }

  export type usersUpdateWithoutStudent_additionalInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUpdateOneWithoutUsersNestedInput
    posts?: postsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutStudent_additionalInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    posts?: postsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUncheckedUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type companyUpsertWithoutStudentInput = {
    update: XOR<companyUpdateWithoutStudentInput, companyUncheckedUpdateWithoutStudentInput>
    create: XOR<companyCreateWithoutStudentInput, companyUncheckedCreateWithoutStudentInput>
    where?: companyWhereInput
  }

  export type companyUpdateToOneWithWhereWithoutStudentInput = {
    where?: companyWhereInput
    data: XOR<companyUpdateWithoutStudentInput, companyUncheckedUpdateWithoutStudentInput>
  }

  export type companyUpdateWithoutStudentInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    bigJobKind?: bigJobKindUpdateOneRequiredWithoutCompanyNestedInput
    midJobKind?: midJobKindUpdateOneRequiredWithoutCompanyNestedInput
    smallJobKind?: smallJobKindUpdateOneRequiredWithoutCompanyNestedInput
    incumebent?: incumbentsAdditionalUpdateManyWithoutCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    bigJobKindId?: IntFieldUpdateOperationsInput | number
    midJobKindId?: IntFieldUpdateOperationsInput | number
    smallJobKindId?: IntFieldUpdateOperationsInput | number
    incumebent?: incumbentsAdditionalUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type schoolUpsertWithoutStudentInput = {
    update: XOR<schoolUpdateWithoutStudentInput, schoolUncheckedUpdateWithoutStudentInput>
    create: XOR<schoolCreateWithoutStudentInput, schoolUncheckedCreateWithoutStudentInput>
    where?: schoolWhereInput
  }

  export type schoolUpdateToOneWithWhereWithoutStudentInput = {
    where?: schoolWhereInput
    data: XOR<schoolUpdateWithoutStudentInput, schoolUncheckedUpdateWithoutStudentInput>
  }

  export type schoolUpdateWithoutStudentInput = {
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    major?: majorUpdateManyWithoutSchoolNestedInput
    incumebent?: incumbentsAdditionalUpdateManyWithoutSchoolNestedInput
  }

  export type schoolUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    major?: majorUncheckedUpdateManyWithoutSchoolNestedInput
    incumebent?: incumbentsAdditionalUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type majorUpsertWithoutStudentInput = {
    update: XOR<majorUpdateWithoutStudentInput, majorUncheckedUpdateWithoutStudentInput>
    create: XOR<majorCreateWithoutStudentInput, majorUncheckedCreateWithoutStudentInput>
    where?: majorWhereInput
  }

  export type majorUpdateToOneWithWhereWithoutStudentInput = {
    where?: majorWhereInput
    data: XOR<majorUpdateWithoutStudentInput, majorUncheckedUpdateWithoutStudentInput>
  }

  export type majorUpdateWithoutStudentInput = {
    name?: StringFieldUpdateOperationsInput | string
    dayAndNight?: StringFieldUpdateOperationsInput | string
    school?: schoolUpdateOneRequiredWithoutMajorNestedInput
    incumebent?: incumbentsAdditionalUpdateManyWithoutMajorNestedInput
  }

  export type majorUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    schoolId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dayAndNight?: StringFieldUpdateOperationsInput | string
    incumebent?: incumbentsAdditionalUncheckedUpdateManyWithoutMajorNestedInput
  }

  export type jobUpsertWithoutStudentInput = {
    update: XOR<jobUpdateWithoutStudentInput, jobUncheckedUpdateWithoutStudentInput>
    create: XOR<jobCreateWithoutStudentInput, jobUncheckedCreateWithoutStudentInput>
    where?: jobWhereInput
  }

  export type jobUpdateToOneWithWhereWithoutStudentInput = {
    where?: jobWhereInput
    data: XOR<jobUpdateWithoutStudentInput, jobUncheckedUpdateWithoutStudentInput>
  }

  export type jobUpdateWithoutStudentInput = {
    clusteringGroup?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    incumebent?: incumbentsAdditionalUpdateManyWithoutJobNestedInput
  }

  export type jobUncheckedUpdateWithoutStudentInput = {
    id?: IntFieldUpdateOperationsInput | number
    clusteringGroup?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    incumebent?: incumbentsAdditionalUncheckedUpdateManyWithoutJobNestedInput
  }

  export type postsCreateWithoutCategoriesInput = {
    title: string
    content: string
    view?: number
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    users?: usersCreateNestedOneWithoutPostsInput
    comments?: commentsCreateNestedManyWithoutPostInput
    recommend_posts?: recommendPostsCreateNestedManyWithoutPostInput
    reported_posts?: reportedPostsCreateNestedManyWithoutPostInput
  }

  export type postsUncheckedCreateWithoutCategoriesInput = {
    id?: number
    userId?: number | null
    title: string
    content: string
    view?: number
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    comments?: commentsUncheckedCreateNestedManyWithoutPostInput
    recommend_posts?: recommendPostsUncheckedCreateNestedManyWithoutPostInput
    reported_posts?: reportedPostsUncheckedCreateNestedManyWithoutPostInput
  }

  export type postsCreateOrConnectWithoutCategoriesInput = {
    where: postsWhereUniqueInput
    create: XOR<postsCreateWithoutCategoriesInput, postsUncheckedCreateWithoutCategoriesInput>
  }

  export type postsCreateManyCategoriesInputEnvelope = {
    data: postsCreateManyCategoriesInput | postsCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type postsUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: postsWhereUniqueInput
    update: XOR<postsUpdateWithoutCategoriesInput, postsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<postsCreateWithoutCategoriesInput, postsUncheckedCreateWithoutCategoriesInput>
  }

  export type postsUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: postsWhereUniqueInput
    data: XOR<postsUpdateWithoutCategoriesInput, postsUncheckedUpdateWithoutCategoriesInput>
  }

  export type postsUpdateManyWithWhereWithoutCategoriesInput = {
    where: postsScalarWhereInput
    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type categoryCreateWithoutPostsInput = {
    name: string
  }

  export type categoryUncheckedCreateWithoutPostsInput = {
    id?: number
    name: string
  }

  export type categoryCreateOrConnectWithoutPostsInput = {
    where: categoryWhereUniqueInput
    create: XOR<categoryCreateWithoutPostsInput, categoryUncheckedCreateWithoutPostsInput>
  }

  export type usersCreateWithoutPostsInput = {
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalCreateNestedOneWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPostsInput = {
    id?: number
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsUncheckedCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsUncheckedCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPostsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>
  }

  export type commentsCreateWithoutPostInput = {
    content: string
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
    users?: usersCreateNestedOneWithoutCommentsInput
    parent?: commentsCreateNestedOneWithoutRepliesInput
    replies?: commentsCreateNestedManyWithoutParentInput
    recommend_comments?: recommendCommentsCreateNestedManyWithoutCommentInput
    reported_comments?: reportedCommentsCreateNestedManyWithoutCommentInput
  }

  export type commentsUncheckedCreateWithoutPostInput = {
    id?: number
    userId?: number | null
    content: string
    parentCommentId?: number | null
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
    replies?: commentsUncheckedCreateNestedManyWithoutParentInput
    recommend_comments?: recommendCommentsUncheckedCreateNestedManyWithoutCommentInput
    reported_comments?: reportedCommentsUncheckedCreateNestedManyWithoutCommentInput
  }

  export type commentsCreateOrConnectWithoutPostInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput>
  }

  export type commentsCreateManyPostInputEnvelope = {
    data: commentsCreateManyPostInput | commentsCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type recommendPostsCreateWithoutPostInput = {
    createdDate?: Date | string
    users?: usersCreateNestedOneWithoutRecommend_postsInput
  }

  export type recommendPostsUncheckedCreateWithoutPostInput = {
    id?: number
    userId: number
    createdDate?: Date | string
  }

  export type recommendPostsCreateOrConnectWithoutPostInput = {
    where: recommendPostsWhereUniqueInput
    create: XOR<recommendPostsCreateWithoutPostInput, recommendPostsUncheckedCreateWithoutPostInput>
  }

  export type recommendPostsCreateManyPostInputEnvelope = {
    data: recommendPostsCreateManyPostInput | recommendPostsCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type reportedPostsCreateWithoutPostInput = {
    reason: string
    createdDate?: Date | string
    users?: usersCreateNestedOneWithoutReported_postsInput
  }

  export type reportedPostsUncheckedCreateWithoutPostInput = {
    id?: number
    userId: number
    reason: string
    createdDate?: Date | string
  }

  export type reportedPostsCreateOrConnectWithoutPostInput = {
    where: reportedPostsWhereUniqueInput
    create: XOR<reportedPostsCreateWithoutPostInput, reportedPostsUncheckedCreateWithoutPostInput>
  }

  export type reportedPostsCreateManyPostInputEnvelope = {
    data: reportedPostsCreateManyPostInput | reportedPostsCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type categoryUpsertWithoutPostsInput = {
    update: XOR<categoryUpdateWithoutPostsInput, categoryUncheckedUpdateWithoutPostsInput>
    create: XOR<categoryCreateWithoutPostsInput, categoryUncheckedCreateWithoutPostsInput>
    where?: categoryWhereInput
  }

  export type categoryUpdateToOneWithWhereWithoutPostsInput = {
    where?: categoryWhereInput
    data: XOR<categoryUpdateWithoutPostsInput, categoryUncheckedUpdateWithoutPostsInput>
  }

  export type categoryUpdateWithoutPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type categoryUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type usersUpsertWithoutPostsInput = {
    update: XOR<usersUpdateWithoutPostsInput, usersUncheckedUpdateWithoutPostsInput>
    create: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPostsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPostsInput, usersUncheckedUpdateWithoutPostsInput>
  }

  export type usersUpdateWithoutPostsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUpdateOneWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUncheckedUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type commentsUpsertWithWhereUniqueWithoutPostInput = {
    where: commentsWhereUniqueInput
    update: XOR<commentsUpdateWithoutPostInput, commentsUncheckedUpdateWithoutPostInput>
    create: XOR<commentsCreateWithoutPostInput, commentsUncheckedCreateWithoutPostInput>
  }

  export type commentsUpdateWithWhereUniqueWithoutPostInput = {
    where: commentsWhereUniqueInput
    data: XOR<commentsUpdateWithoutPostInput, commentsUncheckedUpdateWithoutPostInput>
  }

  export type commentsUpdateManyWithWhereWithoutPostInput = {
    where: commentsScalarWhereInput
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutPostInput>
  }

  export type recommendPostsUpsertWithWhereUniqueWithoutPostInput = {
    where: recommendPostsWhereUniqueInput
    update: XOR<recommendPostsUpdateWithoutPostInput, recommendPostsUncheckedUpdateWithoutPostInput>
    create: XOR<recommendPostsCreateWithoutPostInput, recommendPostsUncheckedCreateWithoutPostInput>
  }

  export type recommendPostsUpdateWithWhereUniqueWithoutPostInput = {
    where: recommendPostsWhereUniqueInput
    data: XOR<recommendPostsUpdateWithoutPostInput, recommendPostsUncheckedUpdateWithoutPostInput>
  }

  export type recommendPostsUpdateManyWithWhereWithoutPostInput = {
    where: recommendPostsScalarWhereInput
    data: XOR<recommendPostsUpdateManyMutationInput, recommendPostsUncheckedUpdateManyWithoutPostInput>
  }

  export type reportedPostsUpsertWithWhereUniqueWithoutPostInput = {
    where: reportedPostsWhereUniqueInput
    update: XOR<reportedPostsUpdateWithoutPostInput, reportedPostsUncheckedUpdateWithoutPostInput>
    create: XOR<reportedPostsCreateWithoutPostInput, reportedPostsUncheckedCreateWithoutPostInput>
  }

  export type reportedPostsUpdateWithWhereUniqueWithoutPostInput = {
    where: reportedPostsWhereUniqueInput
    data: XOR<reportedPostsUpdateWithoutPostInput, reportedPostsUncheckedUpdateWithoutPostInput>
  }

  export type reportedPostsUpdateManyWithWhereWithoutPostInput = {
    where: reportedPostsScalarWhereInput
    data: XOR<reportedPostsUpdateManyMutationInput, reportedPostsUncheckedUpdateManyWithoutPostInput>
  }

  export type usersCreateWithoutCommentsInput = {
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalCreateNestedOneWithoutUsersInput
    posts?: postsCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutCommentsInput = {
    id?: number
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    posts?: postsUncheckedCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsUncheckedCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsUncheckedCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutCommentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
  }

  export type postsCreateWithoutCommentsInput = {
    title: string
    content: string
    view?: number
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    categories?: categoryCreateNestedOneWithoutPostsInput
    users?: usersCreateNestedOneWithoutPostsInput
    recommend_posts?: recommendPostsCreateNestedManyWithoutPostInput
    reported_posts?: reportedPostsCreateNestedManyWithoutPostInput
  }

  export type postsUncheckedCreateWithoutCommentsInput = {
    id?: number
    userId?: number | null
    categoryId?: number | null
    title: string
    content: string
    view?: number
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    recommend_posts?: recommendPostsUncheckedCreateNestedManyWithoutPostInput
    reported_posts?: reportedPostsUncheckedCreateNestedManyWithoutPostInput
  }

  export type postsCreateOrConnectWithoutCommentsInput = {
    where: postsWhereUniqueInput
    create: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>
  }

  export type commentsCreateWithoutRepliesInput = {
    content: string
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
    users?: usersCreateNestedOneWithoutCommentsInput
    post: postsCreateNestedOneWithoutCommentsInput
    parent?: commentsCreateNestedOneWithoutRepliesInput
    recommend_comments?: recommendCommentsCreateNestedManyWithoutCommentInput
    reported_comments?: reportedCommentsCreateNestedManyWithoutCommentInput
  }

  export type commentsUncheckedCreateWithoutRepliesInput = {
    id?: number
    postId: number
    userId?: number | null
    content: string
    parentCommentId?: number | null
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
    recommend_comments?: recommendCommentsUncheckedCreateNestedManyWithoutCommentInput
    reported_comments?: reportedCommentsUncheckedCreateNestedManyWithoutCommentInput
  }

  export type commentsCreateOrConnectWithoutRepliesInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutRepliesInput, commentsUncheckedCreateWithoutRepliesInput>
  }

  export type commentsCreateWithoutParentInput = {
    content: string
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
    users?: usersCreateNestedOneWithoutCommentsInput
    post: postsCreateNestedOneWithoutCommentsInput
    replies?: commentsCreateNestedManyWithoutParentInput
    recommend_comments?: recommendCommentsCreateNestedManyWithoutCommentInput
    reported_comments?: reportedCommentsCreateNestedManyWithoutCommentInput
  }

  export type commentsUncheckedCreateWithoutParentInput = {
    id?: number
    postId: number
    userId?: number | null
    content: string
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
    replies?: commentsUncheckedCreateNestedManyWithoutParentInput
    recommend_comments?: recommendCommentsUncheckedCreateNestedManyWithoutCommentInput
    reported_comments?: reportedCommentsUncheckedCreateNestedManyWithoutCommentInput
  }

  export type commentsCreateOrConnectWithoutParentInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput>
  }

  export type commentsCreateManyParentInputEnvelope = {
    data: commentsCreateManyParentInput | commentsCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type recommendCommentsCreateWithoutCommentInput = {
    createdDate?: Date | string
    users?: usersCreateNestedOneWithoutRecommend_commentsInput
  }

  export type recommendCommentsUncheckedCreateWithoutCommentInput = {
    id?: number
    userId: number
    createdDate?: Date | string
  }

  export type recommendCommentsCreateOrConnectWithoutCommentInput = {
    where: recommendCommentsWhereUniqueInput
    create: XOR<recommendCommentsCreateWithoutCommentInput, recommendCommentsUncheckedCreateWithoutCommentInput>
  }

  export type recommendCommentsCreateManyCommentInputEnvelope = {
    data: recommendCommentsCreateManyCommentInput | recommendCommentsCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type reportedCommentsCreateWithoutCommentInput = {
    reason: string
    createdDate?: Date | string
    users?: usersCreateNestedOneWithoutReported_commentsInput
  }

  export type reportedCommentsUncheckedCreateWithoutCommentInput = {
    id?: number
    userId: number
    reason: string
    createdDate?: Date | string
  }

  export type reportedCommentsCreateOrConnectWithoutCommentInput = {
    where: reportedCommentsWhereUniqueInput
    create: XOR<reportedCommentsCreateWithoutCommentInput, reportedCommentsUncheckedCreateWithoutCommentInput>
  }

  export type reportedCommentsCreateManyCommentInputEnvelope = {
    data: reportedCommentsCreateManyCommentInput | reportedCommentsCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutCommentsInput = {
    update: XOR<usersUpdateWithoutCommentsInput, usersUncheckedUpdateWithoutCommentsInput>
    create: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCommentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCommentsInput, usersUncheckedUpdateWithoutCommentsInput>
  }

  export type usersUpdateWithoutCommentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUpdateOneWithoutUsersNestedInput
    posts?: postsUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    posts?: postsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUncheckedUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type postsUpsertWithoutCommentsInput = {
    update: XOR<postsUpdateWithoutCommentsInput, postsUncheckedUpdateWithoutCommentsInput>
    create: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>
    where?: postsWhereInput
  }

  export type postsUpdateToOneWithWhereWithoutCommentsInput = {
    where?: postsWhereInput
    data: XOR<postsUpdateWithoutCommentsInput, postsUncheckedUpdateWithoutCommentsInput>
  }

  export type postsUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: categoryUpdateOneWithoutPostsNestedInput
    users?: usersUpdateOneWithoutPostsNestedInput
    recommend_posts?: recommendPostsUpdateManyWithoutPostNestedInput
    reported_posts?: reportedPostsUpdateManyWithoutPostNestedInput
  }

  export type postsUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    recommend_posts?: recommendPostsUncheckedUpdateManyWithoutPostNestedInput
    reported_posts?: reportedPostsUncheckedUpdateManyWithoutPostNestedInput
  }

  export type commentsUpsertWithoutRepliesInput = {
    update: XOR<commentsUpdateWithoutRepliesInput, commentsUncheckedUpdateWithoutRepliesInput>
    create: XOR<commentsCreateWithoutRepliesInput, commentsUncheckedCreateWithoutRepliesInput>
    where?: commentsWhereInput
  }

  export type commentsUpdateToOneWithWhereWithoutRepliesInput = {
    where?: commentsWhereInput
    data: XOR<commentsUpdateWithoutRepliesInput, commentsUncheckedUpdateWithoutRepliesInput>
  }

  export type commentsUpdateWithoutRepliesInput = {
    content?: StringFieldUpdateOperationsInput | string
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    users?: usersUpdateOneWithoutCommentsNestedInput
    post?: postsUpdateOneRequiredWithoutCommentsNestedInput
    parent?: commentsUpdateOneWithoutRepliesNestedInput
    recommend_comments?: recommendCommentsUpdateManyWithoutCommentNestedInput
    reported_comments?: reportedCommentsUpdateManyWithoutCommentNestedInput
  }

  export type commentsUncheckedUpdateWithoutRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    recommend_comments?: recommendCommentsUncheckedUpdateManyWithoutCommentNestedInput
    reported_comments?: reportedCommentsUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type commentsUpsertWithWhereUniqueWithoutParentInput = {
    where: commentsWhereUniqueInput
    update: XOR<commentsUpdateWithoutParentInput, commentsUncheckedUpdateWithoutParentInput>
    create: XOR<commentsCreateWithoutParentInput, commentsUncheckedCreateWithoutParentInput>
  }

  export type commentsUpdateWithWhereUniqueWithoutParentInput = {
    where: commentsWhereUniqueInput
    data: XOR<commentsUpdateWithoutParentInput, commentsUncheckedUpdateWithoutParentInput>
  }

  export type commentsUpdateManyWithWhereWithoutParentInput = {
    where: commentsScalarWhereInput
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutParentInput>
  }

  export type recommendCommentsUpsertWithWhereUniqueWithoutCommentInput = {
    where: recommendCommentsWhereUniqueInput
    update: XOR<recommendCommentsUpdateWithoutCommentInput, recommendCommentsUncheckedUpdateWithoutCommentInput>
    create: XOR<recommendCommentsCreateWithoutCommentInput, recommendCommentsUncheckedCreateWithoutCommentInput>
  }

  export type recommendCommentsUpdateWithWhereUniqueWithoutCommentInput = {
    where: recommendCommentsWhereUniqueInput
    data: XOR<recommendCommentsUpdateWithoutCommentInput, recommendCommentsUncheckedUpdateWithoutCommentInput>
  }

  export type recommendCommentsUpdateManyWithWhereWithoutCommentInput = {
    where: recommendCommentsScalarWhereInput
    data: XOR<recommendCommentsUpdateManyMutationInput, recommendCommentsUncheckedUpdateManyWithoutCommentInput>
  }

  export type reportedCommentsUpsertWithWhereUniqueWithoutCommentInput = {
    where: reportedCommentsWhereUniqueInput
    update: XOR<reportedCommentsUpdateWithoutCommentInput, reportedCommentsUncheckedUpdateWithoutCommentInput>
    create: XOR<reportedCommentsCreateWithoutCommentInput, reportedCommentsUncheckedCreateWithoutCommentInput>
  }

  export type reportedCommentsUpdateWithWhereUniqueWithoutCommentInput = {
    where: reportedCommentsWhereUniqueInput
    data: XOR<reportedCommentsUpdateWithoutCommentInput, reportedCommentsUncheckedUpdateWithoutCommentInput>
  }

  export type reportedCommentsUpdateManyWithWhereWithoutCommentInput = {
    where: reportedCommentsScalarWhereInput
    data: XOR<reportedCommentsUpdateManyMutationInput, reportedCommentsUncheckedUpdateManyWithoutCommentInput>
  }

  export type usersCreateWithoutRecommend_postsInput = {
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalCreateNestedOneWithoutUsersInput
    posts?: postsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutRecommend_postsInput = {
    id?: number
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    posts?: postsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsUncheckedCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutRecommend_postsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRecommend_postsInput, usersUncheckedCreateWithoutRecommend_postsInput>
  }

  export type postsCreateWithoutRecommend_postsInput = {
    title: string
    content: string
    view?: number
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    categories?: categoryCreateNestedOneWithoutPostsInput
    users?: usersCreateNestedOneWithoutPostsInput
    comments?: commentsCreateNestedManyWithoutPostInput
    reported_posts?: reportedPostsCreateNestedManyWithoutPostInput
  }

  export type postsUncheckedCreateWithoutRecommend_postsInput = {
    id?: number
    userId?: number | null
    categoryId?: number | null
    title: string
    content: string
    view?: number
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    comments?: commentsUncheckedCreateNestedManyWithoutPostInput
    reported_posts?: reportedPostsUncheckedCreateNestedManyWithoutPostInput
  }

  export type postsCreateOrConnectWithoutRecommend_postsInput = {
    where: postsWhereUniqueInput
    create: XOR<postsCreateWithoutRecommend_postsInput, postsUncheckedCreateWithoutRecommend_postsInput>
  }

  export type usersUpsertWithoutRecommend_postsInput = {
    update: XOR<usersUpdateWithoutRecommend_postsInput, usersUncheckedUpdateWithoutRecommend_postsInput>
    create: XOR<usersCreateWithoutRecommend_postsInput, usersUncheckedCreateWithoutRecommend_postsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRecommend_postsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRecommend_postsInput, usersUncheckedUpdateWithoutRecommend_postsInput>
  }

  export type usersUpdateWithoutRecommend_postsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUpdateOneWithoutUsersNestedInput
    posts?: postsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutRecommend_postsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    posts?: postsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUncheckedUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type postsUpsertWithoutRecommend_postsInput = {
    update: XOR<postsUpdateWithoutRecommend_postsInput, postsUncheckedUpdateWithoutRecommend_postsInput>
    create: XOR<postsCreateWithoutRecommend_postsInput, postsUncheckedCreateWithoutRecommend_postsInput>
    where?: postsWhereInput
  }

  export type postsUpdateToOneWithWhereWithoutRecommend_postsInput = {
    where?: postsWhereInput
    data: XOR<postsUpdateWithoutRecommend_postsInput, postsUncheckedUpdateWithoutRecommend_postsInput>
  }

  export type postsUpdateWithoutRecommend_postsInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: categoryUpdateOneWithoutPostsNestedInput
    users?: usersUpdateOneWithoutPostsNestedInput
    comments?: commentsUpdateManyWithoutPostNestedInput
    reported_posts?: reportedPostsUpdateManyWithoutPostNestedInput
  }

  export type postsUncheckedUpdateWithoutRecommend_postsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: commentsUncheckedUpdateManyWithoutPostNestedInput
    reported_posts?: reportedPostsUncheckedUpdateManyWithoutPostNestedInput
  }

  export type usersCreateWithoutReported_postsInput = {
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalCreateNestedOneWithoutUsersInput
    posts?: postsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutReported_postsInput = {
    id?: number
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    posts?: postsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsUncheckedCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutReported_postsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutReported_postsInput, usersUncheckedCreateWithoutReported_postsInput>
  }

  export type postsCreateWithoutReported_postsInput = {
    title: string
    content: string
    view?: number
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    categories?: categoryCreateNestedOneWithoutPostsInput
    users?: usersCreateNestedOneWithoutPostsInput
    comments?: commentsCreateNestedManyWithoutPostInput
    recommend_posts?: recommendPostsCreateNestedManyWithoutPostInput
  }

  export type postsUncheckedCreateWithoutReported_postsInput = {
    id?: number
    userId?: number | null
    categoryId?: number | null
    title: string
    content: string
    view?: number
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    comments?: commentsUncheckedCreateNestedManyWithoutPostInput
    recommend_posts?: recommendPostsUncheckedCreateNestedManyWithoutPostInput
  }

  export type postsCreateOrConnectWithoutReported_postsInput = {
    where: postsWhereUniqueInput
    create: XOR<postsCreateWithoutReported_postsInput, postsUncheckedCreateWithoutReported_postsInput>
  }

  export type usersUpsertWithoutReported_postsInput = {
    update: XOR<usersUpdateWithoutReported_postsInput, usersUncheckedUpdateWithoutReported_postsInput>
    create: XOR<usersCreateWithoutReported_postsInput, usersUncheckedCreateWithoutReported_postsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutReported_postsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutReported_postsInput, usersUncheckedUpdateWithoutReported_postsInput>
  }

  export type usersUpdateWithoutReported_postsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUpdateOneWithoutUsersNestedInput
    posts?: postsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutReported_postsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    posts?: postsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type postsUpsertWithoutReported_postsInput = {
    update: XOR<postsUpdateWithoutReported_postsInput, postsUncheckedUpdateWithoutReported_postsInput>
    create: XOR<postsCreateWithoutReported_postsInput, postsUncheckedCreateWithoutReported_postsInput>
    where?: postsWhereInput
  }

  export type postsUpdateToOneWithWhereWithoutReported_postsInput = {
    where?: postsWhereInput
    data: XOR<postsUpdateWithoutReported_postsInput, postsUncheckedUpdateWithoutReported_postsInput>
  }

  export type postsUpdateWithoutReported_postsInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: categoryUpdateOneWithoutPostsNestedInput
    users?: usersUpdateOneWithoutPostsNestedInput
    comments?: commentsUpdateManyWithoutPostNestedInput
    recommend_posts?: recommendPostsUpdateManyWithoutPostNestedInput
  }

  export type postsUncheckedUpdateWithoutReported_postsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: commentsUncheckedUpdateManyWithoutPostNestedInput
    recommend_posts?: recommendPostsUncheckedUpdateManyWithoutPostNestedInput
  }

  export type commentsCreateWithoutRecommend_commentsInput = {
    content: string
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
    users?: usersCreateNestedOneWithoutCommentsInput
    post: postsCreateNestedOneWithoutCommentsInput
    parent?: commentsCreateNestedOneWithoutRepliesInput
    replies?: commentsCreateNestedManyWithoutParentInput
    reported_comments?: reportedCommentsCreateNestedManyWithoutCommentInput
  }

  export type commentsUncheckedCreateWithoutRecommend_commentsInput = {
    id?: number
    postId: number
    userId?: number | null
    content: string
    parentCommentId?: number | null
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
    replies?: commentsUncheckedCreateNestedManyWithoutParentInput
    reported_comments?: reportedCommentsUncheckedCreateNestedManyWithoutCommentInput
  }

  export type commentsCreateOrConnectWithoutRecommend_commentsInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutRecommend_commentsInput, commentsUncheckedCreateWithoutRecommend_commentsInput>
  }

  export type usersCreateWithoutRecommend_commentsInput = {
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalCreateNestedOneWithoutUsersInput
    posts?: postsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutRecommend_commentsInput = {
    id?: number
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    posts?: postsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsUncheckedCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsUncheckedCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutRecommend_commentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRecommend_commentsInput, usersUncheckedCreateWithoutRecommend_commentsInput>
  }

  export type commentsUpsertWithoutRecommend_commentsInput = {
    update: XOR<commentsUpdateWithoutRecommend_commentsInput, commentsUncheckedUpdateWithoutRecommend_commentsInput>
    create: XOR<commentsCreateWithoutRecommend_commentsInput, commentsUncheckedCreateWithoutRecommend_commentsInput>
    where?: commentsWhereInput
  }

  export type commentsUpdateToOneWithWhereWithoutRecommend_commentsInput = {
    where?: commentsWhereInput
    data: XOR<commentsUpdateWithoutRecommend_commentsInput, commentsUncheckedUpdateWithoutRecommend_commentsInput>
  }

  export type commentsUpdateWithoutRecommend_commentsInput = {
    content?: StringFieldUpdateOperationsInput | string
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    users?: usersUpdateOneWithoutCommentsNestedInput
    post?: postsUpdateOneRequiredWithoutCommentsNestedInput
    parent?: commentsUpdateOneWithoutRepliesNestedInput
    replies?: commentsUpdateManyWithoutParentNestedInput
    reported_comments?: reportedCommentsUpdateManyWithoutCommentNestedInput
  }

  export type commentsUncheckedUpdateWithoutRecommend_commentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    replies?: commentsUncheckedUpdateManyWithoutParentNestedInput
    reported_comments?: reportedCommentsUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type usersUpsertWithoutRecommend_commentsInput = {
    update: XOR<usersUpdateWithoutRecommend_commentsInput, usersUncheckedUpdateWithoutRecommend_commentsInput>
    create: XOR<usersCreateWithoutRecommend_commentsInput, usersUncheckedCreateWithoutRecommend_commentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutRecommend_commentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutRecommend_commentsInput, usersUncheckedUpdateWithoutRecommend_commentsInput>
  }

  export type usersUpdateWithoutRecommend_commentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUpdateOneWithoutUsersNestedInput
    posts?: postsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutRecommend_commentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    posts?: postsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUncheckedUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUncheckedUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type commentsCreateWithoutReported_commentsInput = {
    content: string
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
    users?: usersCreateNestedOneWithoutCommentsInput
    post: postsCreateNestedOneWithoutCommentsInput
    parent?: commentsCreateNestedOneWithoutRepliesInput
    replies?: commentsCreateNestedManyWithoutParentInput
    recommend_comments?: recommendCommentsCreateNestedManyWithoutCommentInput
  }

  export type commentsUncheckedCreateWithoutReported_commentsInput = {
    id?: number
    postId: number
    userId?: number | null
    content: string
    parentCommentId?: number | null
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
    replies?: commentsUncheckedCreateNestedManyWithoutParentInput
    recommend_comments?: recommendCommentsUncheckedCreateNestedManyWithoutCommentInput
  }

  export type commentsCreateOrConnectWithoutReported_commentsInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutReported_commentsInput, commentsUncheckedCreateWithoutReported_commentsInput>
  }

  export type usersCreateWithoutReported_commentsInput = {
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalCreateNestedOneWithoutUsersInput
    posts?: postsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutReported_commentsInput = {
    id?: number
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    posts?: postsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsUncheckedCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsUncheckedCreateNestedManyWithoutUsersInput
    reported_users?: reportedUsersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutReported_commentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutReported_commentsInput, usersUncheckedCreateWithoutReported_commentsInput>
  }

  export type commentsUpsertWithoutReported_commentsInput = {
    update: XOR<commentsUpdateWithoutReported_commentsInput, commentsUncheckedUpdateWithoutReported_commentsInput>
    create: XOR<commentsCreateWithoutReported_commentsInput, commentsUncheckedCreateWithoutReported_commentsInput>
    where?: commentsWhereInput
  }

  export type commentsUpdateToOneWithWhereWithoutReported_commentsInput = {
    where?: commentsWhereInput
    data: XOR<commentsUpdateWithoutReported_commentsInput, commentsUncheckedUpdateWithoutReported_commentsInput>
  }

  export type commentsUpdateWithoutReported_commentsInput = {
    content?: StringFieldUpdateOperationsInput | string
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    users?: usersUpdateOneWithoutCommentsNestedInput
    post?: postsUpdateOneRequiredWithoutCommentsNestedInput
    parent?: commentsUpdateOneWithoutRepliesNestedInput
    replies?: commentsUpdateManyWithoutParentNestedInput
    recommend_comments?: recommendCommentsUpdateManyWithoutCommentNestedInput
  }

  export type commentsUncheckedUpdateWithoutReported_commentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    replies?: commentsUncheckedUpdateManyWithoutParentNestedInput
    recommend_comments?: recommendCommentsUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type usersUpsertWithoutReported_commentsInput = {
    update: XOR<usersUpdateWithoutReported_commentsInput, usersUncheckedUpdateWithoutReported_commentsInput>
    create: XOR<usersCreateWithoutReported_commentsInput, usersUncheckedCreateWithoutReported_commentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutReported_commentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutReported_commentsInput, usersUncheckedUpdateWithoutReported_commentsInput>
  }

  export type usersUpdateWithoutReported_commentsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUpdateOneWithoutUsersNestedInput
    posts?: postsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutReported_commentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    posts?: postsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUncheckedUpdateManyWithoutUsersNestedInput
    reported_users?: reportedUsersUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutReported_usersInput = {
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalCreateNestedOneWithoutUsersInput
    posts?: postsCreateNestedManyWithoutUsersInput
    comments?: commentsCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutReported_usersInput = {
    id?: number
    email: string
    password: string
    name: string
    age: number
    gender: $Enums.Gender
    image?: string | null
    type: $Enums.userType
    createdDate?: Date | string
    updatedDate?: Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    student_additional?: studentsAdditionalUncheckedCreateNestedOneWithoutUsersInput
    posts?: postsUncheckedCreateNestedManyWithoutUsersInput
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    recommend_posts?: recommendPostsUncheckedCreateNestedManyWithoutUsersInput
    recommend_comments?: recommendCommentsUncheckedCreateNestedManyWithoutUsersInput
    reported_posts?: reportedPostsUncheckedCreateNestedManyWithoutUsersInput
    reported_comments?: reportedCommentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutReported_usersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutReported_usersInput, usersUncheckedCreateWithoutReported_usersInput>
  }

  export type usersUpsertWithoutReported_usersInput = {
    update: XOR<usersUpdateWithoutReported_usersInput, usersUncheckedUpdateWithoutReported_usersInput>
    create: XOR<usersCreateWithoutReported_usersInput, usersUncheckedCreateWithoutReported_usersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutReported_usersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutReported_usersInput, usersUncheckedUpdateWithoutReported_usersInput>
  }

  export type usersUpdateWithoutReported_usersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUpdateOneWithoutUsersNestedInput
    posts?: postsUpdateManyWithoutUsersNestedInput
    comments?: commentsUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutReported_usersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    age?: IntFieldUpdateOperationsInput | number
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    image?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumuserTypeFieldUpdateOperationsInput | $Enums.userType
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    incumbent_additional?: incumbentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    student_additional?: studentsAdditionalUncheckedUpdateOneWithoutUsersNestedInput
    posts?: postsUncheckedUpdateManyWithoutUsersNestedInput
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_posts?: recommendPostsUncheckedUpdateManyWithoutUsersNestedInput
    recommend_comments?: recommendCommentsUncheckedUpdateManyWithoutUsersNestedInput
    reported_posts?: reportedPostsUncheckedUpdateManyWithoutUsersNestedInput
    reported_comments?: reportedCommentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type bigJobKindCreateWithoutCompanyInput = {
    name: string
    midJobKind?: midJobKindCreateNestedManyWithoutBigJobKindInput
  }

  export type bigJobKindUncheckedCreateWithoutCompanyInput = {
    id?: number
    name: string
    midJobKind?: midJobKindUncheckedCreateNestedManyWithoutBigJobKindInput
  }

  export type bigJobKindCreateOrConnectWithoutCompanyInput = {
    where: bigJobKindWhereUniqueInput
    create: XOR<bigJobKindCreateWithoutCompanyInput, bigJobKindUncheckedCreateWithoutCompanyInput>
  }

  export type midJobKindCreateWithoutCompanyInput = {
    name: string
    bigJobKind: bigJobKindCreateNestedOneWithoutMidJobKindInput
    smallJobKind?: smallJobKindCreateNestedManyWithoutMidJobKindInput
  }

  export type midJobKindUncheckedCreateWithoutCompanyInput = {
    id?: number
    bigJobKindId: number
    name: string
    smallJobKind?: smallJobKindUncheckedCreateNestedManyWithoutMidJobKindInput
  }

  export type midJobKindCreateOrConnectWithoutCompanyInput = {
    where: midJobKindWhereUniqueInput
    create: XOR<midJobKindCreateWithoutCompanyInput, midJobKindUncheckedCreateWithoutCompanyInput>
  }

  export type smallJobKindCreateWithoutCompanyInput = {
    name: string
    midJobKind: midJobKindCreateNestedOneWithoutSmallJobKindInput
  }

  export type smallJobKindUncheckedCreateWithoutCompanyInput = {
    id?: number
    midJobKindId: number
    name: string
  }

  export type smallJobKindCreateOrConnectWithoutCompanyInput = {
    where: smallJobKindWhereUniqueInput
    create: XOR<smallJobKindCreateWithoutCompanyInput, smallJobKindUncheckedCreateWithoutCompanyInput>
  }

  export type incumbentsAdditionalCreateWithoutCompanyInput = {
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
    users: usersCreateNestedOneWithoutIncumbent_additionalInput
    school?: schoolCreateNestedOneWithoutIncumebentInput
    major?: majorCreateNestedOneWithoutIncumebentInput
    job?: jobCreateNestedOneWithoutIncumebentInput
  }

  export type incumbentsAdditionalUncheckedCreateWithoutCompanyInput = {
    id?: number
    userId: number
    schoolId?: number | null
    majorId?: number | null
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    jobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type incumbentsAdditionalCreateOrConnectWithoutCompanyInput = {
    where: incumbentsAdditionalWhereUniqueInput
    create: XOR<incumbentsAdditionalCreateWithoutCompanyInput, incumbentsAdditionalUncheckedCreateWithoutCompanyInput>
  }

  export type incumbentsAdditionalCreateManyCompanyInputEnvelope = {
    data: incumbentsAdditionalCreateManyCompanyInput | incumbentsAdditionalCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type studentsAdditionalCreateWithoutWishCompanyInput = {
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
    users: usersCreateNestedOneWithoutStudent_additionalInput
    school?: schoolCreateNestedOneWithoutStudentInput
    major?: majorCreateNestedOneWithoutStudentInput
    wishJob?: jobCreateNestedOneWithoutStudentInput
  }

  export type studentsAdditionalUncheckedCreateWithoutWishCompanyInput = {
    id?: number
    userId: number
    schoolId?: number | null
    majorId?: number | null
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    wishJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type studentsAdditionalCreateOrConnectWithoutWishCompanyInput = {
    where: studentsAdditionalWhereUniqueInput
    create: XOR<studentsAdditionalCreateWithoutWishCompanyInput, studentsAdditionalUncheckedCreateWithoutWishCompanyInput>
  }

  export type studentsAdditionalCreateManyWishCompanyInputEnvelope = {
    data: studentsAdditionalCreateManyWishCompanyInput | studentsAdditionalCreateManyWishCompanyInput[]
    skipDuplicates?: boolean
  }

  export type bigJobKindUpsertWithoutCompanyInput = {
    update: XOR<bigJobKindUpdateWithoutCompanyInput, bigJobKindUncheckedUpdateWithoutCompanyInput>
    create: XOR<bigJobKindCreateWithoutCompanyInput, bigJobKindUncheckedCreateWithoutCompanyInput>
    where?: bigJobKindWhereInput
  }

  export type bigJobKindUpdateToOneWithWhereWithoutCompanyInput = {
    where?: bigJobKindWhereInput
    data: XOR<bigJobKindUpdateWithoutCompanyInput, bigJobKindUncheckedUpdateWithoutCompanyInput>
  }

  export type bigJobKindUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    midJobKind?: midJobKindUpdateManyWithoutBigJobKindNestedInput
  }

  export type bigJobKindUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    midJobKind?: midJobKindUncheckedUpdateManyWithoutBigJobKindNestedInput
  }

  export type midJobKindUpsertWithoutCompanyInput = {
    update: XOR<midJobKindUpdateWithoutCompanyInput, midJobKindUncheckedUpdateWithoutCompanyInput>
    create: XOR<midJobKindCreateWithoutCompanyInput, midJobKindUncheckedCreateWithoutCompanyInput>
    where?: midJobKindWhereInput
  }

  export type midJobKindUpdateToOneWithWhereWithoutCompanyInput = {
    where?: midJobKindWhereInput
    data: XOR<midJobKindUpdateWithoutCompanyInput, midJobKindUncheckedUpdateWithoutCompanyInput>
  }

  export type midJobKindUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    bigJobKind?: bigJobKindUpdateOneRequiredWithoutMidJobKindNestedInput
    smallJobKind?: smallJobKindUpdateManyWithoutMidJobKindNestedInput
  }

  export type midJobKindUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bigJobKindId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    smallJobKind?: smallJobKindUncheckedUpdateManyWithoutMidJobKindNestedInput
  }

  export type smallJobKindUpsertWithoutCompanyInput = {
    update: XOR<smallJobKindUpdateWithoutCompanyInput, smallJobKindUncheckedUpdateWithoutCompanyInput>
    create: XOR<smallJobKindCreateWithoutCompanyInput, smallJobKindUncheckedCreateWithoutCompanyInput>
    where?: smallJobKindWhereInput
  }

  export type smallJobKindUpdateToOneWithWhereWithoutCompanyInput = {
    where?: smallJobKindWhereInput
    data: XOR<smallJobKindUpdateWithoutCompanyInput, smallJobKindUncheckedUpdateWithoutCompanyInput>
  }

  export type smallJobKindUpdateWithoutCompanyInput = {
    name?: StringFieldUpdateOperationsInput | string
    midJobKind?: midJobKindUpdateOneRequiredWithoutSmallJobKindNestedInput
  }

  export type smallJobKindUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    midJobKindId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type incumbentsAdditionalUpsertWithWhereUniqueWithoutCompanyInput = {
    where: incumbentsAdditionalWhereUniqueInput
    update: XOR<incumbentsAdditionalUpdateWithoutCompanyInput, incumbentsAdditionalUncheckedUpdateWithoutCompanyInput>
    create: XOR<incumbentsAdditionalCreateWithoutCompanyInput, incumbentsAdditionalUncheckedCreateWithoutCompanyInput>
  }

  export type incumbentsAdditionalUpdateWithWhereUniqueWithoutCompanyInput = {
    where: incumbentsAdditionalWhereUniqueInput
    data: XOR<incumbentsAdditionalUpdateWithoutCompanyInput, incumbentsAdditionalUncheckedUpdateWithoutCompanyInput>
  }

  export type incumbentsAdditionalUpdateManyWithWhereWithoutCompanyInput = {
    where: incumbentsAdditionalScalarWhereInput
    data: XOR<incumbentsAdditionalUpdateManyMutationInput, incumbentsAdditionalUncheckedUpdateManyWithoutCompanyInput>
  }

  export type incumbentsAdditionalScalarWhereInput = {
    AND?: incumbentsAdditionalScalarWhereInput | incumbentsAdditionalScalarWhereInput[]
    OR?: incumbentsAdditionalScalarWhereInput[]
    NOT?: incumbentsAdditionalScalarWhereInput | incumbentsAdditionalScalarWhereInput[]
    id?: IntFilter<"incumbentsAdditional"> | number
    userId?: IntFilter<"incumbentsAdditional"> | number
    companyId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    schoolId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    majorId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    bigJobId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    midJobId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    smallJobId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    jobId?: IntNullableFilter<"incumbentsAdditional"> | number | null
    shortSpec?: StringNullableFilter<"incumbentsAdditional"> | string | null
    reportedNum?: IntFilter<"incumbentsAdditional"> | number
    adviceCount?: IntFilter<"incumbentsAdditional"> | number
    estimationCount?: FloatFilter<"incumbentsAdditional"> | number
    updatedDate?: DateTimeFilter<"incumbentsAdditional"> | Date | string
  }

  export type studentsAdditionalUpsertWithWhereUniqueWithoutWishCompanyInput = {
    where: studentsAdditionalWhereUniqueInput
    update: XOR<studentsAdditionalUpdateWithoutWishCompanyInput, studentsAdditionalUncheckedUpdateWithoutWishCompanyInput>
    create: XOR<studentsAdditionalCreateWithoutWishCompanyInput, studentsAdditionalUncheckedCreateWithoutWishCompanyInput>
  }

  export type studentsAdditionalUpdateWithWhereUniqueWithoutWishCompanyInput = {
    where: studentsAdditionalWhereUniqueInput
    data: XOR<studentsAdditionalUpdateWithoutWishCompanyInput, studentsAdditionalUncheckedUpdateWithoutWishCompanyInput>
  }

  export type studentsAdditionalUpdateManyWithWhereWithoutWishCompanyInput = {
    where: studentsAdditionalScalarWhereInput
    data: XOR<studentsAdditionalUpdateManyMutationInput, studentsAdditionalUncheckedUpdateManyWithoutWishCompanyInput>
  }

  export type studentsAdditionalScalarWhereInput = {
    AND?: studentsAdditionalScalarWhereInput | studentsAdditionalScalarWhereInput[]
    OR?: studentsAdditionalScalarWhereInput[]
    NOT?: studentsAdditionalScalarWhereInput | studentsAdditionalScalarWhereInput[]
    id?: IntFilter<"studentsAdditional"> | number
    userId?: IntFilter<"studentsAdditional"> | number
    wishCompanyId?: IntNullableFilter<"studentsAdditional"> | number | null
    schoolId?: IntNullableFilter<"studentsAdditional"> | number | null
    majorId?: IntNullableFilter<"studentsAdditional"> | number | null
    wishBigJobId?: IntNullableFilter<"studentsAdditional"> | number | null
    wishMidJobId?: IntNullableFilter<"studentsAdditional"> | number | null
    wishSmallJobId?: IntNullableFilter<"studentsAdditional"> | number | null
    wishJobId?: IntNullableFilter<"studentsAdditional"> | number | null
    portfolio?: StringNullableFilter<"studentsAdditional"> | string | null
    reportedNum?: IntFilter<"studentsAdditional"> | number
    totalGrade?: FloatNullableFilter<"studentsAdditional"> | number | null
    adviceCount?: IntFilter<"studentsAdditional"> | number
    estimationCount?: FloatFilter<"studentsAdditional"> | number
    updatedDate?: DateTimeFilter<"studentsAdditional"> | Date | string
  }

  export type majorCreateWithoutSchoolInput = {
    name: string
    dayAndNight: string
    incumebent?: incumbentsAdditionalCreateNestedManyWithoutMajorInput
    student?: studentsAdditionalCreateNestedManyWithoutMajorInput
  }

  export type majorUncheckedCreateWithoutSchoolInput = {
    id?: number
    name: string
    dayAndNight: string
    incumebent?: incumbentsAdditionalUncheckedCreateNestedManyWithoutMajorInput
    student?: studentsAdditionalUncheckedCreateNestedManyWithoutMajorInput
  }

  export type majorCreateOrConnectWithoutSchoolInput = {
    where: majorWhereUniqueInput
    create: XOR<majorCreateWithoutSchoolInput, majorUncheckedCreateWithoutSchoolInput>
  }

  export type majorCreateManySchoolInputEnvelope = {
    data: majorCreateManySchoolInput | majorCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type incumbentsAdditionalCreateWithoutSchoolInput = {
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
    users: usersCreateNestedOneWithoutIncumbent_additionalInput
    company?: companyCreateNestedOneWithoutIncumebentInput
    major?: majorCreateNestedOneWithoutIncumebentInput
    job?: jobCreateNestedOneWithoutIncumebentInput
  }

  export type incumbentsAdditionalUncheckedCreateWithoutSchoolInput = {
    id?: number
    userId: number
    companyId?: number | null
    majorId?: number | null
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    jobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type incumbentsAdditionalCreateOrConnectWithoutSchoolInput = {
    where: incumbentsAdditionalWhereUniqueInput
    create: XOR<incumbentsAdditionalCreateWithoutSchoolInput, incumbentsAdditionalUncheckedCreateWithoutSchoolInput>
  }

  export type incumbentsAdditionalCreateManySchoolInputEnvelope = {
    data: incumbentsAdditionalCreateManySchoolInput | incumbentsAdditionalCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type studentsAdditionalCreateWithoutSchoolInput = {
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
    users: usersCreateNestedOneWithoutStudent_additionalInput
    wishCompany?: companyCreateNestedOneWithoutStudentInput
    major?: majorCreateNestedOneWithoutStudentInput
    wishJob?: jobCreateNestedOneWithoutStudentInput
  }

  export type studentsAdditionalUncheckedCreateWithoutSchoolInput = {
    id?: number
    userId: number
    wishCompanyId?: number | null
    majorId?: number | null
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    wishJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type studentsAdditionalCreateOrConnectWithoutSchoolInput = {
    where: studentsAdditionalWhereUniqueInput
    create: XOR<studentsAdditionalCreateWithoutSchoolInput, studentsAdditionalUncheckedCreateWithoutSchoolInput>
  }

  export type studentsAdditionalCreateManySchoolInputEnvelope = {
    data: studentsAdditionalCreateManySchoolInput | studentsAdditionalCreateManySchoolInput[]
    skipDuplicates?: boolean
  }

  export type majorUpsertWithWhereUniqueWithoutSchoolInput = {
    where: majorWhereUniqueInput
    update: XOR<majorUpdateWithoutSchoolInput, majorUncheckedUpdateWithoutSchoolInput>
    create: XOR<majorCreateWithoutSchoolInput, majorUncheckedCreateWithoutSchoolInput>
  }

  export type majorUpdateWithWhereUniqueWithoutSchoolInput = {
    where: majorWhereUniqueInput
    data: XOR<majorUpdateWithoutSchoolInput, majorUncheckedUpdateWithoutSchoolInput>
  }

  export type majorUpdateManyWithWhereWithoutSchoolInput = {
    where: majorScalarWhereInput
    data: XOR<majorUpdateManyMutationInput, majorUncheckedUpdateManyWithoutSchoolInput>
  }

  export type majorScalarWhereInput = {
    AND?: majorScalarWhereInput | majorScalarWhereInput[]
    OR?: majorScalarWhereInput[]
    NOT?: majorScalarWhereInput | majorScalarWhereInput[]
    id?: IntFilter<"major"> | number
    schoolId?: IntFilter<"major"> | number
    name?: StringFilter<"major"> | string
    dayAndNight?: StringFilter<"major"> | string
  }

  export type incumbentsAdditionalUpsertWithWhereUniqueWithoutSchoolInput = {
    where: incumbentsAdditionalWhereUniqueInput
    update: XOR<incumbentsAdditionalUpdateWithoutSchoolInput, incumbentsAdditionalUncheckedUpdateWithoutSchoolInput>
    create: XOR<incumbentsAdditionalCreateWithoutSchoolInput, incumbentsAdditionalUncheckedCreateWithoutSchoolInput>
  }

  export type incumbentsAdditionalUpdateWithWhereUniqueWithoutSchoolInput = {
    where: incumbentsAdditionalWhereUniqueInput
    data: XOR<incumbentsAdditionalUpdateWithoutSchoolInput, incumbentsAdditionalUncheckedUpdateWithoutSchoolInput>
  }

  export type incumbentsAdditionalUpdateManyWithWhereWithoutSchoolInput = {
    where: incumbentsAdditionalScalarWhereInput
    data: XOR<incumbentsAdditionalUpdateManyMutationInput, incumbentsAdditionalUncheckedUpdateManyWithoutSchoolInput>
  }

  export type studentsAdditionalUpsertWithWhereUniqueWithoutSchoolInput = {
    where: studentsAdditionalWhereUniqueInput
    update: XOR<studentsAdditionalUpdateWithoutSchoolInput, studentsAdditionalUncheckedUpdateWithoutSchoolInput>
    create: XOR<studentsAdditionalCreateWithoutSchoolInput, studentsAdditionalUncheckedCreateWithoutSchoolInput>
  }

  export type studentsAdditionalUpdateWithWhereUniqueWithoutSchoolInput = {
    where: studentsAdditionalWhereUniqueInput
    data: XOR<studentsAdditionalUpdateWithoutSchoolInput, studentsAdditionalUncheckedUpdateWithoutSchoolInput>
  }

  export type studentsAdditionalUpdateManyWithWhereWithoutSchoolInput = {
    where: studentsAdditionalScalarWhereInput
    data: XOR<studentsAdditionalUpdateManyMutationInput, studentsAdditionalUncheckedUpdateManyWithoutSchoolInput>
  }

  export type schoolCreateWithoutMajorInput = {
    name: string
    branch: string
    incumebent?: incumbentsAdditionalCreateNestedManyWithoutSchoolInput
    student?: studentsAdditionalCreateNestedManyWithoutSchoolInput
  }

  export type schoolUncheckedCreateWithoutMajorInput = {
    id?: number
    name: string
    branch: string
    incumebent?: incumbentsAdditionalUncheckedCreateNestedManyWithoutSchoolInput
    student?: studentsAdditionalUncheckedCreateNestedManyWithoutSchoolInput
  }

  export type schoolCreateOrConnectWithoutMajorInput = {
    where: schoolWhereUniqueInput
    create: XOR<schoolCreateWithoutMajorInput, schoolUncheckedCreateWithoutMajorInput>
  }

  export type incumbentsAdditionalCreateWithoutMajorInput = {
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
    users: usersCreateNestedOneWithoutIncumbent_additionalInput
    company?: companyCreateNestedOneWithoutIncumebentInput
    school?: schoolCreateNestedOneWithoutIncumebentInput
    job?: jobCreateNestedOneWithoutIncumebentInput
  }

  export type incumbentsAdditionalUncheckedCreateWithoutMajorInput = {
    id?: number
    userId: number
    companyId?: number | null
    schoolId?: number | null
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    jobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type incumbentsAdditionalCreateOrConnectWithoutMajorInput = {
    where: incumbentsAdditionalWhereUniqueInput
    create: XOR<incumbentsAdditionalCreateWithoutMajorInput, incumbentsAdditionalUncheckedCreateWithoutMajorInput>
  }

  export type incumbentsAdditionalCreateManyMajorInputEnvelope = {
    data: incumbentsAdditionalCreateManyMajorInput | incumbentsAdditionalCreateManyMajorInput[]
    skipDuplicates?: boolean
  }

  export type studentsAdditionalCreateWithoutMajorInput = {
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
    users: usersCreateNestedOneWithoutStudent_additionalInput
    wishCompany?: companyCreateNestedOneWithoutStudentInput
    school?: schoolCreateNestedOneWithoutStudentInput
    wishJob?: jobCreateNestedOneWithoutStudentInput
  }

  export type studentsAdditionalUncheckedCreateWithoutMajorInput = {
    id?: number
    userId: number
    wishCompanyId?: number | null
    schoolId?: number | null
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    wishJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type studentsAdditionalCreateOrConnectWithoutMajorInput = {
    where: studentsAdditionalWhereUniqueInput
    create: XOR<studentsAdditionalCreateWithoutMajorInput, studentsAdditionalUncheckedCreateWithoutMajorInput>
  }

  export type studentsAdditionalCreateManyMajorInputEnvelope = {
    data: studentsAdditionalCreateManyMajorInput | studentsAdditionalCreateManyMajorInput[]
    skipDuplicates?: boolean
  }

  export type schoolUpsertWithoutMajorInput = {
    update: XOR<schoolUpdateWithoutMajorInput, schoolUncheckedUpdateWithoutMajorInput>
    create: XOR<schoolCreateWithoutMajorInput, schoolUncheckedCreateWithoutMajorInput>
    where?: schoolWhereInput
  }

  export type schoolUpdateToOneWithWhereWithoutMajorInput = {
    where?: schoolWhereInput
    data: XOR<schoolUpdateWithoutMajorInput, schoolUncheckedUpdateWithoutMajorInput>
  }

  export type schoolUpdateWithoutMajorInput = {
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    incumebent?: incumbentsAdditionalUpdateManyWithoutSchoolNestedInput
    student?: studentsAdditionalUpdateManyWithoutSchoolNestedInput
  }

  export type schoolUncheckedUpdateWithoutMajorInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    incumebent?: incumbentsAdditionalUncheckedUpdateManyWithoutSchoolNestedInput
    student?: studentsAdditionalUncheckedUpdateManyWithoutSchoolNestedInput
  }

  export type incumbentsAdditionalUpsertWithWhereUniqueWithoutMajorInput = {
    where: incumbentsAdditionalWhereUniqueInput
    update: XOR<incumbentsAdditionalUpdateWithoutMajorInput, incumbentsAdditionalUncheckedUpdateWithoutMajorInput>
    create: XOR<incumbentsAdditionalCreateWithoutMajorInput, incumbentsAdditionalUncheckedCreateWithoutMajorInput>
  }

  export type incumbentsAdditionalUpdateWithWhereUniqueWithoutMajorInput = {
    where: incumbentsAdditionalWhereUniqueInput
    data: XOR<incumbentsAdditionalUpdateWithoutMajorInput, incumbentsAdditionalUncheckedUpdateWithoutMajorInput>
  }

  export type incumbentsAdditionalUpdateManyWithWhereWithoutMajorInput = {
    where: incumbentsAdditionalScalarWhereInput
    data: XOR<incumbentsAdditionalUpdateManyMutationInput, incumbentsAdditionalUncheckedUpdateManyWithoutMajorInput>
  }

  export type studentsAdditionalUpsertWithWhereUniqueWithoutMajorInput = {
    where: studentsAdditionalWhereUniqueInput
    update: XOR<studentsAdditionalUpdateWithoutMajorInput, studentsAdditionalUncheckedUpdateWithoutMajorInput>
    create: XOR<studentsAdditionalCreateWithoutMajorInput, studentsAdditionalUncheckedCreateWithoutMajorInput>
  }

  export type studentsAdditionalUpdateWithWhereUniqueWithoutMajorInput = {
    where: studentsAdditionalWhereUniqueInput
    data: XOR<studentsAdditionalUpdateWithoutMajorInput, studentsAdditionalUncheckedUpdateWithoutMajorInput>
  }

  export type studentsAdditionalUpdateManyWithWhereWithoutMajorInput = {
    where: studentsAdditionalScalarWhereInput
    data: XOR<studentsAdditionalUpdateManyMutationInput, studentsAdditionalUncheckedUpdateManyWithoutMajorInput>
  }

  export type companyCreateWithoutBigJobKindInput = {
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    midJobKind: midJobKindCreateNestedOneWithoutCompanyInput
    smallJobKind: smallJobKindCreateNestedOneWithoutCompanyInput
    incumebent?: incumbentsAdditionalCreateNestedManyWithoutCompanyInput
    student?: studentsAdditionalCreateNestedManyWithoutWishCompanyInput
  }

  export type companyUncheckedCreateWithoutBigJobKindInput = {
    id?: number
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    midJobKindId: number
    smallJobKindId: number
    incumebent?: incumbentsAdditionalUncheckedCreateNestedManyWithoutCompanyInput
    student?: studentsAdditionalUncheckedCreateNestedManyWithoutWishCompanyInput
  }

  export type companyCreateOrConnectWithoutBigJobKindInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutBigJobKindInput, companyUncheckedCreateWithoutBigJobKindInput>
  }

  export type companyCreateManyBigJobKindInputEnvelope = {
    data: companyCreateManyBigJobKindInput | companyCreateManyBigJobKindInput[]
    skipDuplicates?: boolean
  }

  export type midJobKindCreateWithoutBigJobKindInput = {
    name: string
    company?: companyCreateNestedManyWithoutMidJobKindInput
    smallJobKind?: smallJobKindCreateNestedManyWithoutMidJobKindInput
  }

  export type midJobKindUncheckedCreateWithoutBigJobKindInput = {
    id?: number
    name: string
    company?: companyUncheckedCreateNestedManyWithoutMidJobKindInput
    smallJobKind?: smallJobKindUncheckedCreateNestedManyWithoutMidJobKindInput
  }

  export type midJobKindCreateOrConnectWithoutBigJobKindInput = {
    where: midJobKindWhereUniqueInput
    create: XOR<midJobKindCreateWithoutBigJobKindInput, midJobKindUncheckedCreateWithoutBigJobKindInput>
  }

  export type midJobKindCreateManyBigJobKindInputEnvelope = {
    data: midJobKindCreateManyBigJobKindInput | midJobKindCreateManyBigJobKindInput[]
    skipDuplicates?: boolean
  }

  export type companyUpsertWithWhereUniqueWithoutBigJobKindInput = {
    where: companyWhereUniqueInput
    update: XOR<companyUpdateWithoutBigJobKindInput, companyUncheckedUpdateWithoutBigJobKindInput>
    create: XOR<companyCreateWithoutBigJobKindInput, companyUncheckedCreateWithoutBigJobKindInput>
  }

  export type companyUpdateWithWhereUniqueWithoutBigJobKindInput = {
    where: companyWhereUniqueInput
    data: XOR<companyUpdateWithoutBigJobKindInput, companyUncheckedUpdateWithoutBigJobKindInput>
  }

  export type companyUpdateManyWithWhereWithoutBigJobKindInput = {
    where: companyScalarWhereInput
    data: XOR<companyUpdateManyMutationInput, companyUncheckedUpdateManyWithoutBigJobKindInput>
  }

  export type companyScalarWhereInput = {
    AND?: companyScalarWhereInput | companyScalarWhereInput[]
    OR?: companyScalarWhereInput[]
    NOT?: companyScalarWhereInput | companyScalarWhereInput[]
    id?: IntFilter<"company"> | number
    name?: StringFilter<"company"> | string
    address?: StringFilter<"company"> | string
    longitude?: FloatFilter<"company"> | number
    latitude?: FloatFilter<"company"> | number
    scale?: StringFilter<"company"> | string
    bigJobKindId?: IntFilter<"company"> | number
    midJobKindId?: IntFilter<"company"> | number
    smallJobKindId?: IntFilter<"company"> | number
  }

  export type midJobKindUpsertWithWhereUniqueWithoutBigJobKindInput = {
    where: midJobKindWhereUniqueInput
    update: XOR<midJobKindUpdateWithoutBigJobKindInput, midJobKindUncheckedUpdateWithoutBigJobKindInput>
    create: XOR<midJobKindCreateWithoutBigJobKindInput, midJobKindUncheckedCreateWithoutBigJobKindInput>
  }

  export type midJobKindUpdateWithWhereUniqueWithoutBigJobKindInput = {
    where: midJobKindWhereUniqueInput
    data: XOR<midJobKindUpdateWithoutBigJobKindInput, midJobKindUncheckedUpdateWithoutBigJobKindInput>
  }

  export type midJobKindUpdateManyWithWhereWithoutBigJobKindInput = {
    where: midJobKindScalarWhereInput
    data: XOR<midJobKindUpdateManyMutationInput, midJobKindUncheckedUpdateManyWithoutBigJobKindInput>
  }

  export type midJobKindScalarWhereInput = {
    AND?: midJobKindScalarWhereInput | midJobKindScalarWhereInput[]
    OR?: midJobKindScalarWhereInput[]
    NOT?: midJobKindScalarWhereInput | midJobKindScalarWhereInput[]
    id?: IntFilter<"midJobKind"> | number
    bigJobKindId?: IntFilter<"midJobKind"> | number
    name?: StringFilter<"midJobKind"> | string
  }

  export type companyCreateWithoutMidJobKindInput = {
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    bigJobKind: bigJobKindCreateNestedOneWithoutCompanyInput
    smallJobKind: smallJobKindCreateNestedOneWithoutCompanyInput
    incumebent?: incumbentsAdditionalCreateNestedManyWithoutCompanyInput
    student?: studentsAdditionalCreateNestedManyWithoutWishCompanyInput
  }

  export type companyUncheckedCreateWithoutMidJobKindInput = {
    id?: number
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    bigJobKindId: number
    smallJobKindId: number
    incumebent?: incumbentsAdditionalUncheckedCreateNestedManyWithoutCompanyInput
    student?: studentsAdditionalUncheckedCreateNestedManyWithoutWishCompanyInput
  }

  export type companyCreateOrConnectWithoutMidJobKindInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutMidJobKindInput, companyUncheckedCreateWithoutMidJobKindInput>
  }

  export type companyCreateManyMidJobKindInputEnvelope = {
    data: companyCreateManyMidJobKindInput | companyCreateManyMidJobKindInput[]
    skipDuplicates?: boolean
  }

  export type bigJobKindCreateWithoutMidJobKindInput = {
    name: string
    company?: companyCreateNestedManyWithoutBigJobKindInput
  }

  export type bigJobKindUncheckedCreateWithoutMidJobKindInput = {
    id?: number
    name: string
    company?: companyUncheckedCreateNestedManyWithoutBigJobKindInput
  }

  export type bigJobKindCreateOrConnectWithoutMidJobKindInput = {
    where: bigJobKindWhereUniqueInput
    create: XOR<bigJobKindCreateWithoutMidJobKindInput, bigJobKindUncheckedCreateWithoutMidJobKindInput>
  }

  export type smallJobKindCreateWithoutMidJobKindInput = {
    name: string
    company?: companyCreateNestedManyWithoutSmallJobKindInput
  }

  export type smallJobKindUncheckedCreateWithoutMidJobKindInput = {
    id?: number
    name: string
    company?: companyUncheckedCreateNestedManyWithoutSmallJobKindInput
  }

  export type smallJobKindCreateOrConnectWithoutMidJobKindInput = {
    where: smallJobKindWhereUniqueInput
    create: XOR<smallJobKindCreateWithoutMidJobKindInput, smallJobKindUncheckedCreateWithoutMidJobKindInput>
  }

  export type smallJobKindCreateManyMidJobKindInputEnvelope = {
    data: smallJobKindCreateManyMidJobKindInput | smallJobKindCreateManyMidJobKindInput[]
    skipDuplicates?: boolean
  }

  export type companyUpsertWithWhereUniqueWithoutMidJobKindInput = {
    where: companyWhereUniqueInput
    update: XOR<companyUpdateWithoutMidJobKindInput, companyUncheckedUpdateWithoutMidJobKindInput>
    create: XOR<companyCreateWithoutMidJobKindInput, companyUncheckedCreateWithoutMidJobKindInput>
  }

  export type companyUpdateWithWhereUniqueWithoutMidJobKindInput = {
    where: companyWhereUniqueInput
    data: XOR<companyUpdateWithoutMidJobKindInput, companyUncheckedUpdateWithoutMidJobKindInput>
  }

  export type companyUpdateManyWithWhereWithoutMidJobKindInput = {
    where: companyScalarWhereInput
    data: XOR<companyUpdateManyMutationInput, companyUncheckedUpdateManyWithoutMidJobKindInput>
  }

  export type bigJobKindUpsertWithoutMidJobKindInput = {
    update: XOR<bigJobKindUpdateWithoutMidJobKindInput, bigJobKindUncheckedUpdateWithoutMidJobKindInput>
    create: XOR<bigJobKindCreateWithoutMidJobKindInput, bigJobKindUncheckedCreateWithoutMidJobKindInput>
    where?: bigJobKindWhereInput
  }

  export type bigJobKindUpdateToOneWithWhereWithoutMidJobKindInput = {
    where?: bigJobKindWhereInput
    data: XOR<bigJobKindUpdateWithoutMidJobKindInput, bigJobKindUncheckedUpdateWithoutMidJobKindInput>
  }

  export type bigJobKindUpdateWithoutMidJobKindInput = {
    name?: StringFieldUpdateOperationsInput | string
    company?: companyUpdateManyWithoutBigJobKindNestedInput
  }

  export type bigJobKindUncheckedUpdateWithoutMidJobKindInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    company?: companyUncheckedUpdateManyWithoutBigJobKindNestedInput
  }

  export type smallJobKindUpsertWithWhereUniqueWithoutMidJobKindInput = {
    where: smallJobKindWhereUniqueInput
    update: XOR<smallJobKindUpdateWithoutMidJobKindInput, smallJobKindUncheckedUpdateWithoutMidJobKindInput>
    create: XOR<smallJobKindCreateWithoutMidJobKindInput, smallJobKindUncheckedCreateWithoutMidJobKindInput>
  }

  export type smallJobKindUpdateWithWhereUniqueWithoutMidJobKindInput = {
    where: smallJobKindWhereUniqueInput
    data: XOR<smallJobKindUpdateWithoutMidJobKindInput, smallJobKindUncheckedUpdateWithoutMidJobKindInput>
  }

  export type smallJobKindUpdateManyWithWhereWithoutMidJobKindInput = {
    where: smallJobKindScalarWhereInput
    data: XOR<smallJobKindUpdateManyMutationInput, smallJobKindUncheckedUpdateManyWithoutMidJobKindInput>
  }

  export type smallJobKindScalarWhereInput = {
    AND?: smallJobKindScalarWhereInput | smallJobKindScalarWhereInput[]
    OR?: smallJobKindScalarWhereInput[]
    NOT?: smallJobKindScalarWhereInput | smallJobKindScalarWhereInput[]
    id?: IntFilter<"smallJobKind"> | number
    midJobKindId?: IntFilter<"smallJobKind"> | number
    name?: StringFilter<"smallJobKind"> | string
  }

  export type companyCreateWithoutSmallJobKindInput = {
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    bigJobKind: bigJobKindCreateNestedOneWithoutCompanyInput
    midJobKind: midJobKindCreateNestedOneWithoutCompanyInput
    incumebent?: incumbentsAdditionalCreateNestedManyWithoutCompanyInput
    student?: studentsAdditionalCreateNestedManyWithoutWishCompanyInput
  }

  export type companyUncheckedCreateWithoutSmallJobKindInput = {
    id?: number
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    bigJobKindId: number
    midJobKindId: number
    incumebent?: incumbentsAdditionalUncheckedCreateNestedManyWithoutCompanyInput
    student?: studentsAdditionalUncheckedCreateNestedManyWithoutWishCompanyInput
  }

  export type companyCreateOrConnectWithoutSmallJobKindInput = {
    where: companyWhereUniqueInput
    create: XOR<companyCreateWithoutSmallJobKindInput, companyUncheckedCreateWithoutSmallJobKindInput>
  }

  export type companyCreateManySmallJobKindInputEnvelope = {
    data: companyCreateManySmallJobKindInput | companyCreateManySmallJobKindInput[]
    skipDuplicates?: boolean
  }

  export type midJobKindCreateWithoutSmallJobKindInput = {
    name: string
    company?: companyCreateNestedManyWithoutMidJobKindInput
    bigJobKind: bigJobKindCreateNestedOneWithoutMidJobKindInput
  }

  export type midJobKindUncheckedCreateWithoutSmallJobKindInput = {
    id?: number
    bigJobKindId: number
    name: string
    company?: companyUncheckedCreateNestedManyWithoutMidJobKindInput
  }

  export type midJobKindCreateOrConnectWithoutSmallJobKindInput = {
    where: midJobKindWhereUniqueInput
    create: XOR<midJobKindCreateWithoutSmallJobKindInput, midJobKindUncheckedCreateWithoutSmallJobKindInput>
  }

  export type companyUpsertWithWhereUniqueWithoutSmallJobKindInput = {
    where: companyWhereUniqueInput
    update: XOR<companyUpdateWithoutSmallJobKindInput, companyUncheckedUpdateWithoutSmallJobKindInput>
    create: XOR<companyCreateWithoutSmallJobKindInput, companyUncheckedCreateWithoutSmallJobKindInput>
  }

  export type companyUpdateWithWhereUniqueWithoutSmallJobKindInput = {
    where: companyWhereUniqueInput
    data: XOR<companyUpdateWithoutSmallJobKindInput, companyUncheckedUpdateWithoutSmallJobKindInput>
  }

  export type companyUpdateManyWithWhereWithoutSmallJobKindInput = {
    where: companyScalarWhereInput
    data: XOR<companyUpdateManyMutationInput, companyUncheckedUpdateManyWithoutSmallJobKindInput>
  }

  export type midJobKindUpsertWithoutSmallJobKindInput = {
    update: XOR<midJobKindUpdateWithoutSmallJobKindInput, midJobKindUncheckedUpdateWithoutSmallJobKindInput>
    create: XOR<midJobKindCreateWithoutSmallJobKindInput, midJobKindUncheckedCreateWithoutSmallJobKindInput>
    where?: midJobKindWhereInput
  }

  export type midJobKindUpdateToOneWithWhereWithoutSmallJobKindInput = {
    where?: midJobKindWhereInput
    data: XOR<midJobKindUpdateWithoutSmallJobKindInput, midJobKindUncheckedUpdateWithoutSmallJobKindInput>
  }

  export type midJobKindUpdateWithoutSmallJobKindInput = {
    name?: StringFieldUpdateOperationsInput | string
    company?: companyUpdateManyWithoutMidJobKindNestedInput
    bigJobKind?: bigJobKindUpdateOneRequiredWithoutMidJobKindNestedInput
  }

  export type midJobKindUncheckedUpdateWithoutSmallJobKindInput = {
    id?: IntFieldUpdateOperationsInput | number
    bigJobKindId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    company?: companyUncheckedUpdateManyWithoutMidJobKindNestedInput
  }

  export type incumbentsAdditionalCreateWithoutJobInput = {
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
    users: usersCreateNestedOneWithoutIncumbent_additionalInput
    company?: companyCreateNestedOneWithoutIncumebentInput
    school?: schoolCreateNestedOneWithoutIncumebentInput
    major?: majorCreateNestedOneWithoutIncumebentInput
  }

  export type incumbentsAdditionalUncheckedCreateWithoutJobInput = {
    id?: number
    userId: number
    companyId?: number | null
    schoolId?: number | null
    majorId?: number | null
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type incumbentsAdditionalCreateOrConnectWithoutJobInput = {
    where: incumbentsAdditionalWhereUniqueInput
    create: XOR<incumbentsAdditionalCreateWithoutJobInput, incumbentsAdditionalUncheckedCreateWithoutJobInput>
  }

  export type incumbentsAdditionalCreateManyJobInputEnvelope = {
    data: incumbentsAdditionalCreateManyJobInput | incumbentsAdditionalCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type studentsAdditionalCreateWithoutWishJobInput = {
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
    users: usersCreateNestedOneWithoutStudent_additionalInput
    wishCompany?: companyCreateNestedOneWithoutStudentInput
    school?: schoolCreateNestedOneWithoutStudentInput
    major?: majorCreateNestedOneWithoutStudentInput
  }

  export type studentsAdditionalUncheckedCreateWithoutWishJobInput = {
    id?: number
    userId: number
    wishCompanyId?: number | null
    schoolId?: number | null
    majorId?: number | null
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type studentsAdditionalCreateOrConnectWithoutWishJobInput = {
    where: studentsAdditionalWhereUniqueInput
    create: XOR<studentsAdditionalCreateWithoutWishJobInput, studentsAdditionalUncheckedCreateWithoutWishJobInput>
  }

  export type studentsAdditionalCreateManyWishJobInputEnvelope = {
    data: studentsAdditionalCreateManyWishJobInput | studentsAdditionalCreateManyWishJobInput[]
    skipDuplicates?: boolean
  }

  export type incumbentsAdditionalUpsertWithWhereUniqueWithoutJobInput = {
    where: incumbentsAdditionalWhereUniqueInput
    update: XOR<incumbentsAdditionalUpdateWithoutJobInput, incumbentsAdditionalUncheckedUpdateWithoutJobInput>
    create: XOR<incumbentsAdditionalCreateWithoutJobInput, incumbentsAdditionalUncheckedCreateWithoutJobInput>
  }

  export type incumbentsAdditionalUpdateWithWhereUniqueWithoutJobInput = {
    where: incumbentsAdditionalWhereUniqueInput
    data: XOR<incumbentsAdditionalUpdateWithoutJobInput, incumbentsAdditionalUncheckedUpdateWithoutJobInput>
  }

  export type incumbentsAdditionalUpdateManyWithWhereWithoutJobInput = {
    where: incumbentsAdditionalScalarWhereInput
    data: XOR<incumbentsAdditionalUpdateManyMutationInput, incumbentsAdditionalUncheckedUpdateManyWithoutJobInput>
  }

  export type studentsAdditionalUpsertWithWhereUniqueWithoutWishJobInput = {
    where: studentsAdditionalWhereUniqueInput
    update: XOR<studentsAdditionalUpdateWithoutWishJobInput, studentsAdditionalUncheckedUpdateWithoutWishJobInput>
    create: XOR<studentsAdditionalCreateWithoutWishJobInput, studentsAdditionalUncheckedCreateWithoutWishJobInput>
  }

  export type studentsAdditionalUpdateWithWhereUniqueWithoutWishJobInput = {
    where: studentsAdditionalWhereUniqueInput
    data: XOR<studentsAdditionalUpdateWithoutWishJobInput, studentsAdditionalUncheckedUpdateWithoutWishJobInput>
  }

  export type studentsAdditionalUpdateManyWithWhereWithoutWishJobInput = {
    where: studentsAdditionalScalarWhereInput
    data: XOR<studentsAdditionalUpdateManyMutationInput, studentsAdditionalUncheckedUpdateManyWithoutWishJobInput>
  }

  export type postsCreateManyUsersInput = {
    id?: number
    categoryId?: number | null
    title: string
    content: string
    view?: number
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
  }

  export type commentsCreateManyUsersInput = {
    id?: number
    postId: number
    content: string
    parentCommentId?: number | null
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
  }

  export type recommendPostsCreateManyUsersInput = {
    id?: number
    postId: number
    createdDate?: Date | string
  }

  export type recommendCommentsCreateManyUsersInput = {
    id?: number
    commentId: number
    createdDate?: Date | string
  }

  export type reportedPostsCreateManyUsersInput = {
    id?: number
    postId: number
    reason: string
    createdDate?: Date | string
  }

  export type reportedCommentsCreateManyUsersInput = {
    id?: number
    commentId: number
    reason: string
    createdDate?: Date | string
  }

  export type reportedUsersCreateManyUsersInput = {
    id?: number
    reportingUserId: number
    reason: string
    createdDate?: Date | string
  }

  export type postsUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: categoryUpdateOneWithoutPostsNestedInput
    comments?: commentsUpdateManyWithoutPostNestedInput
    recommend_posts?: recommendPostsUpdateManyWithoutPostNestedInput
    reported_posts?: reportedPostsUpdateManyWithoutPostNestedInput
  }

  export type postsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: commentsUncheckedUpdateManyWithoutPostNestedInput
    recommend_posts?: recommendPostsUncheckedUpdateManyWithoutPostNestedInput
    reported_posts?: reportedPostsUncheckedUpdateManyWithoutPostNestedInput
  }

  export type postsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentsUpdateWithoutUsersInput = {
    content?: StringFieldUpdateOperationsInput | string
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    post?: postsUpdateOneRequiredWithoutCommentsNestedInput
    parent?: commentsUpdateOneWithoutRepliesNestedInput
    replies?: commentsUpdateManyWithoutParentNestedInput
    recommend_comments?: recommendCommentsUpdateManyWithoutCommentNestedInput
    reported_comments?: reportedCommentsUpdateManyWithoutCommentNestedInput
  }

  export type commentsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    replies?: commentsUncheckedUpdateManyWithoutParentNestedInput
    recommend_comments?: recommendCommentsUncheckedUpdateManyWithoutCommentNestedInput
    reported_comments?: reportedCommentsUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type commentsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type recommendPostsUpdateWithoutUsersInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: postsUpdateOneRequiredWithoutRecommend_postsNestedInput
  }

  export type recommendPostsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recommendPostsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recommendCommentsUpdateWithoutUsersInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: commentsUpdateOneRequiredWithoutRecommend_commentsNestedInput
  }

  export type recommendCommentsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recommendCommentsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedPostsUpdateWithoutUsersInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: postsUpdateOneRequiredWithoutReported_postsNestedInput
  }

  export type reportedPostsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedPostsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedCommentsUpdateWithoutUsersInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: commentsUpdateOneRequiredWithoutReported_commentsNestedInput
  }

  export type reportedCommentsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedCommentsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedUsersUpdateWithoutUsersInput = {
    reportingUserId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedUsersUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportingUserId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedUsersUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    reportingUserId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type postsCreateManyCategoriesInput = {
    id?: number
    userId?: number | null
    title: string
    content: string
    view?: number
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
  }

  export type postsUpdateWithoutCategoriesInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutPostsNestedInput
    comments?: commentsUpdateManyWithoutPostNestedInput
    recommend_posts?: recommendPostsUpdateManyWithoutPostNestedInput
    reported_posts?: reportedPostsUpdateManyWithoutPostNestedInput
  }

  export type postsUncheckedUpdateWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: commentsUncheckedUpdateManyWithoutPostNestedInput
    recommend_posts?: recommendPostsUncheckedUpdateManyWithoutPostNestedInput
    reported_posts?: reportedPostsUncheckedUpdateManyWithoutPostNestedInput
  }

  export type postsUncheckedUpdateManyWithoutCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    view?: IntFieldUpdateOperationsInput | number
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentsCreateManyPostInput = {
    id?: number
    userId?: number | null
    content: string
    parentCommentId?: number | null
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
  }

  export type recommendPostsCreateManyPostInput = {
    id?: number
    userId: number
    createdDate?: Date | string
  }

  export type reportedPostsCreateManyPostInput = {
    id?: number
    userId: number
    reason: string
    createdDate?: Date | string
  }

  export type commentsUpdateWithoutPostInput = {
    content?: StringFieldUpdateOperationsInput | string
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    users?: usersUpdateOneWithoutCommentsNestedInput
    parent?: commentsUpdateOneWithoutRepliesNestedInput
    replies?: commentsUpdateManyWithoutParentNestedInput
    recommend_comments?: recommendCommentsUpdateManyWithoutCommentNestedInput
    reported_comments?: reportedCommentsUpdateManyWithoutCommentNestedInput
  }

  export type commentsUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    replies?: commentsUncheckedUpdateManyWithoutParentNestedInput
    recommend_comments?: recommendCommentsUncheckedUpdateManyWithoutCommentNestedInput
    reported_comments?: reportedCommentsUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type commentsUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type recommendPostsUpdateWithoutPostInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutRecommend_postsNestedInput
  }

  export type recommendPostsUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recommendPostsUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedPostsUpdateWithoutPostInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutReported_postsNestedInput
  }

  export type reportedPostsUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedPostsUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentsCreateManyParentInput = {
    id?: number
    postId: number
    userId?: number | null
    content: string
    recommend?: number
    reported?: number
    createdDate?: Date | string
    updatedDate?: Date | string
    isDelete?: boolean
  }

  export type recommendCommentsCreateManyCommentInput = {
    id?: number
    userId: number
    createdDate?: Date | string
  }

  export type reportedCommentsCreateManyCommentInput = {
    id?: number
    userId: number
    reason: string
    createdDate?: Date | string
  }

  export type commentsUpdateWithoutParentInput = {
    content?: StringFieldUpdateOperationsInput | string
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    users?: usersUpdateOneWithoutCommentsNestedInput
    post?: postsUpdateOneRequiredWithoutCommentsNestedInput
    replies?: commentsUpdateManyWithoutParentNestedInput
    recommend_comments?: recommendCommentsUpdateManyWithoutCommentNestedInput
    reported_comments?: reportedCommentsUpdateManyWithoutCommentNestedInput
  }

  export type commentsUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
    replies?: commentsUncheckedUpdateManyWithoutParentNestedInput
    recommend_comments?: recommendCommentsUncheckedUpdateManyWithoutCommentNestedInput
    reported_comments?: reportedCommentsUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type commentsUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    recommend?: IntFieldUpdateOperationsInput | number
    reported?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isDelete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type recommendCommentsUpdateWithoutCommentInput = {
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutRecommend_commentsNestedInput
  }

  export type recommendCommentsUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recommendCommentsUncheckedUpdateManyWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedCommentsUpdateWithoutCommentInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutReported_commentsNestedInput
  }

  export type reportedCommentsUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportedCommentsUncheckedUpdateManyWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    createdDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type incumbentsAdditionalCreateManyCompanyInput = {
    id?: number
    userId: number
    schoolId?: number | null
    majorId?: number | null
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    jobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type studentsAdditionalCreateManyWishCompanyInput = {
    id?: number
    userId: number
    schoolId?: number | null
    majorId?: number | null
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    wishJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type incumbentsAdditionalUpdateWithoutCompanyInput = {
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutIncumbent_additionalNestedInput
    school?: schoolUpdateOneWithoutIncumebentNestedInput
    major?: majorUpdateOneWithoutIncumebentNestedInput
    job?: jobUpdateOneWithoutIncumebentNestedInput
  }

  export type incumbentsAdditionalUncheckedUpdateWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type incumbentsAdditionalUncheckedUpdateManyWithoutCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsAdditionalUpdateWithoutWishCompanyInput = {
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutStudent_additionalNestedInput
    school?: schoolUpdateOneWithoutStudentNestedInput
    major?: majorUpdateOneWithoutStudentNestedInput
    wishJob?: jobUpdateOneWithoutStudentNestedInput
  }

  export type studentsAdditionalUncheckedUpdateWithoutWishCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsAdditionalUncheckedUpdateManyWithoutWishCompanyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type majorCreateManySchoolInput = {
    id?: number
    name: string
    dayAndNight: string
  }

  export type incumbentsAdditionalCreateManySchoolInput = {
    id?: number
    userId: number
    companyId?: number | null
    majorId?: number | null
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    jobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type studentsAdditionalCreateManySchoolInput = {
    id?: number
    userId: number
    wishCompanyId?: number | null
    majorId?: number | null
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    wishJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type majorUpdateWithoutSchoolInput = {
    name?: StringFieldUpdateOperationsInput | string
    dayAndNight?: StringFieldUpdateOperationsInput | string
    incumebent?: incumbentsAdditionalUpdateManyWithoutMajorNestedInput
    student?: studentsAdditionalUpdateManyWithoutMajorNestedInput
  }

  export type majorUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dayAndNight?: StringFieldUpdateOperationsInput | string
    incumebent?: incumbentsAdditionalUncheckedUpdateManyWithoutMajorNestedInput
    student?: studentsAdditionalUncheckedUpdateManyWithoutMajorNestedInput
  }

  export type majorUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    dayAndNight?: StringFieldUpdateOperationsInput | string
  }

  export type incumbentsAdditionalUpdateWithoutSchoolInput = {
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutIncumbent_additionalNestedInput
    company?: companyUpdateOneWithoutIncumebentNestedInput
    major?: majorUpdateOneWithoutIncumebentNestedInput
    job?: jobUpdateOneWithoutIncumebentNestedInput
  }

  export type incumbentsAdditionalUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type incumbentsAdditionalUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsAdditionalUpdateWithoutSchoolInput = {
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutStudent_additionalNestedInput
    wishCompany?: companyUpdateOneWithoutStudentNestedInput
    major?: majorUpdateOneWithoutStudentNestedInput
    wishJob?: jobUpdateOneWithoutStudentNestedInput
  }

  export type studentsAdditionalUncheckedUpdateWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    wishCompanyId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsAdditionalUncheckedUpdateManyWithoutSchoolInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    wishCompanyId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type incumbentsAdditionalCreateManyMajorInput = {
    id?: number
    userId: number
    companyId?: number | null
    schoolId?: number | null
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    jobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type studentsAdditionalCreateManyMajorInput = {
    id?: number
    userId: number
    wishCompanyId?: number | null
    schoolId?: number | null
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    wishJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type incumbentsAdditionalUpdateWithoutMajorInput = {
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutIncumbent_additionalNestedInput
    company?: companyUpdateOneWithoutIncumebentNestedInput
    school?: schoolUpdateOneWithoutIncumebentNestedInput
    job?: jobUpdateOneWithoutIncumebentNestedInput
  }

  export type incumbentsAdditionalUncheckedUpdateWithoutMajorInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type incumbentsAdditionalUncheckedUpdateManyWithoutMajorInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    jobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsAdditionalUpdateWithoutMajorInput = {
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutStudent_additionalNestedInput
    wishCompany?: companyUpdateOneWithoutStudentNestedInput
    school?: schoolUpdateOneWithoutStudentNestedInput
    wishJob?: jobUpdateOneWithoutStudentNestedInput
  }

  export type studentsAdditionalUncheckedUpdateWithoutMajorInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    wishCompanyId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsAdditionalUncheckedUpdateManyWithoutMajorInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    wishCompanyId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyCreateManyBigJobKindInput = {
    id?: number
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    midJobKindId: number
    smallJobKindId: number
  }

  export type midJobKindCreateManyBigJobKindInput = {
    id?: number
    name: string
  }

  export type companyUpdateWithoutBigJobKindInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    midJobKind?: midJobKindUpdateOneRequiredWithoutCompanyNestedInput
    smallJobKind?: smallJobKindUpdateOneRequiredWithoutCompanyNestedInput
    incumebent?: incumbentsAdditionalUpdateManyWithoutCompanyNestedInput
    student?: studentsAdditionalUpdateManyWithoutWishCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutBigJobKindInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    midJobKindId?: IntFieldUpdateOperationsInput | number
    smallJobKindId?: IntFieldUpdateOperationsInput | number
    incumebent?: incumbentsAdditionalUncheckedUpdateManyWithoutCompanyNestedInput
    student?: studentsAdditionalUncheckedUpdateManyWithoutWishCompanyNestedInput
  }

  export type companyUncheckedUpdateManyWithoutBigJobKindInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    midJobKindId?: IntFieldUpdateOperationsInput | number
    smallJobKindId?: IntFieldUpdateOperationsInput | number
  }

  export type midJobKindUpdateWithoutBigJobKindInput = {
    name?: StringFieldUpdateOperationsInput | string
    company?: companyUpdateManyWithoutMidJobKindNestedInput
    smallJobKind?: smallJobKindUpdateManyWithoutMidJobKindNestedInput
  }

  export type midJobKindUncheckedUpdateWithoutBigJobKindInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    company?: companyUncheckedUpdateManyWithoutMidJobKindNestedInput
    smallJobKind?: smallJobKindUncheckedUpdateManyWithoutMidJobKindNestedInput
  }

  export type midJobKindUncheckedUpdateManyWithoutBigJobKindInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type companyCreateManyMidJobKindInput = {
    id?: number
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    bigJobKindId: number
    smallJobKindId: number
  }

  export type smallJobKindCreateManyMidJobKindInput = {
    id?: number
    name: string
  }

  export type companyUpdateWithoutMidJobKindInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    bigJobKind?: bigJobKindUpdateOneRequiredWithoutCompanyNestedInput
    smallJobKind?: smallJobKindUpdateOneRequiredWithoutCompanyNestedInput
    incumebent?: incumbentsAdditionalUpdateManyWithoutCompanyNestedInput
    student?: studentsAdditionalUpdateManyWithoutWishCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutMidJobKindInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    bigJobKindId?: IntFieldUpdateOperationsInput | number
    smallJobKindId?: IntFieldUpdateOperationsInput | number
    incumebent?: incumbentsAdditionalUncheckedUpdateManyWithoutCompanyNestedInput
    student?: studentsAdditionalUncheckedUpdateManyWithoutWishCompanyNestedInput
  }

  export type companyUncheckedUpdateManyWithoutMidJobKindInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    bigJobKindId?: IntFieldUpdateOperationsInput | number
    smallJobKindId?: IntFieldUpdateOperationsInput | number
  }

  export type smallJobKindUpdateWithoutMidJobKindInput = {
    name?: StringFieldUpdateOperationsInput | string
    company?: companyUpdateManyWithoutSmallJobKindNestedInput
  }

  export type smallJobKindUncheckedUpdateWithoutMidJobKindInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    company?: companyUncheckedUpdateManyWithoutSmallJobKindNestedInput
  }

  export type smallJobKindUncheckedUpdateManyWithoutMidJobKindInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type companyCreateManySmallJobKindInput = {
    id?: number
    name: string
    address: string
    longitude: number
    latitude: number
    scale: string
    bigJobKindId: number
    midJobKindId: number
  }

  export type companyUpdateWithoutSmallJobKindInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    bigJobKind?: bigJobKindUpdateOneRequiredWithoutCompanyNestedInput
    midJobKind?: midJobKindUpdateOneRequiredWithoutCompanyNestedInput
    incumebent?: incumbentsAdditionalUpdateManyWithoutCompanyNestedInput
    student?: studentsAdditionalUpdateManyWithoutWishCompanyNestedInput
  }

  export type companyUncheckedUpdateWithoutSmallJobKindInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    bigJobKindId?: IntFieldUpdateOperationsInput | number
    midJobKindId?: IntFieldUpdateOperationsInput | number
    incumebent?: incumbentsAdditionalUncheckedUpdateManyWithoutCompanyNestedInput
    student?: studentsAdditionalUncheckedUpdateManyWithoutWishCompanyNestedInput
  }

  export type companyUncheckedUpdateManyWithoutSmallJobKindInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    longitude?: FloatFieldUpdateOperationsInput | number
    latitude?: FloatFieldUpdateOperationsInput | number
    scale?: StringFieldUpdateOperationsInput | string
    bigJobKindId?: IntFieldUpdateOperationsInput | number
    midJobKindId?: IntFieldUpdateOperationsInput | number
  }

  export type incumbentsAdditionalCreateManyJobInput = {
    id?: number
    userId: number
    companyId?: number | null
    schoolId?: number | null
    majorId?: number | null
    bigJobId?: number | null
    midJobId?: number | null
    smallJobId?: number | null
    shortSpec?: string | null
    reportedNum?: number
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type studentsAdditionalCreateManyWishJobInput = {
    id?: number
    userId: number
    wishCompanyId?: number | null
    schoolId?: number | null
    majorId?: number | null
    wishBigJobId?: number | null
    wishMidJobId?: number | null
    wishSmallJobId?: number | null
    portfolio?: string | null
    reportedNum?: number
    totalGrade?: number | null
    adviceCount?: number
    estimationCount?: number
    updatedDate?: Date | string
  }

  export type incumbentsAdditionalUpdateWithoutJobInput = {
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutIncumbent_additionalNestedInput
    company?: companyUpdateOneWithoutIncumebentNestedInput
    school?: schoolUpdateOneWithoutIncumebentNestedInput
    major?: majorUpdateOneWithoutIncumebentNestedInput
  }

  export type incumbentsAdditionalUncheckedUpdateWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type incumbentsAdditionalUncheckedUpdateManyWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    companyId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    bigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    midJobId?: NullableIntFieldUpdateOperationsInput | number | null
    smallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    shortSpec?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsAdditionalUpdateWithoutWishJobInput = {
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutStudent_additionalNestedInput
    wishCompany?: companyUpdateOneWithoutStudentNestedInput
    school?: schoolUpdateOneWithoutStudentNestedInput
    major?: majorUpdateOneWithoutStudentNestedInput
  }

  export type studentsAdditionalUncheckedUpdateWithoutWishJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    wishCompanyId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type studentsAdditionalUncheckedUpdateManyWithoutWishJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    wishCompanyId?: NullableIntFieldUpdateOperationsInput | number | null
    schoolId?: NullableIntFieldUpdateOperationsInput | number | null
    majorId?: NullableIntFieldUpdateOperationsInput | number | null
    wishBigJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishMidJobId?: NullableIntFieldUpdateOperationsInput | number | null
    wishSmallJobId?: NullableIntFieldUpdateOperationsInput | number | null
    portfolio?: NullableStringFieldUpdateOperationsInput | string | null
    reportedNum?: IntFieldUpdateOperationsInput | number
    totalGrade?: NullableFloatFieldUpdateOperationsInput | number | null
    adviceCount?: IntFieldUpdateOperationsInput | number
    estimationCount?: FloatFieldUpdateOperationsInput | number
    updatedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsersCountOutputTypeDefaultArgs instead
     */
    export type UsersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostsCountOutputTypeDefaultArgs instead
     */
    export type PostsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentsCountOutputTypeDefaultArgs instead
     */
    export type CommentsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CompanyCountOutputTypeDefaultArgs instead
     */
    export type CompanyCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CompanyCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SchoolCountOutputTypeDefaultArgs instead
     */
    export type SchoolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SchoolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MajorCountOutputTypeDefaultArgs instead
     */
    export type MajorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MajorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BigJobKindCountOutputTypeDefaultArgs instead
     */
    export type BigJobKindCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BigJobKindCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MidJobKindCountOutputTypeDefaultArgs instead
     */
    export type MidJobKindCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MidJobKindCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SmallJobKindCountOutputTypeDefaultArgs instead
     */
    export type SmallJobKindCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SmallJobKindCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobCountOutputTypeDefaultArgs instead
     */
    export type JobCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use usersDefaultArgs instead
     */
    export type usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = usersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use incumbentsAdditionalDefaultArgs instead
     */
    export type incumbentsAdditionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = incumbentsAdditionalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use studentsAdditionalDefaultArgs instead
     */
    export type studentsAdditionalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = studentsAdditionalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use categoryDefaultArgs instead
     */
    export type categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = categoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use postsDefaultArgs instead
     */
    export type postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = postsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use commentsDefaultArgs instead
     */
    export type commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = commentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use recommendPostsDefaultArgs instead
     */
    export type recommendPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = recommendPostsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use reportedPostsDefaultArgs instead
     */
    export type reportedPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = reportedPostsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use recommendCommentsDefaultArgs instead
     */
    export type recommendCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = recommendCommentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use reportedCommentsDefaultArgs instead
     */
    export type reportedCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = reportedCommentsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use reportedUsersDefaultArgs instead
     */
    export type reportedUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = reportedUsersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use companyDefaultArgs instead
     */
    export type companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = companyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use schoolDefaultArgs instead
     */
    export type schoolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = schoolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use majorDefaultArgs instead
     */
    export type majorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = majorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use bigJobKindDefaultArgs instead
     */
    export type bigJobKindArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = bigJobKindDefaultArgs<ExtArgs>
    /**
     * @deprecated Use midJobKindDefaultArgs instead
     */
    export type midJobKindArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = midJobKindDefaultArgs<ExtArgs>
    /**
     * @deprecated Use smallJobKindDefaultArgs instead
     */
    export type smallJobKindArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = smallJobKindDefaultArgs<ExtArgs>
    /**
     * @deprecated Use jobDefaultArgs instead
     */
    export type jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = jobDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}